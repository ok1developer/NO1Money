
<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ระบบยืนยันตัวตนระดับพรีเมียม | บริการไฟแนนซ์</title>
    <link rel="icon" type="image/png" href="https://lh3.googleusercontent.com/d/1oW_pFaJ4AhgosP5mPhxXeQmPsYngtDwa">
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- SweetAlert2 -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sweetalert2@11/dist/sweetalert2.min.css">
    <!-- SwiperJS CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper@11/swiper-bundle.min.css" />
    <!-- ** ADDED: MediaPipe Dependencies ** -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <!-- heic2any Library -->
    <script src="https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js"></script>
  <script src="https://static.line-scdn.net/liff/edge/versions/2.21.0/sdk.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/browser-image-compression@2.0.2/dist/browser-image-compression.js"></script>

    <style>
        /* Added LINESeedSansTH font */
        @font-face {
          font-family: 'LINESeedSansTH';
          src: url('https://cdn.glitch.global/47bd20a5-ea68-4eee-b852-538d3eb2c0a4/LINESeedSansTH_W_Rg.woff?v=1729614138182') format('woff');
          font-weight: normal; /* 400 */
        }
        @font-face {
          font-family: 'LINESeedSansTH';
          src: url('https://cdn.glitch.global/47bd20a5-ea68-4eee-b852-538d3eb2c0a4/LINESeedSansTH_W_Bd.woff?v=1731156180172') format('woff');
          font-weight: bold; /* 700 */
        }

        :root {
            --primary-color: #9c27b0; /* Deep Purple */
            --primary-light: #ba68c8;
            --secondary-color: #7b1fa2; /* Darker Purple */
            --accent-color: #e91e63; /* Pink */
            --success-color: #4caf50; /* Green */
            --warning-color: #ff9800; /* Orange */
            --danger-color: #f44336; /* Red */
            --light-color: #f5f5f5;
            --dark-color: #212121;
            --gray-color: #757575;
            --info-color: #2196f3; /* Blue for info elements */
            --info-light: #e3f2fd;
            --border-radius: 16px; /* Slightly larger radius */
            --box-shadow: 0 10px 20px rgba(0, 0, 0, 0.15);
            --transition: all 0.3s ease-out; /* Faster transition */
            --glass-effect: rgba(255, 255, 255, 0.15);
            --pink-gradient: linear-gradient(135deg, #e91e63, #9c27b0);
            --purple-gradient: linear-gradient(135deg, #9c27b0, #673ab7);
            --gold-gradient: linear-gradient(135deg, #FFD700, #FFA500);
            /* ** ADDED/UPDATED: Guide Variables from Face Verification Source ** */
            --guide-color: rgba(255, 255, 255, 0.7); /* White guide frame color */
            --guide-overlay-bg: rgba(0, 0, 0, 0.55); /* Semi-transparent overlay background */
            --guide-invalid-color: rgba(244, 67, 54, 0.8); /* Red for invalid position */
            --guide-text-bg: rgba(0,0,0,0.7);
            --debug-text-bg: rgba(255, 152, 0, 0.8);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent; /* Prevent tap highlight on mobile */
        }

        html {
            scroll-behavior: smooth;
            height: 100%; /* Needed for fullscreen slider */
        }

        body {
            font-family: 'LINESeedSansTH', 'Prompt', sans-serif;
            line-height: 1.7;
            color: var(--dark-color);
            background: linear-gradient(135deg, #fafafa 0%, #f5f5f5 100%);
            min-height: 100vh;
            height: 100%; /* Needed for fullscreen slider */
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top for scroll */
            overflow: hidden; /* Prevent body scroll initially due to slider */
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* --- Fullscreen Slider Styles --- */
        #fullscreen-slider {
            position: fixed; /* Changed to fixed for true fullscreen */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%; /* Full viewport height */
            z-index: 1000; /* Ensure it's on top initially */
            background-color: var(--dark-color); /* Fallback background */
            display: block; /* Initially visible */
        }

        #fullscreen-slider .swiper {
            width: 100%;
            height: 100%;
        }

        #fullscreen-slider .swiper-slide {
            text-align: center;
            font-size: 18px;
            background: #fff; /* Default background for slide */
            display: flex;
            justify-content: center;
            align-items: flex-end; /* Align content to bottom */
            position: relative; /* Needed for overlay */
            background-size: cover;
            background-position: center;
            color: white; /* Default text color for overlay */
        }

        /* --- REPLACE THESE BACKGROUND IMAGES --- */
        #fullscreen-slider .swiper-slide:nth-child(1) { background-image: url('https://lh3.googleusercontent.com/d/1XQbZn5A8RC0xQ_cMHD00ZMzypsMY7EXu'); }
        #fullscreen-slider .swiper-slide:nth-child(2) { background-image: url('https://lh3.googleusercontent.com/d/1QgDvoG5QUEVm21N-12e4p5ABUAXR2eUi'); }
        #fullscreen-slider .swiper-slide:nth-child(3) { background-image: url('https://lh3.googleusercontent.com/d/1LVaYZ7hA-EMB5EBcfZ0f03t7QLAeuhB3'); }
        #fullscreen-slider .swiper-slide:nth-child(4) { background-image: url('https://lh3.googleusercontent.com/d/1_7rcsJeB9lgsBxgsrCguuwve6AKw4DKl'); }
        /* ------------------------------------- */

        #fullscreen-slider .slide-content {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(0deg, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0.6) 40%, rgba(0,0,0,0) 100%); /* Gradient overlay */
            padding: 60px 20px 30px 20px; /* Adjust padding (more space at top for buttons/text) */
            text-align: center;
        }

        #fullscreen-slider .slide-content h2 {
            font-size: 24px;
            margin-bottom: 10px;
            font-weight: bold;
            text-shadow: 0 1px 3px rgba(0,0,0,0.5);
        }

        #fullscreen-slider .slide-content p {
            font-size: 16px;
            margin-bottom: 25px;
            line-height: 1.5;
            max-width: 90%;
            margin-left: auto;
            margin-right: auto;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }

        #fullscreen-slider .slide-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center; /* Center buttons horizontally */
            width: 100%;
            max-width: 350px; /* Max width for buttons */
            margin: 0 auto;
        }

        #fullscreen-slider .slider-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 14px 24px;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-family: inherit;
            font-size: 16px;
            font-weight: bold;
            text-align: center;
            transition: var(--transition);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            width: 100%;
            -webkit-appearance: none;
        }

        #fullscreen-slider .slider-register-btn {
            background: var(--pink-gradient);
            color: white;
        }
         #fullscreen-slider .slider-register-btn:hover {
            background: var(--purple-gradient);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(156, 39, 176, 0.35);
        }

        #fullscreen-slider .slider-learn-more-btn {
            background-color: rgba(255, 255, 255, 0.9);
            color: var(--primary-color);
            border: 1px solid rgba(255,255,255,0.5);
        }
        #fullscreen-slider .slider-learn-more-btn:hover {
             background-color: white;
             color: var(--secondary-color);
             transform: translateY(-2px);
             box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        /* Swiper UI Customization */
        #fullscreen-slider .swiper-pagination-bullet {
            background-color: rgba(255, 255, 255, 0.6);
            opacity: 1;
            width: 10px;
            height: 10px;
            transition: all 0.3s ease;
        }

        #fullscreen-slider .swiper-pagination-bullet-active {
            background-color: white;
            transform: scale(1.2);
        }

        #fullscreen-slider .swiper-button-prev,
        #fullscreen-slider .swiper-button-next {
            color: white;
            background-color: rgba(0, 0, 0, 0.3);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            transition: background-color 0.3s ease;
        }
        #fullscreen-slider .swiper-button-prev:hover,
        #fullscreen-slider .swiper-button-next:hover {
             background-color: rgba(0, 0, 0, 0.5);
        }

        #fullscreen-slider .swiper-button-prev::after,
        #fullscreen-slider .swiper-button-next::after {
            font-size: 18px;
            font-weight: bold;
        }

        @media (max-width: 768px) {
            #fullscreen-slider .swiper-button-prev,
            #fullscreen-slider .swiper-button-next { display: none; } /* Hide arrows on smaller screens */

            #fullscreen-slider .slide-content { padding: 40px 15px 20px 15px; }
            #fullscreen-slider .slide-content h2 { font-size: 22px; }
            #fullscreen-slider .slide-content p { font-size: 15px; margin-bottom: 20px; }
            #fullscreen-slider .slider-btn { font-size: 15px; padding: 12px 20px; }
            #fullscreen-slider .slide-buttons { gap: 12px; }
        }


        /* --- Existing Registration Form Styles --- */
        .container {
            width: 100%;
            max-width: 100%; /* Full width on mobile */
            margin: 0 auto;
            perspective: 1000px;
            display: none; /* Hide registration form initially */
        }

        .registration-card {
            background: linear-gradient(145deg, rgba(255,255,255,0.95) 0%, rgba(255,255,255,0.98) 100%);
            border-radius: 0;
            box-shadow: none;
            overflow: hidden;
            margin-bottom: 0;
            position: relative;
            transform-style: preserve-3d;
            transition: var(--transition);
            backdrop-filter: blur(10px);
            border: none;
            min-height: 100vh;
            display: flex; /* Use flex for layout */
            flex-direction: column; /* Stack children vertically */
        }

        .card-header {
            background: var(--purple-gradient);
            color: white;
            padding: 20px;
            text-align: center;
            position: relative;
            overflow: hidden;
            clip-path: polygon(0 0, 100% 0, 100% 90%, 0 100%);
            flex-shrink: 0; /* Prevent header from shrinking */
            padding-top: 40px; /* Added padding to compensate for removed progress steps */
            padding-bottom: 30px;
        }

        .card-header h1 {
            font-size: 24px;
            margin-bottom: 10px;
            position: relative;
            z-index: 1;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
            font-weight: bold; /* Use bold weight */
        }

        .card-header p {
            opacity: 0.9;
            font-size: 14px;
            position: relative;
            z-index: 1;
            max-width: 90%;
            margin: 0 auto;
        }

        .logo {
            width: 60px;
            height: 60px;
            background: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            position: relative;
            z-index: 1;
        }

        .logo i {
            font-size: 28px;
            background: var(--pink-gradient);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .step-icon {
            margin-right: 8px;
        }

        h2, h3, h4 {
            font-weight: bold; /* Use bold for headings */
        }

        .card-body {
            padding: 20px;
            position: relative;
            flex-grow: 1; /* Allow body to take remaining space */
            overflow-y: auto; /* Allow scrolling within card body if needed */
            overflow-x: hidden; /* Prevent horizontal scroll */
        }

        .form-step {
            display: none;
            opacity: 1; /* Start visible for animation */
            transform: translateX(0);
        }

        .form-step.active {
            display: block;
        }

        .form-group {
            margin-bottom: 20px;
            position: relative;
        }

        .form-row {
            display: flex;
            flex-wrap: wrap;
            margin: 0 -8px; /* Smaller gap */
        }

        .form-col {
            flex: 1 1 100%; /* Default to full width */
            padding: 0 8px; /* Smaller gap */
        }

        @media (min-width: 600px) { /* Adjust breakpoint as needed */
             .form-col {
                 flex: 1 1 50%; /* Two columns on larger screens */
             }
        }


        label {
            display: block;
            margin-bottom: 8px; /* Smaller margin */
            font-weight: bold; /* Use bold for labels */
            color: var(--dark-color);
            font-size: 14px;
            position: relative;
        }

        .required-field::after {
            content: '*';
            color: var(--danger-color);
            margin-left: 4px;
            font-size: 16px;
        }

        input, select, textarea {
            width: 100%;
            padding: 14px 16px;
            border: 1px solid #ccc; /* Thinner border */
            border-radius: var(--border-radius);
            font-family: inherit; /* Inherit LINESeedSansTH */
            font-size: 16px;
            transition: var(--transition);
            background-color: #fff; /* White background */
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.06); /* Subtle inset shadow */
            appearance: none; /* Remove default styling */
             -webkit-appearance: none;
             -moz-appearance: none;
        }
        /* Style select dropdown arrow */
         select {
             background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23757575' width='18px' height='18px'%3E%3Cpath d='M7 10l5 5 5-5z'/%3E%3C/svg%3E");
             background-repeat: no-repeat;
             background-position: right 16px center;
             background-size: 18px;
             padding-right: 40px; /* Space for arrow */
         }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(156, 39, 176, 0.15), inset 0 1px 3px rgba(0,0,0,0.06); /* Adjusted focus shadow */
            background-color: white;
        }
        /* Style for readonly inputs */
        input:read-only, textarea:read-only {
            background-color: #eee;
            cursor: not-allowed;
            opacity: 0.8;
            box-shadow: none;
        }
        /* Style disabled elements */
        input:disabled, select:disabled, textarea:disabled {
            background-color: #eee;
            opacity: 0.7;
            cursor: not-allowed;
        }

        .input-with-icon {
            position: relative;
        }

        .input-with-icon i.validation-icon { /* Specific class for validation icons */
            position: absolute;
            top: 50%;
            right: 16px;
            transform: translateY(-50%);
            color: var(--gray-color);
            transition: var(--transition);
            font-size: 18px;
             z-index: 2; /* Ensure icon is above input */
            pointer-events: none; /* Don't block input focus */
        }

        input:focus + i.validation-icon {
            color: var(--primary-color);
        }

        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 14px 24px;
            background: var(--pink-gradient);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-family: inherit; /* Inherit LINESeedSansTH */
            font-size: 16px;
            font-weight: bold; /* Use bold for buttons */
            text-align: center;
            transition: var(--transition);
            box-shadow: 0 4px 10px rgba(156, 39, 176, 0.3);
            position: relative;
            overflow: hidden;
            width: 100%;
             -webkit-appearance: none; /* Remove default button styles on iOS */
        }

        .btn:hover:not(:disabled) { /* Add :not(:disabled) */
            background: var(--purple-gradient);
            transform: translateY(-2px); /* Smaller lift */
            box-shadow: 0 6px 12px rgba(156, 39, 176, 0.35); /* Adjusted shadow */
        }

        .btn:active:not(:disabled) { /* Add :not(:disabled) */
            transform: translateY(0);
             box-shadow: 0 3px 8px rgba(156, 39, 176, 0.25); /* Adjusted active shadow */
        }
        .btn:disabled {
             opacity: 0.6;
             cursor: not-allowed;
             background: var(--gray-color);
             box-shadow: none;
             transform: none;
         }

        .btn-outline {
            background: transparent;
            border: 2px solid var(--primary-color);
            color: var(--primary-color);
            box-shadow: none;
        }

        .btn-outline:hover:not(:disabled) { /* Add :not(:disabled) */
            background: rgba(156, 39, 176, 0.05); /* Lighter hover background */
            transform: translateY(-2px);
            color: var(--primary-color);
             box-shadow: 0 2px 5px rgba(156, 39, 176, 0.1); /* Add subtle shadow on hover */
        }
         .btn-outline:disabled {
             border-color: var(--gray-color);
             color: var(--gray-color);
             background: transparent;
             opacity: 0.6;
             cursor: not-allowed;
             transform: none;
             box-shadow: none;
         }

        /* Standard button group - Primary first */
        .btn-group {
            display: flex;
            flex-direction: column; /* Stack buttons */
            gap: 12px;
            margin-top: 30px;
        }


        .btn-block {
            display: block;
            width: 100%;
        }

        .upload-area {
            border: 2px dashed #bdbdbd;
            border-radius: var(--border-radius);
            padding: 25px;
            text-align: center;
            cursor: pointer;
            transition: var(--transition);
            margin-bottom: 15px;
            background-color: rgba(255,255,255,0.7);
            position: relative;
            overflow: hidden;
             min-height: 150px; /* Ensure minimum height */
             display: flex;
             flex-direction: column;
             align-items: center;
             justify-content: center;
        }
        .upload-area.disabled { /* Style for disabled upload area */
            cursor: not-allowed;
            background-color: #f0f0f0;
            opacity: 0.7;
            border-color: #ccc;
        }
        .upload-area.disabled:hover { /* Prevent hover effect when disabled */
             border-color: #ccc;
             background-color: #f0f0f0;
        }
        .upload-area:not(.disabled):hover {
            border-color: var(--primary-color);
            background-color: rgba(156, 39, 176, 0.03); /* Even lighter hover */
        }
         .upload-area.dragover { /* Style when dragging over */
             border-color: var(--primary-color);
             background-color: rgba(156, 39, 176, 0.05);
             border-style: solid;
         }

        .upload-area i {
            font-size: 40px;
            color: var(--primary-color);
            margin-bottom: 15px;
            transition: var(--transition);
        }
        .upload-area.disabled i { color: var(--gray-color); }

        .upload-area p {
            margin-bottom: 10px;
            color: var(--dark-color);
            font-weight: bold; /* Use bold weight */
            font-size: 14px;
        }
        .upload-area.disabled p { color: var(--gray-color); }

        .upload-area small {
            color: var(--gray-color);
            font-size: 12px;
        }

        .preview-container {
            display: flex; /* Changed to flex for easier centering */
            justify-content: center; /* Center card horizontally */
            margin-top: 15px;
        }


        .preview-card {
            width: 100%; /* Full width for single card */
            max-width: 400px; /* Optional max width */
            border: 1px solid #e0e0e0; /* Thinner border */
            border-radius: var(--border-radius);
            overflow: hidden;
            position: relative;
            transition: var(--transition);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.08); /* Slightly larger shadow */
            background: white;
        }

        .preview-image {
            width: 100%;
             aspect-ratio: 16 / 10; /* Adjust aspect ratio for ID cards/faces */
            object-fit: cover;
            border-bottom: 1px solid #eee;
            display: block; /* Remove extra space below image */
        }
        /* Style for video preview */
        #video-preview.preview-image {
            aspect-ratio: 16 / 9; /* Standard video aspect ratio */
            background-color: #000; /* Black background for video */
        }


        .preview-info {
            padding: 10px 12px; /* Smaller padding */
            background-color: white;
            text-align: center;
        }

        .preview-info p {
            font-size: 12px; /* Smaller font */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-weight: bold; /* Use bold weight */
            color: var(--dark-color);
            margin: 0; /* Remove default margin */
        }

        .remove-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 28px; /* Slightly larger */
            height: 28px;
            background-color: rgba(244, 67, 54, 0.8); /* Slightly transparent */
            color: white;
            border: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 12px; /* Adjust icon size */
            transition: var(--transition);
            opacity: 0.9;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            z-index: 5; /* Ensure it's above preview image */
        }

        .remove-btn:hover {
            opacity: 1;
            transform: scale(1.1);
            background-color: var(--danger-color); /* Solid on hover */
        }

        .ocr-result {
            background-color: #f9f9f9; /* Lighter background */
            border-radius: var(--border-radius);
            padding: 20px; /* Increased padding */
            margin-top: 20px;
            border-left: 4px solid var(--primary-light); /* Lighter border color */
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .ocr-result h4 {
            margin-bottom: 15px; /* Increased margin */
            color: var(--primary-color);
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 18px; /* Slightly larger */
            font-weight: bold; /* Bold */
        }

        .face-verification {
            text-align: center;
            margin-top: 20px; /* Reduced margin */
            background: #fff; /* White background */
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: 0 5px 15px rgba(0,0,0,0.08); /* Softer shadow */
        }

        /* --- Webcam & Overlay Styles (Combined/Adjusted) --- */
        .webcam-container {
            width: 100%;
            max-width: 480px; /* Max width for webcam */
            aspect-ratio: 4 / 3; /* Common webcam aspect ratio */
            margin: 0 auto 15px; /* Reduced bottom margin */
            border-radius: var(--border-radius);
            overflow: hidden;
            position: relative;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
            border: 1px solid #ddd; /* Thinner border */
            background-color: #212121; /* Background while loading */
        }
        @media (max-width: 480px) {
            .webcam-container {
                 aspect-ratio: 3 / 4; /* More portrait on mobile */
             }
        }

        #webcam-face, #webcam-video {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Cover the container */
            display: block;
            transform: scaleX(-1); /* Mirror image */
        }

        /* Face Capture Overlay */
        #webcam-face-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(33, 33, 33, 0.6); /* From face verification */
            color: #fff;
            font-size: 16px;
            opacity: 1; /* Show initially by default */
            transition: opacity 0.4s ease;
            padding: 20px;
            text-align: center;
            pointer-events: none;
            z-index: 1; /* Behind face guide frame */
        }
        /* Hide overlay when playing */
        #webcam-container-face.playing #webcam-face-overlay {
             opacity: 0;
        }

        .capture-btn {
            margin: 15px auto;
            padding: 12px 30px;
            border-radius: 50px;
            font-weight: bold; /* Use bold weight */
            letter-spacing: 0.5px;
        }

        .hidden {
            display: none !important; /* Use important to override potential conflicts */
        }

        .status-pending {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background-color: #fff8e1;
            color: #ff8f00;
            border-radius: var(--border-radius);
            font-size: 14px;
            font-weight: bold; /* Use bold weight */
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }

        .status-approved {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background-color: #e8f5e9;
            color: #2e7d32;
            border-radius: var(--border-radius);
            font-size: 14px;
            font-weight: bold; /* Use bold weight */
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }

        .otp-container {
            display: flex;
            justify-content: center;
            gap: 8px; /* Smaller gap */
            margin-top: 20px;
        }

        /* OTP Input Styling Adjustment */
        .otp-input {
            width: 48px; /* Adjusted size */
            height: 58px; /* Adjusted size */
            text-align: center;
            font-size: 22px; /* Slightly smaller font */
            border: 1px solid #ccc; /* Thinner border */
            border-radius: 12px; /* Smaller radius */
            transition: var(--transition);
            font-weight: bold; /* Use bold weight */
            color: var(--primary-color);
            padding: 0; /* Remove padding */
            line-height: 56px; /* Vertically center text */
            background-color: #fff;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.06);
            caret-color: var(--primary-color); /* Make caret visible */
             appearance: none; /* Remove default spinner */
             -webkit-appearance: none;
             -moz-appearance: textfield; /* Firefox */
        }
         /* Remove spinner buttons on number inputs */
         .otp-input::-webkit-outer-spin-button,
         .otp-input::-webkit-inner-spin-button {
             -webkit-appearance: none;
             margin: 0;
         }


        .otp-input:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(156, 39, 176, 0.15), inset 0 1px 3px rgba(0,0,0,0.06);
            outline: none;
            background-color: white;
        }

        .otp-input.filled {
            border-color: var(--primary-color); /* Use primary color when filled */
        }
         .otp-input.error { /* Style for incorrect OTP */
            border-color: var(--danger-color);
             animation: shake 0.4s; /* Add shake on error */
         }


        .resend-otp {
            margin-top: 15px;
            text-align: center;
            color: var(--gray-color);
            font-size: 14px;
        }

        .resend-otp a {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: bold; /* Use bold weight */
            cursor: pointer;
            transition: var(--transition);
            position: relative;
        }
        .resend-otp a:hover {
            color: var(--secondary-color);
            text-decoration: underline;
        }
        .resend-otp a.disabled { /* Style for disabled link */
             pointer-events: none;
             opacity: 0.5;
             text-decoration: none; /* Remove underline when disabled */
         }

        .security-badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 15px;
            background-color: var(--info-light);
            color: #1565c0;
            border-radius: var(--border-radius);
            font-size: 13px;
            font-weight: bold; /* Use bold weight */
            border: 1px solid #bbdefb;
            margin-top: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }

        .success-message {
            text-align: center;
            padding: 30px 20px;
            background: #fff; /* White background */
            border-radius: var(--border-radius);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            margin: 15px 0;
        }

        .success-message i.success-icon { /* Specific class for the icon */
            font-size: 60px;
            margin-bottom: 20px;
            color: var(--success-color); /* Use success color directly */
            display: inline-block;
        }

        .success-message h2 {
            margin-bottom: 15px;
            color: var(--primary-color);
            font-size: 22px;
            font-weight: bold; /* Use bold weight */
        }

        .success-message p {
            margin-bottom: 15px;
            color: var(--dark-color);
            font-size: 15px;
            line-height: 1.6;
            max-width: 100%;
            margin-left: auto;
            margin-right: auto;
        }

        /* Video Recording Section */
        .video-recording-container {
            margin-top: 25px; /* Adjusted margin */
            padding-top: 20px;
        }
         .video-recording-container h4 {
            font-size: 18px;
            color: var(--primary-color);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: bold; /* Bolder heading */
         }

        .recording-indicator {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background-color: #ffebee;
            color: #c62828;
            border-radius: 20px;
            font-size: 13px;
            position: absolute;
            top: 15px;
            left: 15px;
            z-index: 4;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        .video-recording-container.active .recording-indicator {
            opacity: 1;
        }

        .recording-indicator .pulse-dot {
            width: 8px;
            height: 8px;
            background-color: #c62828;
            border-radius: 50%;
            animation: pulse-rec 1.5s infinite ease-in-out; /* Renamed animation */
        }
        @keyframes pulse-rec { /* Renamed animation */
            0%, 100% { box-shadow: 0 0 0 0 rgba(198, 40, 40, 0.7); }
            50% { box-shadow: 0 0 0 6px rgba(198, 40, 40, 0); }
        }

        /* Karaoke-style instruction container */
        #recording-instruction-container {
             position: absolute;
             bottom: 15px;
             left: 50%;
             transform: translateX(-50%);
             width: 90%;
             max-width: 450px;
             background-color: var(--guide-text-bg);
             padding: 10px 15px;
             border-radius: 8px;
             text-align: center;
             z-index: 3;
             pointer-events: none;
             color: white;
             font-weight: bold; /* Use bold weight */
             font-size: 16px;
             text-shadow: 0 1px 2px rgba(0,0,0,0.8);
             transition: opacity 0.3s ease, transform 0.3s ease;
             opacity: 0; /* Start hidden */
         }
         #recording-instruction-container.visible {
             opacity: 1;
             transform: translateX(-50%) translateY(0);
         }
         @media (max-width: 480px) {
             #recording-instruction-container {
                font-size: 14px;
                padding: 8px 10px;
                bottom: 10px;
             }
         }

        .action-buttons {
            display: flex;
            gap: 12px;
            margin-top: 15px;
        }
        /* ** ADDED ** Style for face capture buttons to make them stacked */
         #face-capture-section .action-buttons {
            flex-direction: column;
            align-items: center;
         }
         #face-capture-section .action-buttons .btn,
         #face-capture-section .action-buttons .btn-outline {
             width: 80%; max-width: 300px;
         }
         /* Style for video recording buttons (default row layout) */
         #video-recording-section .action-buttons {
            flex-direction: row;
            justify-content: center;
         }
         #video-recording-section .action-buttons .btn {
             width: auto; /* Reset width */
             max-width: none;
         }


        .pdpa-agreement {
            background-color: #f9f9f9; /* Lighter */
            border: 1px solid #eee; /* Lighter border */
            border-radius: var(--border-radius);
            padding: 15px;
            margin: 20px 0; /* Add margin */
        }

        /* Scrollable container for PDPA text */
        .pdpa-scroll-container {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            background-color: #fff;
            font-size: 14px;
            line-height: 1.6;
        }
        .pdpa-scroll-container h3 {
            font-size: 18px;
            color: var(--primary-color);
            margin-bottom: 15px;
            text-align: center;
            font-weight: bold; /* Bold */
        }
        .pdpa-scroll-container h4 {
            font-size: 16px;
            color: var(--secondary-color);
            margin-top: 15px;
            margin-bottom: 10px;
            font-weight: bold; /* Bold */
        }
         .pdpa-scroll-container p, .pdpa-scroll-container li {
             margin-bottom: 10px;
             color: var(--dark-color);
         }
         .pdpa-scroll-container ul, .pdpa-scroll-container ol {
             padding-left: 25px; /* Standard indent */
             margin-left: 15px; /* Ensure lists are indented */
         }
        .pdpa-scroll-container strong {
             font-weight: bold; /* Use bold weight */
             color: var(--secondary-color);
         }
         /* Style for the list-like structure in section 5 */
         .pdpa-scroll-container .purpose-item {
             margin-bottom: 15px;
             padding-left: 5px;
         }
         .pdpa-scroll-container .purpose-item h4 {
             margin-top: 0;
             margin-bottom: 5px;
             font-size: 15px; /* Slightly smaller than regular h4 */
             color: var(--secondary-color);
         }
         .pdpa-scroll-container .purpose-item p {
             margin-bottom: 0;
             font-size: 14px;
         }
         /* Style for the list-like structure in section 10 */
         .pdpa-scroll-container .right-item {
             margin-bottom: 15px;
             padding-left: 5px;
         }
         .pdpa-scroll-container .right-item h4 {
             margin-top: 0;
             margin-bottom: 5px;
             font-size: 15px;
             color: var(--secondary-color);
         }
         .pdpa-scroll-container .right-item p {
             margin-bottom: 0;
             font-size: 14px;
         }

        .pdpa-checkbox {
            display: flex;
            align-items: flex-start; /* Align items to the start */
            margin-bottom: 12px;
        }

        /* Refined PDPA Checkbox Style */
        .pdpa-checkbox input[type="checkbox"] {
            width: 18px;
            height: 18px;
            margin-right: 12px;
            margin-top: 3px; /* Adjust vertical alignment */
            flex-shrink: 0;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 4px;
            display: inline-block; /* Ensure it's an inline block */
            position: relative; /* Needed for absolute positioning of ::after */
            transition: background-color 0.2s, border-color 0.2s;
            vertical-align: top; /* Align with the top of the text */
        }

        .pdpa-checkbox input[type="checkbox"]:checked {
            background-color: var(--primary-color);
            border-color: var(--primary-color);
        }

        /* The checkmark */
        .pdpa-checkbox input[type="checkbox"]:checked::after {
            content: '';
            position: absolute;
            /* Adjust positioning carefully */
            left: 6px;
            top: 2px;
            width: 5px;
            height: 10px;
            border: solid white;
            border-width: 0 2px 2px 0; /* Right and bottom borders */
            transform: rotate(45deg);
            display: block; /* Ensure it's displayed */
        }

        .pdpa-text {
            font-size: 14px;
            color: var(--dark-color);
            line-height: 1.6;
            cursor: pointer;
            flex-grow: 1; /* Allow text to take remaining space */
        }

        .pdpa-link {
            color: var(--primary-color);
            text-decoration: underline;
            font-weight: bold; /* Use bold weight */
        }

        .pdpa-link:hover {
            color: var(--secondary-color);
        }

        /* ** ADDED from Face Verification Source ** */
        .flash-effect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white; /* Changed from #fff */
            opacity: 0;
            pointer-events: none;
            z-index: 1000; /* Ensure it's above other content */
            transition: opacity 0.3s ease-out; /* Match transition */
        }

        .flash {
            animation: flash 0.5s;
        }

        @keyframes flash {
            0% { opacity: 0; background: #fff; }
            50% { opacity: .8; background: #fff; }
            100% { opacity: 0; background: #fff; }
        }
        /* ** END ADDED from Face Verification Source ** */

        .pin-code-container {
            margin-top: 15px;
        }

        .id-card-guide {
            background-color: var(--info-light);
            border-radius: var(--border-radius);
            padding: 15px;
            margin-bottom: 15px;
            border-left: 4px solid var(--info-color);
        }

        .id-card-guide h4 {
            color: #1565c0;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 16px;
            font-weight: bold; /* Bold */
        }

        .id-card-guide ul {
            padding-left: 20px;
            margin-bottom: 0;
            list-style: disc;
        }

        .id-card-guide li {
            margin-bottom: 6px;
            font-size: 13px;
            color: #1e88e5;
        }

        .btn-3d {
            position: relative;
            transform-style: preserve-3d;
            transition: all 0.3s ease;
            box-shadow: 0 3px 10px rgba(156, 39, 176, 0.4);
        }

        .btn-3d:hover:not(:disabled) {
            transform: translateY(-3px) rotateX(5deg);
            box-shadow: 0 5px 15px rgba(156, 39, 176, 0.5);
        }

        .btn-3d:active:not(:disabled) {
            transform: translateY(0) rotateX(0);
            box-shadow: 0 3px 10px rgba(156, 39, 176, 0.4);
        }

        .otp-reference {
            background-color: #f5f5f5;
            border-radius: var(--border-radius);
            padding: 12px;
            margin-top: 15px;
            text-align: center;
            font-size: 13px;
            color: var(--gray-color);
            border: 1px solid #eee;
            /* Initially hidden, shown by JS when ref number is available */
            display: none;
        }

        .otp-reference strong {
            color: var(--primary-color);
            font-weight: bold; /* Use bold weight */
        }

        .shake {
            animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both; /* Smoother shake */
        }

        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-3px, 0, 0); } /* Adjust shake intensity */
            40%, 60% { transform: translate3d(3px, 0, 0); }
        }

        @keyframes pulse { /* Keep original pulse for success check */
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        .liff-header {
            position: relative;
        }

        .premium-badge {
            background: var(--gold-gradient);
            color: white;
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold; /* Use bold weight */
            display: inline-block;
            margin-left: 8px;
            vertical-align: middle;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .input-label {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .input-label i {
            color: var(--primary-color);
            width: 1.2em;
             text-align: center;
            font-size: 1.1em;
        }

        /* PIN Keypad Styling Improvements */
        .numeric-keyboard {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-top: 20px;
        }

        .numeric-key {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 55px;
            background-color: #fff;
            border-radius: var(--border-radius);
            font-size: 24px;
            font-weight: normal; /* Regular weight for numbers */
            cursor: pointer;
            transition: background-color 0.15s ease, transform 0.1s ease;
            user-select: none;
            border: 1px solid #e0e0e0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.07);
            color: var(--dark-color);
        }

        .numeric-key:hover { background-color: #f5f5f5; }
        .numeric-key:active {
            background-color: #eee;
            transform: scale(0.95);
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }
        .numeric-key.backspace {
            font-size: 22px;
            color: var(--primary-color);
            background-color: #f9f9f9;
        }
         .numeric-key.backspace i { font-weight: bold; } /* Make icon bolder */
         .numeric-key.backspace:hover { background-color: #f0f0f0; }
         .numeric-key.backspace:active { background-color: #e8e8e8; }
        .numeric-key.placeholder {
            background-color: transparent;
            box-shadow: none;
            border: none;
            cursor: default;
            pointer-events: none;
        }

        .keyboard-container {
            background-color: #fdfdfd;
            border-radius: var(--border-radius);
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.08);
            border: 1px solid #f0f0f0;
        }

        .keyboard-title {
            text-align: center;
            margin-bottom: 15px;
            color: var(--gray-color);
            font-size: 14px;
            font-weight: bold; /* Use bold weight */
        }

        .pin-input-container { position: relative; }
        .pin-input-fields {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 25px;
        }
        .pin-input-field {
            width: 42px;
            height: 55px;
            border: 1px solid #ccc;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold; /* Use bold weight */
            transition: var(--transition), transform 0.2s ease;
            background-color: #fff;
        }
        .pin-input-field.active {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(156, 39, 176, 0.15);
             transform: scale(1.05);
        }
        .pin-input-field.filled { border-color: var(--primary-color); }
        .pin-input-dot {
            width: 12px;
            height: 12px;
            background-color: var(--dark-color);
            border-radius: 50%;
            opacity: 0;
            transition: opacity 0.2s ease-in-out, transform 0.2s ease;
            transform: scale(0.5);
        }
        .pin-input-field.filled .pin-input-dot {
             opacity: 1;
             transform: scale(1);
             animation: fillDot 0.2s ease-out forwards;
         }
        @keyframes fillDot { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        .keyboard-note {
            text-align: center;
            font-size: 13px;
            color: var(--gray-color);
            margin-top: 15px;
        }

        /* Step Transition Animations */
        .form-step {
             /* Default state, ready for animation */
            opacity: 1;
            transform: translateX(0);
        }
         .form-step.slide-out-left { animation: slideOutLeft 0.4s ease-in forwards; }
         .form-step.slide-in-right { animation: slideInRight 0.4s ease-out forwards; }
         .form-step.slide-in-left { animation: slideInLeft 0.4s ease-out forwards; }
         .form-step.slide-out-right { animation: slideOutRight 0.4s ease-in forwards; }

        @keyframes slideInRight { from { opacity: 0; transform: translateX(40px); } to { opacity: 1; transform: translateX(0); } }
        @keyframes slideOutLeft { from { opacity: 1; transform: translateX(0); } to { opacity: 0; transform: translateX(-40px); } }
        @keyframes slideInLeft { from { opacity: 0; transform: translateX(-40px); } to { opacity: 1; transform: translateX(0); } }
        @keyframes slideOutRight { from { opacity: 1; transform: translateX(0); } to { opacity: 0; transform: translateX(40px); } }

        /* Camera Guide Styles (ID Card) */
        .camera-guide {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 2;
            background-color: rgba(0, 0, 0, 0.65); /* Darker overlay */
            display: flex; align-items: center; justify-content: center; flex-direction: column;
            opacity: 0; transition: opacity 0.3s ease;
        }
        .camera-guide.visible { opacity: 1; }
        .id-card-frame { /* Rectangular frame */
            width: 85%; height: 58%; /* Aspect ratio closer to ID card */
            border: 3px dashed var(--primary-color); /* Use primary color for consistency */
            border-radius: 10px; pointer-events: none; z-index: 2;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.65); /* Cutout effect */
        }
        .id-card-guide-text { /* Text inside the frame for ID card */
             position: absolute;
             bottom: 15px; /* Position inside */
             left: 50%; transform: translateX(-50%);
             width: 85%; text-align: center; color: white; font-weight: bold;
             text-shadow: 0 1px 3px rgba(0,0,0,0.7); padding: 5px 8px;
             background-color: var(--guide-text-bg); border-radius: 4px;
             pointer-events: none; z-index: 3; font-size: 13px;
         }

        /* --- ** ADDED/MERGED: Face Verification Styles ** --- */
        /* Face Guide Frame (From Source) */
        #face-guide-frame {
            position: absolute; top: 10%; left: 15%; width: 70%; height: 80%;
            border-radius: 50% / 50%; /* Oval shape */
            box-shadow: 0 0 0 2000px var(--guide-overlay-bg); /* Overlay effect */
            border: 3px dashed var(--guide-color); /* Make border thicker */
            pointer-events: none; z-index: 2; /* Ensure above video, below text */
            opacity: 0; /* Start hidden */
            transition: opacity 0.4s ease-out, border-color 0.3s ease-out; /* Add border-color transition */
        }
        #face-guide-frame.visible { opacity: 1; }
        #face-guide-frame.invalid { border-color: var(--guide-invalid-color); }

        /* Text Overlays (From Source, Adjusted Positions) */
        .face-action-text, .face-status-text, .face-countdown-text {
            position: absolute; left: 50%; transform: translateX(-50%); color: #fff;
            font-weight: bold; z-index: 3; /* Above guide frame */
            white-space: nowrap; box-shadow: 0 3px 8px rgba(0,0,0,0.4);
            transition: background-color 0.3s ease, transform 0.3s ease, opacity 0.3s ease;
            pointer-events: none; /* Make sure text doesn't block video interaction */
        }
        .face-action-text {
            bottom: 15px; background: var(--guide-text-bg); font-size: 16px;
            padding: 10px 20px; border-radius: 25px;
            display: inline-flex; align-items: center;
        }
        .face-action-text.detected {
            background-color: var(--info-color); transform: translateX(-50%) scale(1.05);
        }
        .face-status-text {
            bottom: 75px; /* Position above action text */
            background: var(--warning-color); font-size: 13px;
            padding: 6px 12px; border-radius: 15px;
        }
        .face-status-text.frame-issue {
            background-color: var(--danger-color); /* Red background for frame issue */
        }
        .face-countdown-text {
             top: 10px; /* Position near top */
             background: var(--success-color);
             padding: 6px 12px; border-radius: 15px; font-size: 14px;
             box-shadow: 0 2px 5px rgba(0,0,0,0.3);
         }
         #debug-info {
            position: absolute; top: 5px; right: 5px; left: auto;
            background: var(--debug-text-bg); color: white; padding: 4px 6px; font-size: 10px;
            border-radius: 4px; z-index: 4; opacity: 0.8;
            font-family: monospace; white-space: pre; text-align: left;
        }
        /* Face Gallery Styles (From Source) */
        .captured-faces-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
            justify-content: center;
        }
        .captured-faces-container .preview-card {
            width: calc(33.33% - 7px); /* Adjust based on source */
            border: 1px solid #e0e0e0;
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: 0 3px 10px rgba(0,0,0,0.08);
            background: #fff;
            position: relative;
            max-width: none; /* Override potential max-width */
        }
        @media(max-width:600px) { .captured-faces-container .preview-card { width:calc(50% - 5px); } }
        @media(max-width:400px) { .captured-faces-container .preview-card { width:100%; } }
        .captured-faces-container .preview-image {
            width:100%; aspect-ratio:4/3; /* Match source aspect ratio */
            object-fit:cover; border-bottom:1px solid #eee; display:block; background-color: #eee;
        }
        .captured-faces-container .preview-info {
            padding: 8px 10px; background:#fff; text-align:center;
        }
        .captured-faces-container .preview-info p {
            font-size:11px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; font-weight:bold; color:var(--dark-color); margin: 0; line-height: 1.3;
        }
        /* --- END ADDED/MERGED --- */


        /* Duplicate Warning Styling */
        .duplicate-warning {
            color: var(--danger-color);
            font-size: 13px;
            margin-top: 6px; /* Slightly more space */
            display: none; /* Controlled by JS */
            align-items: center;
            gap: 5px;
            padding-left: 2px; /* Slight indent */
        }
        .duplicate-warning i { font-size: 14px; }

        /* Birthdate Fields Styling */
        .birthdate-fields { display: flex; gap: 10px; }
        .birthdate-field { flex: 1; }

        .text-muted { color: var(--gray-color); font-size: 14px; }

        /* Style for face capture section container */
        #face-capture-section { margin-bottom: 20px; }

        /* Style SweetAlert buttons and content */
        .swal2-confirm {
            font-weight: bold !important; /* Ensure confirm button is bold */
        }
        .swal2-cancel {
            font-weight: normal !important; /* Keep cancel button normal */
        }
        /* Ensure video fits well in SweetAlert */
        .swal2-html-container video,
        .swal2-html-container iframe { /* Added iframe */
            max-width: 100%;
            height: auto;
            border-radius: 8px; /* Optional: rounded corners */
            margin-top: 10px; /* Space above video/iframe */
            aspect-ratio: 16 / 9; /* Maintain aspect ratio */
        }
        .swal2-html-container p {
            margin-bottom: 10px;
            line-height: 1.6;
        }
        /* Style disabled confirm button */
        .swal2-confirm:disabled {
            background-color: #aaa !important; /* Gray background */
            color: #eee !important; /* Lighter text */
            cursor: not-allowed !important;
        }


        /* --- Added Styles for Map --- */
        #map-container {
             margin-top: 15px;
             border-radius: var(--border-radius);
             overflow: hidden; /* Keeps map rounded */
             border: 1px solid #eee;
             box-shadow: 0 2px 5px rgba(0,0,0,0.05);
         }
         #map {
             height: 250px; /* Adjust height as needed */
             width: 100%;
             z-index: 1; /* Ensure map is below any potential absolute overlays if needed later */
         }
         #get-location-btn {
            width: auto; /* Don't make it full width */
            padding: 10px 16px;
            font-size: 14px;
            margin-top: 10px;
         }
         /* Ensure Leaflet popup content uses the primary font */
        .leaflet-popup-content-wrapper {
            font-family: 'LINESeedSansTH', 'Prompt', sans-serif !important;
        }
        .leaflet-popup-content p {
             margin: 5px 0 !important;
        }
         .location-status {
            font-size: 13px;
            margin-top: 8px;
            color: var(--gray-color);
         }

         /* Mobile Adjustments */
        @media (max-width: 480px) {
             /* ... other mobile styles ... */
             .pdpa-checkbox input[type="checkbox"]:checked::after {
                 left: 5px; /* Adjust checkmark position */
                 top: 1px;
                 width: 4px;
                 height: 9px;
             }
            .pdpa-text { font-size: 13px; }
            .card-header h1 { font-size: 20px; }
            .card-header p { font-size: 13px; }
            .form-group { margin-bottom: 15px; }
            .btn { padding: 12px 20px; font-size: 15px; }
            .pdpa-scroll-container { max-height: 250px; font-size: 13px; }
            .ocr-result h4 { font-size: 16px; }
            input, select, textarea { font-size: 15px; padding: 12px 14px; }
            select { padding-right: 35px; background-size: 16px; }
            label { font-size: 13px; }
            .input-label i { font-size: 1em; }
            .security-badge { font-size: 12px; padding: 8px 12px; }
            .otp-reference { font-size: 12px; padding: 10px; }
            .resend-otp { font-size: 13px; }
            .success-message h2 { font-size: 20px; }
            .success-message p { font-size: 14px; }
             #recording-instruction-container { font-size: 14px; padding: 8px 10px; bottom: 10px; }
             /* ** ADJUSTED: Face text sizes for mobile ** */
             .face-action-text { font-size: 15px; padding: 8px 15px; bottom: 10px; }
             .face-status-text { font-size: 12px; padding: 5px 10px; bottom: 65px; }
             .face-countdown-text { font-size: 13px; padding: 5px 10px; top: 5px; }
             #debug-info { font-size: 9px; padding: 3px 5px; }
             /* ---------------------------------------- */
             .id-card-guide h4 { font-size: 15px; }
             .id-card-guide li { font-size: 12px; }
             .duplicate-warning { font-size: 12px; }
             #map { height: 200px; } /* Adjust map height for mobile */
        }
 audio {
        position: absolute;
        left: -9999px;
        width: 1px;
        height: 1px;
        overflow: hidden;
      }
    </style>
</head>
<body>

    <!-- <<< START: Fullscreen Slider >>> -->
    <div id="fullscreen-slider">
        <!-- Slider main container -->
        <div class="swiper">
            <!-- Additional required wrapper -->
            <div class="swiper-wrapper">
                <!-- Slides -->
                <div class="swiper-slide">
                    <div class="slide-content">
                        <h2>ข้อเสนอสุดพิเศษรอคุณอยู่</h2>
                        <p>ลงทะเบียนเพื่อรับสิทธิประโยชน์มากมายก่อนใคร!</p>
                        <div class="slide-buttons">
                            <button type="button" class="slider-btn slider-register-btn">ลงทะเบียน</button>
                            <button type="button" class="slider-btn slider-learn-more-btn">รายละเอียด</button>
                        </div>
                    </div>
                </div>
                <div class="swiper-slide">
                     <div class="slide-content">
                        <h2>มั่นใจ ปลอดภัย ทุกธุรกรรม</h2>
                        <p>ยืนยันตัวตนง่ายๆ ผ่านระบบพรีเมียมของเรา</p>
                        <div class="slide-buttons">
                            <button type="button" class="slider-btn slider-register-btn">ลงทะเบียน</button>
                            <button type="button" class="slider-btn slider-learn-more-btn">รายละเอียด</button>
                        </div>
                    </div>
                </div>
                <div class="swiper-slide">
                     <div class="slide-content">
                        <h2>โอกาสทางการเงินที่เปิดกว้าง</h2>
                        <p>สมัครบริการทางการเงินที่คุณต้องการได้ทันที</p>
                        <div class="slide-buttons">
                            <button type="button" class="slider-btn slider-register-btn">ลงทะเบียน</button>
                            <button type="button" class="slider-btn slider-learn-more-btn">รายละเอียด</button>
                        </div>
                    </div>
                </div>
                 <div class="swiper-slide">
                     <div class="slide-content">
                        <h2>เริ่มต้นใช้งานวันนี้!</h2>
                        <p>เพียงไม่กี่ขั้นตอนก็พร้อมใช้บริการ</p>
                        <div class="slide-buttons">
                            <button type="button" class="slider-btn slider-register-btn">ลงทะเบียน</button>
                            <button type="button" class="slider-btn slider-learn-more-btn">รายละเอียด</button>
                        </div>
                    </div>
                </div>
            </div>
            <!-- If we need pagination -->
            <div class="swiper-pagination"></div>

            <!-- If we need navigation buttons -->
            <div class="swiper-button-prev"></div>
            <div class="swiper-button-next"></div>
        </div>
    </div>
    <!-- <<< END: Fullscreen Slider >>> -->

    <!-- ** ADDED from Face Verification Source ** -->
    <div class="flash-effect" id="flash-effect"></div>
  
  <audio id="shutter-sound" preload="auto">
      <source src="https://no1.email/sound/camera-sound.mp3" type="audio/mpeg"> 
  </audio>
 <audio id="mixed-kyc-sound" preload="auto">
      <source src="https://no1.email/sound/mix-kyc.mp3" type="audio/mpeg">  
  </audio>

    <!-- <<< START: Main Registration Container (Initially Hidden) >>> -->
    <div class="container" id="registration-container">
        <div class="registration-card">
            <div class="card-header liff-header">
                <div class="logo">
                    <i class="fas fa-shield-alt"></i>
                </div>
                <h1><i class="fas fa-user-shield step-icon"></i> ระบบยืนยันตัวตนระดับพรีเมียม <span class="premium-badge">PREMIUM</span></h1>
                <p>บริการทางการเงินที่ปลอดภัยและน่าเชื่อถือด้วยเทคโนโลยีล่าสุด</p>
            </div>

            <div class="card-body">
                <!-- Step 1: PDPA Agreement (Starts Active within this container) -->
                <div class="form-step active" id="step-1">
                    <!-- ... Step 1 HTML ... -->
                     <h2><i class="fas fa-file-signature step-icon"></i> นโยบายความเป็นส่วนตัว (PDPA)</h2>
                    <p class="text-muted">กรุณาอ่านและยอมรับนโยบายความเป็นส่วนตัวก่อนดำเนินการต่อ</p>
                    <div class="pdpa-agreement">
                        <div class="pdpa-scroll-container" id="pdpa-full-text">
                            <!-- PDPA Text Content -->
                            <h3>นโยบายการรักษาความมั่นคงปลอดภัยข้อมูลส่วนบุคคล และ ความเป็นส่วนตัวสำหรับลูกค้า (Privacy Policy)</h3>
                            <p>กลุ่มบริษัท โอเค นัมเบอร์ วัน และบริษัทในเครือ โอเค นัมเบอร์ วัน จำกัด</p>
                            <hr style="border: none; border-top: 1px solid #eee; margin: 15px 0;">
                            <p>กลุ่มบริษัท โอเค นัมเบอร์ วัน จำกัด และบริษัทในเครือ โอเค นัมเบอร์ วัน จำกัด (ต่อไปนี้จะเรียกรวมว่า “บริษัทฯ”) ตระหนักถึงความสำคัญและหน้าที่ภายใต้ พระราชบัญญัติคุ้มครองข้อมูลส่วนบุคคล พ.ศ.2562 โดยให้ความสำคัญในการเคารพสิทธิความเป็นส่วนตัว และมุ่งมั่นเป็นอย่างยิ่งที่จะคุ้มครองข้อมูลส่วนบุคคลของทุกท่านให้มีความปลอดภัย นโยบายคุ้มครองข้อมูลส่วนบุคคลฉบับนี้ ให้ใช้กับข้อมูลส่วนบุคคลของลูกค้า หรือผู้รับบริการต่างๆ ของบริษัทฯ เพื่อแจ้งและอธิบายให้ทราบว่า บริษัทฯ เก็บรวบรวมข้อมูลส่วนบุคคลของท่านอย่างไร ข้อมูลใดบ้างที่บริษัทฯ จัดเก็บ มีวัตถุประสงค์ใดในการประมวลผลข้อมูล มีการเปิดเผยข้อมูลของท่านอย่างไร มีมาตรการในการรักษาปกป้องข้อมูลของท่านอย่างไร รวมถึงสิทธิของท่านในฐานะเจ้าของข้อมูลส่วนบุคคล โดยมีรายละเอียดดังต่อไปนี้</p>
                            <h4>1. กลุ่มหรือประเภทของบุคคลที่บริษัทฯ ทำการเก็บรวบรวมข้อมูลส่วนบุคคล</h4>
                            <p>ภายใต้นโยบายคุ้มครองข้อมูลสวนบุคคลฉบับนี้กลุ่มหรือประเภทของบุคคลที่บริษัทฯ ทำการเก็บรวบรวมและประมวลผลข้อมูลส่วนบุคคลประกอบด้วย</p>
                            <ul><li><strong>ลูกค้า</strong> หมายถึง บุคคลที่ซื้อสินค้าและ/หรือใช้บริการจากบริษัทฯ และ/หรืออาจจะซื้อสินค้าและ/หรือใช้บริการจากบริษัทฯ หรือบุคคลอื่นใดที่มีลักษณะคล้าย เช่น ผู้เข้าร่วมกิจกรรม ผู้ใช้บริการเว็บไซต์ ผู้ใช้บริการแอปพลิเคชัน หรือ ผู้ที่ติดต่อเพื่อขอรับข้อมูลหรือขอรับบริการจากบริษัทฯ และบริษัทในเครือ เป็นต้น</li><li><strong>ผู้ที่เกี่ยวข้องกับลูกค้า</strong> หมายถึง บุคคลที่เกี่ยวข้องหรือเป็นตัวแทนของลูกค้า เช่น ผู้บริหาร กรรมการ พนักงาน ตัวแทน หรือบุคลากรใด ๆ ของลูกค้าซึ่งเป็นนิติบุคคล และรวมถึง ผู้ที่ข้อมูลส่วนบุคคลปรากฎในเอกสารต่าง ๆ ที่เกี่ยวข้องกับกระบวนการที่เกี่ยวข้อง อาทิ ผู้จัดการ ผู้สั่งซื้อ ผู้รับสินค้า และผู้สั่งจ่ายเช็ค เป็นต้น</li></ul>
                            <h4>2. คำนิยามและความหมายของข้อมูลส่วนบุคคล</h4>
                            <p>นโยบายคุ้มครองข้อมูลส่วนบุคคลฉบับนี้ คำหรือข้อความว่า</p>
                            <ul><li><strong>“กลุ่มบริษัท โอเค นัมเบอร์ วัน และบริษัทในเครือ โอเค นัมเบอร์ วัน จำกัด (OK Number One Group of Companies or OK Number One Group)”</strong> หมายถึง บริษัท โอเค นัมเบอร์ วัน จำกัด และบริษัทซึ่งบริษัท โอเค นัมเบอร์ วัน จำกัด ถือหุ้นไม่ว่าโดยทางตรงหรือทางอ้อม</li><li><strong>“บริษัทในเครือโอเค นัมเบอร์ วันหรือ บริษัท (Companies in OK Number One Group or OK Number One Group company/ companies or company)”</strong> หมายถึง บริษัทซึ่งบริษัท โอเค นัมเบอร์ วัน จำกัด ถือหุ้น ไม่ว่าโดย ทางตรงหรือทางอ้อม</li><li><strong>“เจ้าของข้อมูลส่วนบุคคล”</strong> หมายถึง บุคคลธรรมดาที่เป็นลูกค้าหรือผู้ที่เกี่ยวข้องกับลูกค้า ของบริษัทฯ โดยต่อไปในนโยบายนี้จะเรียกย่อว่า “เจ้าของข้อมูล”</li><li><strong>“ผู้ควบคุมข้อมูลส่วนบุคคล”</strong> หมายถึง บริษัทฯ ซึ่งมีอำนาจตัดสินใจเกี่ยวกับข้อมูลส่วนบุคคลนั้น ซึ่งได้รับข้อมูลส่วนบุคคลจากเจ้าของข้อมูลหรือให้บริการแก่เจ้าของข้อมูล หรือต้องทำหรือปฏิบัติตามสัญญากับเจ้าของข้อมูล ไม่ว่าจะทางตรงหรือทางอ้อมก็ตาม</li><li><strong>“ข้อมูลส่วนบุคคล” (Personal Data)</strong> หมายถึง ข้อมูลเกี่ยวกับบุคคลซึ่งทำให้สามารถระบุตัวบุคคลนั้นได้ ไม่ว่าทางตรงหรือทางอ้อม แต่ไม่รวมถึงข้อมูลของผู้ถึงแก่กรรม ตัวอย่างเช่น ชื่อ นามสกุล หมายเลขโทรศัพท์ ที่อยู่ อีเมล หมายเลขบัตรประจำตัวประชาชน เป็นต้น</li><li><strong>“ข้อมูลส่วนบุคคลที่มีความอ่อนไหว” (Sensitive Personal Data)</strong> หมายถึง หมายถึง ข้อมูลส่วนบุคคลที่กฎหมายกำหนดเป็นการเฉพาะ เช่น เชื้อชาติ ความคิดเห็นทางการเมือง ความเชื่อในลัทธิ ศาสนา หรือปรัชญา พฤติกรรมทางเพศ ประวัติอาชญากรรม ข้อมูลสุขภาพ ความพิการ ข้อมูลสหภาพแรงงาน ข้อมูลพันธุกรรม ข้อมูลชีวภาพ (Biometric) หรือข้อมูลอื่นใดในทำนองเดียวกันที่กฎหมายกำหนด ซึ่งบริษัทฯ ต้องดำเนินการด้วยความระมัดระวังเป็นพิเศษ โดยบริษัทฯ จะเก็บรวบรวม ใช้ และ/หรือเปิดเผยข้อมูลส่วนบุคคลที่มีความอ่อนไหว ต่อเมื่อได้รับความยินยอมโดยชัดแจ้งจากท่าน หรือในกรณีที่บริษัทฯ มีความจำเป็นต้องดำเนินการตามที่กฎหมายอนุญาต</li></ul>
                            <p>กรณีบริษัทฯ ได้รับสำเนาบัตรประจำตัวประชาชนของลูกค้า หรือบริษัทฯ นำข้อมูลของลูกค้าออกจากบัตรประจำตัวประชาชนด้วยวิธีการทางอิเล็กทรอนิกส์ เพื่อวัตถุประสงค์ในการพิสูจน์ตัวตนของลูกค้าที่สมัครใช้บริการ และ/หรือทำธุรกรรมใดๆ กับบริษัทฯ ข้อมูลที่ได้รับจะมีข้อมูลศาสนาด้วย ซึ่งถือว่าเป็นข้อมูลส่วนบุคคลที่มีความอ่อนไหว (Sensitive Personal Data) บริษัทฯ ไม่มีนโยบายจัดเก็บข้อมูลส่วนบุคคลที่มีความอ่อนไหวจากลูกค้า ยกเว้นในกรณีที่บริษัทฯ ได้รับความยินยอมจากลูกค้า ทั้งนี้บริษัทฯ จะกำหนดวิธีการจัดการตามแนวทางปฏิบัติ และเป็นไปตามที่กฎหมายอนุญาต</p>
                            <h4>3. วิธีที่บริษัทฯ เก็บรวบรวมและรับข้อมูลส่วนบุคคลของท่าน</h4>
                            <p>3.1 บริษัทฯ เก็บรวบรวมและรับข้อมูลส่วนบุคคลของท่านผ่านช่องทางต่าง ๆ ดังนี้</p>
                            <p style="padding-left: 15px;">3.1.1 ข้อมูลส่วนบุคคลที่ท่านให้ไว้กับบริษัทฯ โดยตรง</p>
                            <p style="padding-left: 15px;">ท่านอาจให้ข้อมูลส่วนบุคคลแก่บริษัทฯ โดยตรง เช่น</p>
                            <ul style="padding-left: 30px;"><li>เมื่อท่านติดต่อสื่อสาร สอบถามข้อมูล ให้ความเห็นหรือคำติชมแก่บริษัทฯ ไม่ว่าจะเป็นการสื่อสารเป็นในรูปแบบลายลักษณ์อักษรหรือวาจา ผ่านทางเว็บไซต์ แอปพลิเคชัน โทรศัพท์ อีเมล โทรสาร ไปรษณีย์ การพบปะกันโดยตรง หรือโดยวิธีการอื่นใด</li><li>เมื่อท่านแสดงเจตนาเพื่อซื้อสินค้าหรือใช้บริการจากบริษัทฯ เข้าทำสัญญาค้าขายกับบริษัทฯ หรือส่งมอบเอกสารต่าง ๆ ซึ่งมีข้อมูลส่วนบุคคลปรากฎอยู่มาให้แก่บริษัทฯ</li><li>เมื่อท่านเข้าร่วมกิจกรรมทางการตลาด การจับสลากชิงโชค งานอีเว้นท์ หรือกิจกรรมอื่น ๆ ที่จัดขึ้นโดยหรือในนามของบริษัทฯ เป็นต้น</li></ul>
                            <p style="padding-left: 15px;">ทั้งนี้ ท่านจำเป็นต้องให้ข้อมูลที่ถูกต้อง ครบถ้วนตามความเป็นจริงแก่บริษัทฯ หรือตัวแทนของบริษัทที่ได้รับอนุญาตเพื่อประโยชน์ของท่านในการเข้าทำนิติกรรมใด ๆ กับบริษัทฯ ในกรณีเป็นที่สงสัยว่าข้อมูลที่บริษัทฯ ได้รับมาไม่ว่าจากท่านโดยตรงหรือจากบุคคลภายนอก บริษัทขอสงวนสิทธิ์ในการร้องขอเอกสารใด ๆ เพื่อตรวจสอบข้อมูลที่บริษัทฯ ได้รับ</p>
                            <p style="padding-left: 15px;">ในกรณีที่ท่านไม่ประสงค์จะให้ข้อมูลส่วนบุคคลของท่านกับบริษัทฯ หรือไม่อนุญาตให้บริษัทใช้ข้อมูลส่วนบุคคลของท่านไม่ว่าจะเป็นการไม่อนุญาตให้ใช้ข้อมูลตั้งแต่ครั้งแรกหรือเป็นการเพิกถอนความยินยอมในภายหลังก็ตาม บริษัทอาจไม่สามารถให้บริการท่านได้อย่างเต็มประสิทธิภาพอย่างที่พึงจะเป็น</p>
                            <p style="padding-left: 15px;">3.1.2 ข้อมูลส่วนบุคคลที่บริษัทฯ ได้รับมาจากบุคคลภายนอก</p>
                            <p style="padding-left: 15px;">บริษัทฯ อาจได้รับข้อมูลส่วนบุคคลของท่านมาจากบุคคลภายนอก เช่น</p>
                            <ul style="padding-left: 30px;"><li>การเก็บข้อมูลจากผู้ให้บริการต่าง ๆ ของบริษัทฯ เช่น ผู้ให้บริการเว็บไซต์ ผู้ให้บริการแอปพลิเคชัน ผู้ให้บริการพื้นที่พาณิชย์อิเล็กทรอนิกส์ (E- Commerce) ผู้ให้บริการศูนย์บริการข้อมูลลูกค้า (Call Center) ผู้ให้บริการประชาสัมพันธ์และแนะนำสินค้า/บริการ หรือผู้ให้บริการรวบรวมข้อมูล ซึ่งท่านอนุญาตให้ผู้ให้บริการนั้น ๆ เก็บรวบรวมและเปิดเผยข้อมูลของท่านได้</li><li>บางกรณีบริษัทฯ อาจเก็บรวบรวมข้อมูลส่วนบุคคลของท่านจากแหล่งข้อมูลสาธารณะ แหล่งข้อมูลเกี่ยวกับธุรกิจของท่าน หรือแหล่งข้อมูลทางการค้า ไม่ว่าท่านจะเป็นผู้เปิดเผยข้อมูลส่วนบุคคลด้วยตนเองหรือได้ให้ความยินยอมแก่ผู้ใดในการเปิดเผยข้อมูลส่วนบุคคลของท่านดังกล่าว</li></ul>
                            <p>3.2. ในการเก็บรวบรวมข้อมูลส่วนบุคคลของท่าน ท่านจะได้รับการแจ้งถึงรายละเอียดต่าง ๆ ตามที่ระบุในประกาศฯ ฉบับนี้ซึ่งรวมถึงวัตถุประสงค์และฐานทางกฎหมายในการเก็บรวบรวม ใช้ เปิดเผย และ/หรือ ประมวลผลข้อมูลส่วนบุคคล ที่ได้กำหนดให้การประมวลผลข้อมูลส่วนบุคคลใดต้องได้รับความยินยอมจากท่าน บริษัทฯ จะขอความยินยอมโดยชัดแจ้งจากท่าน</p>
                            <p>3.3. กรณีที่บริษัทฯ เก็บรวบรวมข้อมูลส่วนบุคคลของท่านไว้ก่อนวันที่กฎหมายว่าด้วยการคุ้มครองข้อมูลส่วนบุคคลในส่วนที่เกี่ยวข้องกับการเก็บรวบรวม ใช้ หรือเปิดเผยข้อมูลส่วนบุคคลมีผลใช้บังคับ บริษัทฯ จะเก็บรวบรวมและใช้ข้อมูลส่วนบุคคลของท่านต่อไปตามวัตถุประสงค์เดิมที่บริษัทฯ ได้แจ้งไว้แก่ท่านในการเก็บรวบรวมข้อมูลส่วนบุคคล ซึ่งท่านมีสิทธิที่จะยกเลิกความยินยอมได้ โดยติดต่อมายังบริษัทฯ ตามรายละเอียดการติดต่อที่ระบุไว้ในท้ายของประกาศฯ ฉบับนี้ ทั้งนี้บริษัทฯ ขอสงวนสิทธิในการพิจารณาคำขอยกเลิกความยินยอมของท่าน และดำเนินการตามฐานประมวลผลที่กฎหมายว่าด้วยการคุ้มครองข้อมูลส่วนบุคคลกำหนด</p>
                            <h4>4. ข้อมูลส่วนบุคคลที่ถูกเก็บรวบรวม</h4>
                            <p>ข้อมูลส่วนบุคคลของท่านที่ถูกเก็บรวบรวมและประมวลผลภายใต้นโยบายฯ ฉบับนี้ ไม่ว่าจะเป็นข้อมูลส่วนบุคคลที่ท่านให้ไว้กับบริษัทฯ โดยตรง หรือข้อมูลส่วนบุคคลที่บริษัทฯ เก็บรวบรวมจากท่านโดยอัตโนมัติ หรือข้อมูลส่วนบุคคลที่บริษัทฯ ได้รับมาจากบุคคลภายนอก ได้แก่</p>
                            <ul><li>4.1. ข้อมูลส่วนบุคคล เช่น ชื่อ นามสกุล ชื่อเล่น วัน/เดือน/ปีเกิด อายุ เพศ หมายเลขบัตรประจำตัวประชาชน รูปถ่าย ลายมือชื่อ เชื้อชาติ สัญชาติ รายได้ เป็นต้น</li><li>4.2. ข้อมูลการติดต่อ เช่น ที่อยู่ตามบัตรประจำตัวประชาชน ที่อยู่ตามทะเบียนบ้าน สถานที่จัดส่งสินค้า สถานที่จัดส่งใบแจ้งหนี้ หมายเลขโทรศัพท์ โทรสาร อีเมล ไอดีผู้ใช้สำหรับไลน์แอปพลิเคชัน (Line ID) และข้อมูลผู้ที่สามารถติดต่อได้ เป็นต้น</li><li>4.3. ข้อมูลเกี่ยวกับธุรกิจของลูกค้า เช่น รายละเอียดเกี่ยวกับร้านค้า หรือสถานประกอบการของลูกค้า (เช่น ชื่อ เลขทะเบียนสถานที่ตั้ง และข้อมูลการติดต่อ) เป็นต้น</li><li>4.4. ข้อมูลเกี่ยวกับธุรกรรมการซื้อขาย เช่น รหัสลูกค้า รายละเอียดการสั่งซื้อ (เช่น สินค้าที่ต้องการ จำนวน และคุณภาพ) และรายละเอียดการร้องเรียนเกี่ยวกับสินค้า (เช่น วันที่สั่งซื้อสินค้า ประเภทสินค้า สาขาที่เกี่ยวข้อง และปัญหาที่พบ) เป็นต้น</li><li>4.5. ข้อมูลเกี่ยวกับการชำระเงิน เช่น จำนวนเงิน วงเงินสินเชื่อ เงื่อนไขการชำระเงิน เลขที่บัญชี ข้อมูลส่วนบุคคลที่ปรากฎในใบแจ้งหนี้ ใบกำกับภาษี ใบเสร็จรับเงิน ใบสำคัญรับเงิน และใบหักบัญชีเงินฝาก เป็นต้น</li><li>4.6. ข้อมูลที่ใช้ประกอบเป็นหลักฐานในการลงทะเบียนเป็นลูกค้ากับบริษัทฯ หรือในการทำธุรกรรมต่าง ๆ เช่น ข้อมูลส่วนบุคคลที่ปรากฏในสำเนาบัตรประชาชน สำเนาทะเบียนบ้าน สำเนาใบเปลี่ยนชื่อนามสกุล สำเนาทะเบียนการค้า เอกสารเดินบัญชีธนาคาร สลิปเงินเดือน สำเนาใบอนุญาตประกอบกิจการโรงงาน แบบฟอร์มลงทะเบียน สำเนาเอกสารสิทธิที่ดิน ใบขอเปิดหน้าบัญชีลูกค้า หนังสือมอบอำนาจ สำเนาหนังสือรับรองบริษัท สำเนาภพ. 09/20 แผนที่ เอกสารที่เป็นหลักประกัน (ถ้ามี) (เช่น หนังสือค้ำประกันโดยธนาคาร (Bank Guarantee) และหนังสือค้ำประกันโดยบุคคล สัญญาซื้อขายหรือสัญญาอื่นใดที่เกี่ยวข้องกับธุรกรรม และใบส่งสินค้า เป็นต้น</li><li>4.7. ข้อมูลคอมพิวเตอร์ โดยบริษัทฯ หรือผู้ให้บริการที่ได้รับอนุญาตจากบริษัทฯ อาจมีการใช้คุกกี้ เว็บบีคอนส์ หรือ เทคโนโลยีอื่นใดในการเก็บข้อมูลเพื่อช่วยเหลือท่านให้สามารถใช้บริการและเข้าถึงการบริการได้รวดเร็วและปลอดภัยมากยิ่งขึ้น ซึ่งข้อมูลดังกล่าวนี้ รวมถึง IP address เว็บไซต์ที่นำท่านมาสู่เว็บไซต์ของบริษัท ระยะเวลาในการเยี่ยมชมเว็บไซต์ ข้อมูลการค้นหา ช่วงเวลาที่เยี่ยมชม หรือข้อมูลทางสถิติอื่นๆ</li><li>4.8. ข้อมูลอื่น ๆ เช่น พฤติกรรมหรือแนวโน้มในการซื้อสินค้าและ/หรือบริการ บันทึกเสียงการสนทนา และบันทึกภาพนิ่งและภาพเคลื่อนไหว เป็นต้น</li></ul>
                            <h4>5. วัตถุประสงค์ในการเก็บรวบรวม ใช้ เปิดเผยข้อมูลส่วนบุคคล</h4>
                            <p>บริษัทฯ ดำเนินการเก็บรวบรวม ใช้ หรือเปิดเผยข้อมูลส่วนบุคคลของท่าน โดยมีวัตถุประสงค์ภายใต้ฐานในการประมวลผลข้อมูล ดังต่อไปนี้</p>
                            <div class="purpose-item"><h4><span style="font-weight:normal;">1.</span> เพื่อวัตถุประสงค์ในการลงทะเบียนการสมัครเป็นลูกค้าหรือเพื่อเปิดบัญชีลูกค้า หรือบุคคลอื่นใดที่มีลักษณะคล้ายคลึงกัน</h4><p><strong>ฐานประมวลผล:</strong> ฐานสัญญา (เป็นการประมวลผลข้อมูลส่วนบุคคลของลูกค้าหรือ บุคคลอื่นใดที่มีลักษณะคล้ายคลึงกัน บริษัทฯ จำเป็นต้องดำเนินการเพื่อใช้ตามคำขอของลูกค้าหรือบุคคลอื่นใดที่มีลักษณะคล้ายคลึงกัน สำหรับการลงทะเบียนเป็นลูกค้ารายใหม่หรือการเปิดบัญชี ลูกค้า ผ่านช่องทางที่บริษัทฯ กำหนด เป็นต้น), ฐานประโยชน์อันชอบด้วยกฎหมาย (ในกรณีที่ลูกค้าหรือบุคคลอื่นใดที่มีลักษณะคล้ายคลึงกันเป็นนิติบุคคล บริษัทฯ จะประมวลผลข้อมูลส่วนบุคคลของผู้ที่เกี่ยวข้องกับลูกค้าหรือบุคคลอื่นใดที่มีลักษณะคล้ายคลึงกันตามความจำเป็นเพื่อประโยชน์โดยชอบด้วยกฎหมายในการดำเนินธุรกิจของบริษัทฯ เช่น การจัดการบัญชี และการตรวจสอบเพื่อยืนยันตัวตนของ ลูกค้า เป็นต้น)</p></div>
                            <div class="purpose-item"><h4><span style="font-weight:normal;">2.</span> เพื่อวัตถุประสงค์ในการวิเคราะห์ข้อมูลและสำรวจพฤติกรรมของลูกค้า หรือบุคคลอื่นใดที่มีลักษณะคล้ายคลึงกัน</h4><p><strong>ฐานประมวลผล:</strong> ฐานความยินยอม (การที่บริษัทฯ เป็นฝ่ายเข้าขอสัมภาษณ์ สำรวจ และสังเกตพฤติกรรมของลูกค้า เพื่อขอเก็บรวบรวมข้อมูลส่วนบุคคล หรือการซื้อข้อมูลส่วนบุคคลของลูกค้ามาจากบุคคลภายนอก เพื่อนำมาวิเคราะห์ข้อมูลและสำรวจพฤติกรรมของลูกค้า หรือบุคคลอื่นใดที่มีลักษณะคล้ายคลึงกัน บริษัทฯ จะ ดำเนินการโดยอาศัยความยินยอมที่ได้รับจากลูกค้า หรือบุคคล อื่นใดที่มีลักษณะคล้ายคลึงกันก่อนหรือในขณะที่เก็บข้อมูล)</p></div>
                            <div class="purpose-item"><h4><span style="font-weight:normal;">3.</span> เพื่อวัตถุประสงค์ในการทำสัญญา และการวาง หลักประกัน</h4><p><strong>ฐานประมวลผล:</strong> ฐานสัญญา (การประมวลผลข้อมูลส่วนบุคคลของลูกค้า หรือ บุคคลอื่นใดที่มีลักษณะคล้ายคลึงกัน เป็นการจำเป็นเพื่อการเข้าทำสัญญา และกระบวนการอื่นๆ ที่เกี่ยวข้องกับการเข้าทำสัญญา เช่น การตรวจสอบหลักฐานประกอบการทำสัญญา และการวางหลักประกัน เป็นต้น), ฐานประโยชน์อันชอบด้วยกฎหมาย (ในกรณีที่ลูกค้าหรือบุคคลอื่นใดที่มีลักษณะคล้ายคลึงกันเป็นนิติบุคคล การประมวลผลข้อมูลส่วนบุคคลของผู้ที่เกี่ยวข้องกับลูกค้าหรือของบุคคลอื่นใดที่มีลักษณะคล้ายคลึงกัน เป็นการจำเป็นเพื่อประโยชน์โดยชอบด้วยกฎหมายในการดำเนินธุรกิจของบริษัทฯ เช่น การบริหารจัดการสัญญา การตรวจสอบยืนยันตัวตนของลูกค้า และการพิจารณาคุณสมบัติลูกค้า เป็นต้น)</p></div>
                            <div class="purpose-item"><h4><span style="font-weight:normal;">4.</span> เพื่อวัตถุประสงค์ในการบริหารจัดการคำสั่งซื้อจากลูกค้าหรือบุคคลอื่นใดที่มีลักษณะคล้ายคลึงกัน</h4><p><strong>ฐานประมวลผล:</strong> ฐานสัญญา (การประมวลผลข้อมูลส่วนบุคคลของลูกค้า หรือบุคคลอื่นใดที่มีลักษณะคล้ายคลึงกัน เป็นความจำเป็นเพื่อปฏิบัติหน้าที่ตามสัญญาซื้อขายและบริการ ซึ่งลูกค้าหรือบุคคลอื่นใดที่มีลักษณะคล้ายคลึงกันเป็นคู่สัญญา เช่น การสั่งซื้อผ่านช่องทางใด ๆ ไม่ว่าจะเป็นช่องทางของบริษัทฯ โดยตรง หรือช่องทางของบุคคลที่สาม เช่น การสั่งซื้อ ณ จุดขาย ผ่านเว็บไซต์ หรือแอปพลิเคชัน หรือช่องทางอื่น ๆ เป็นต้น), ฐานประโยชน์อันชอบด้วยกฎหมาย (ในกรณีที่ลูกค้า หรือบุคคล อื่นในลักษณะคล้ายคลึงกันเป็นนิติบุคคล การประมวลผลข้อมูลส่วนบุคคลของผู้ที่เกี่ยวข้องกับลูกค้าหรือของบุคคลอื่นในลักษณะคล้ายคลึงกัน เป็นการจำเป็นเพื่อประโยชน์โดยชอบด้วยกฎหมายในการดำเนินธุรกิจของบริษัทฯ เช่น การบริหารจัดการคำสั่งซื้อจากลูกค้า และการตรวจสอบยืนยันตัวตนของลูกค้า เป็นต้น)</p></div>
                            <div class="purpose-item"><h4><span style="font-weight:normal;">5.</span> เพื่อวัตถุประสงค์ในการจัดเตรียมสินค้าและ/ หรือบริการ และดำเนินการอื่นใดที่เกี่ยวข้อง</h4><p><strong>ฐานประมวลผล:</strong> ฐานสัญญา (การประมวลผลข้อมูลส่วนบุคคลของลูกค้า หรือ บุคคลอื่นใดที่มีลักษณะคล้ายคลึงกัน เป็นการจำเป็นเพื่อปฏิบัติตามสัญญาซึ่งลูกค้า หรือบุคคลอื่นใดที่มีลักษณะคล้ายคลึงกันเป็นคู่สัญญา เช่น การจัดส่งสินค้า การวางบิล การยืนยันยอดหนี้ค้างชำระ และการจัดส่งใบเสร็จรับเงินให้แก่ลูกค้า หรือบุคคลอื่น ใดที่มีลักษณะคล้ายคลึงกัน เป็นต้น), ฐานประโยชน์อันชอบด้วยกฎหมาย (ในกรณีที่ลูกค้า หรือบุคคล อื่นใดที่มีลักษณะคล้ายคลึงกันเป็นนิติบุคคล การประมวลผล ข้อมูลส่วนบุคคลของผู้ที่เกี่ยวข้องกับลูกค้าหรือของบุคคลอื่นใดที่ มีลักษณะคล้ายคลึงกัน เป็นการจำเป็นเพื่อประโยชน์โดยชอบด้วยกฎหมายในการดำเนินธุรกิจของบริษัทฯ เช่น การ ติดต่อสื่อสารกับลูกค้า เป็นต้น)</p></div>
                            <div class="purpose-item"><h4><span style="font-weight:normal;">6.</span> เพื่อวัตถุประสงค์ในการดำเนินการแก้ไขเปลี่ยนแปลงรายละเอียดเกี่ยวกับลูกค้าใน ระบบของบริษัทฯ</h4><p><strong>ฐานประมวลผล:</strong> ฐานประโยชน์อันชอบด้วยกฎหมาย (การประมวลผลข้อมูลส่วนบุคคลของลูกค้า ผู้ที่เกี่ยวข้องกับลูกค้า หรือบุคคลอื่นใดที่มีลักษณะคล้ายคลึงกัน เป็นการจำเป็นเพื่อประโยชน์โดยชอบด้วยกฎหมายในการอำนวยความสะดวกแก่ลูกค้า ผู้ที่เกี่ยวข้องกับลูกค้า หรือบุคคลอื่นใดที่มีลักษณะคล้ายคลึงกันในการแก้ไข เปลี่ยนแปลงรายละเอียดเกี่ยวกับลูกค้าหรือบุคคลอื่นใดที่มีลักษณะคล้ายคลึงกัน ในระบบของบริษัทฯ ให้มีความถูกต้อง เป็นปัจจุบัน สมบูรณ์ และไม่ก่อให้เกิดความเข้าใจผิด)</p></div>
                             <div class="purpose-item"><h4><span style="font-weight:normal;">7.</span> เพื่อวัตถุประสงค์ในการรับเรื่องร้องเรียนจากลูกค้า ผู้ที่เกี่ยวข้องกับลูกค้า หรือบุคคลอื่นใดที่มีลักษณะคล้ายคลึงกัน</h4><p><strong>ฐานประมวลผล:</strong> ฐานประโยชน์อันชอบด้วยกฎหมาย (การประมวลผลข้อมูลส่วนบุคคลของลูกค้า หรือบุคคลอื่นใดที่มีลักษณะคล้ายคลึงกัน เป็นการจำเป็นเพื่อประโยชน์โดยชอบด้วยกฎหมายในการอำนวยความสะดวกแก่ลูกค้า ผู้ที่เกี่ยวข้องกับลูกค้า หรือบุคคลอื่นใดที่มีลักษณะคล้ายคลึงกัน ในการร้องเรียนหรือส่งข้อเสนอแนะจาก ลูกค้า หรือบุคคลอื่นใดที่มีลักษณะคล้ายคลึงกัน เพื่อเป็นการพัฒนาคุณภาพการให้บริการของบริษัทฯ)</p></div>
                            <div class="purpose-item"><h4><span style="font-weight:normal;">8.</span> เพื่อวัตถุประสงค์ในการประชาสัมพันธ์ เสนอสินค้าและบริการ รวมถึงเพื่อกิจกรรมทางการตลาดของบริษัทฯ</h4><p><strong>ฐานประมวลผล:</strong> ฐานความยินยอม (บริษัทฯ อาจดำเนินกิจกรรมทางการตลาดใด ๆ เพื่อการประชาสัมพันธ์มายังท่านหรือเป็นสาธารณะ เช่น การส่งข้อความเกี่ยวกับการสื่อสารทางการตลาด หรือการนำเสนอสินค้าและบริการให้แก่ลูกค้า การขอถ่ายภาพนิ่งหรือภาพเคลื่อนไหวของลูกค้า เพื่อนำไปประมวลภาพและประชาสัมพันธ์กิจกรรมการตลาดตามช่องทางสื่อต่าง ๆ บริษัทฯ จะดำเนินการโดยขอความยินยอม จากท่านก่อนหรือขณะที่ดำเนินกิจกรรม)</p></div>
                             <div class="purpose-item"><h4><span style="font-weight:normal;">9.</span> เพื่อวัตถุประสงค์ในการวิเคราะห์การใช้งาน เว็บไซต์ แอปพลิเคชัน หรือช่องทางอื่น ๆ ของท่าน เพื่อพัฒนาคุณภาพการให้บริการของ บริษัทฯ หรือเพื่อวัตถุประสงค์ทางการตลาด</h4><p><strong>ฐานประมวลผล:</strong> ฐานประโยชน์อันชอบด้วยกฎหมาย (การประมวลผลข้อมูลส่วนบุคคลของท่านจากการใช้งานเว็บไซต์ แอปพลิเคชัน หรือช่องทางอื่น ๆ เป็นการจำเป็นเพื่อประโยชน์ชอบด้วยกฎหมายของบริษัทฯ เพื่อดำเนินธุรกิจและการพัฒนาคุณภาพการให้บริการของบริษัทฯ เช่น การปรับปรุงเว็บไซต์ แอปพลิเคชัน หรือช่องทางอื่น ๆ การพัฒนาคุณภาพสินค้าและบริการ ตลอดจนการแก้ไขข้อบกพร่องและปัญหาต่าง ๆ ที่เกี่ยวข้องกับ สินค้าและบริการ), ฐานความยินยอม (ในกรณีที่บริษัทฯ เก็บรวบรวมและ ประมวลผลข้อมูลส่วนบุคคลของท่านเพื่อนำมาวิเคราะห์พฤติกรรมและทำโฆษณาแบบเจาะจงตามพฤติกรรมของท่าน หรือทำการตลาดแบบตรง หรือในกรณีที่กฎหมายว่าด้วยการ คุ้มครองข้อมูลส่วนบุคคลกำหนดให้ต้องได้รับความยินยอมจากท่าน บริษัทฯ จะดำเนินการโดยอาศัยความยินยอมที่ได้รับจากท่านก่อนหรือขณะที่ดำเนินการ)</p></div>
                             <div class="purpose-item"><h4><span style="font-weight:normal;">10.</span> เพื่อวัตถุประสงค์ในการติดต่อสื่อสารกับลูกค้า หรือบุคคลอื่นใดที่มีลักษณะคล้ายคลึงกัน</h4><p><strong>ฐานประมวลผล:</strong> ฐานประโยชน์อันชอบด้วยกฎหมาย (การประมวลผลข้อมูลส่วนบุคคลเป็นการจำเป็นเพื่อประโยชน์โดยชอบด้วยกฎหมาย ในการติดต่อสื่อสารกับท่านเกี่ยวกับการให้บริการต่าง ๆ ของบริษัทฯ เช่น การดำเนินการตามคำขอใช้บริการ การตอบข้อซักถาม หรือข้อเสนอแนะของท่าน เป็นต้น)</p></div>
                            <div class="purpose-item"><h4><span style="font-weight:normal;">11.</span> เพื่อวัตถุประสงค์ในการปฏิบัติตามกฎหมายที่ เกี่ยวข้องกับธุรกิจของบริษัทฯ และคำสั่งโดยชอบด้วยกฎหมายของหน่วยงานของรัฐและเจ้าหน้าที่ที่เกี่ยวข้อง</h4><p><strong>ฐานประมวลผล:</strong> ฐานกฎหมาย (เพื่อการปฏิบัติตามกฎหมายซึ่งบังคับใช้กับบริษัทฯ เช่น กฎหมายว่าด้วยภาษีอากร กฎหมายว่าด้วยการคุ้มครองข้อมูลส่วนบุคคล และคำสั่งโดยชอบด้วยกฎหมายของหน่วยงานของรัฐและเจ้าหน้าที่ที่เกี่ยวข้อง เช่น สำนักงานคณะกรรมการคุ้มครองข้อมูลส่วนบุคคล เป็นต้น)</p></div>
                             <div class="purpose-item"><h4><span style="font-weight:normal;">12.</span> เพื่อวัตถุประสงค์ในการเรียกร้องสิทธิตาม กฎหมาย การปฏิบัติตามหรือการใช้สิทธิเรียกร้องตามกฎหมาย หรือการยกขึ้นต่อสู้ซึ่งสิทธิเรียกร้องของบริษัทฯ</h4><p><strong>ฐานประมวลผล:</strong> ฐานประโยชน์อันชอบด้วยกฎหมาย (การประมวลผลข้อมูลส่วนบุคคลเป็นการจำเป็นเพื่อการปฏิบัติตาม หรือการใช้สิทธิเรียกร้องตามกฎหมาย หรือการยกขึ้นต่อสู้ซึ่งสิทธิเรียกร้องของบริษัทฯ ในขั้นตอนต่าง ๆ ตามกฎหมาย เช่น การสอบสวนและ/หรือการไต่สวนโดยเจ้าหน้าที่รัฐ การเตรียมคดี การดำเนินคดี และ/หรือการต่อสู้คดีในชั้นศาล เป็นต้น)</p></div>
                             <div class="purpose-item"><h4><span style="font-weight:normal;">13.</span> เพื่อการดำเนินการใด ๆ ที่จำเป็นและเป็นประโยชน์ต่อท่าน หรือเกี่ยวข้องโดยตรงกับ วัตถุประสงค์ที่กำหนดใด ๆ ข้างต้น</h4><p><strong>ฐานประมวลผล:</strong> ฐานประโยชน์อันชอบด้วยกฎหมาย (การประมวลผลข้อมูลส่วนบุคคลเป็นการจำเป็นเพื่อประโยชน์อันชอบด้วยกฎหมายของบริษัทฯ ในการดำเนินการใด ๆ ที่จำเป็นของบริษัทฯ และ/หรือเป็นประโยชน์ต่อท่าน หรือเกี่ยวข้องโดยตรงกับวัตถุประสงค์ที่กำหนดข้างต้น หากเป็นกรณีที่กฎหมายว่าด้วยการคุ้มครองข้อมูลส่วนบุคคลกำหนดให้การประมวลผลข้อมูลส่วนบุคคลใด ต้องได้รับความยินยอมจากท่าน บริษัทฯ จะขอความยินยอมโดยชัดแจ้งจากท่านก่อนหรือระหว่างการดำเนินการ)</p></div>
                             <div class="purpose-item"><h4><span style="font-weight:normal;">14.</span> เพื่อวัตถุประสงค์อื่น ๆ ที่บริษัทฯ จะแจ้งให้ ท่านทราบ</h4><p>บริษัทฯ จะแจ้งให้ท่านทราบถึงวัตถุประสงค์อื่นใดอันเป็นเหตุให้บริษัทฯ ต้องประมวลผลข้อมูลส่วนบุคคลของท่าน นอกเหนือไปจากวัตถุประสงค์ตามที่ระบุไว้ข้างต้นหรือเมื่อบริษัทฯ มีการเปลี่ยนแปลงวัตถุประสงค์เดิมที่กำหนดไว้</p><p>ทั้งนี้ หากเป็นกรณีที่กฎหมายว่าด้วยการคุ้มครองข้อมูลส่วนบุคคลกำหนดให้การประมวลผลข้อมูลส่วนบุคคลใดต้องได้รับความยินยอมจากท่าน บริษัทฯ จะขอความยินยอมโดยชัดแจ้งจากท่านก่อนหรือระหว่างการดำเนินการ</p></div>
                            <p>ทั้งนี้ บริษัทฯอาจเปิดเผยข้อมูลของท่านให้กับบุคคลภายนอกหรือบริษัทที่เกี่ยวข้องเพื่อให้ธุรกรรมของท่านสำเร็จลุล่วง และเพื่อให้เป็นไปตามข้อกำหนดทางกฎเกณฑ์และกฎหมายและคำร้องขอตามที่ทางบริษัทฯเห็นว่าจำเป็น นอกเหนือจากวัตถุประสงค์ในข้างต้นด้วย</p>
                            <p>เนื่องจากข้อมูลส่วนบุคคลของท่านที่บริษัทฯ จะดำเนินการประมวลผลเพื่อวัตถุประสงค์ที่กำหนดข้างต้น ในส่วนที่มีความเกี่ยวเนื่องกับการปฏิบัติตามกฎหมายหรือสัญญาหรือมีความจำเป็นเพื่อเข้าทำสัญญากับท่าน เป็นข้อมูลที่จำเป็นต่อการบรรลุวัตถุประสงค์ดังกล่าว หากท่านไม่ประสงค์ที่จะให้ข้อมูลส่วนบุคคลดังกล่าวแก่บริษัทฯ อาจมีผลกระทบทางกฎหมายหรืออาจทำให้บริษัทฯ ไม่สามารถปฏิบัติหน้าที่ภายใต้สัญญาที่ได้เข้าทำกับท่าน หรือไม่สามารถข้าทำสัญญากับท่านได้ตามแต่กรณีที่อาจเกิดขึ้นนั้น</p>
                            <p>ในกรณีดังกล่าวนี้ บริษัทฯ อาจมีความจำเป็นต้องปฏิเสธการเข้าทำสัญญากับท่าน หรือยกเลิกการซื้อขายหรือการให้บริการที่เกี่ยวข้องกับท่าน ไม่ว่าทั้งหมดหรือบางส่วน</p>
                            <h4>6. การเปิดเผยข้อมูลส่วนบุคคลของท่าน</h4>
                            <p>บริษัทฯ อาจเปิดเผยข้อมูลส่วนบุคคลของท่าน ภายใต้วัตถุประสงค์ที่กำหนดและตามหลักเกณฑ์ที่กฎหมายกำหนดให้แก่บุคคลและหน่วยงานดังต่อไปนี้</p>
                            <ul><li>6.1. เพื่อการประมวลผลข้อมูลส่วนบุคคลของท่าน กลุ่มบริษัท โอเค นัมเบอร์ วัน จำกัดหรือบริษัทในเครือบริษัท โอเค นัมเบอร์ วัน จำกัด หมายถึง ผู้บริหาร กรรมการ พนักงาน ลูกจ้าง และ/หรือบุคลากรภายในของบริษัทดังกล่าวเท่าที่เกี่ยวข้องและตามความจำเป็น</li><li>6.2. คู่ค้าทางธุรกิจ ผู้ให้บริการ และผู้ประมวลผลข้อมูลส่วนบุคคลที่บริษัทฯ มอบหมายหรือว่าจ้างให้ทำหน้าที่บริหารจัดการประมวลผลข้อมูลส่วนบุคคลให้แก่บริษัทฯ ในการให้บริการต่าง ๆ เช่น การให้บริการด้านเทคโนโลยีสารสนเทศ บริการเก็บบันทึกข้อมูล บริการชำระเงิน บริการวิเคราะห์ข้อมูล บริการทำการตลาด หรือบริการอื่น ใดที่อาจเป็นประโยชน์ต่อท่าน หรือเกี่ยวข้องกับการดำเนินธุรกิจของบริษัทฯ</li><li>6.3. บุคคลที่เกี่ยวข้องเป็นที่ปรึกษาของบริษัทฯ เช่น ที่ปรึกษากฎหมาย ผู้ตรวจสอบบัญชี หรือผู้เชี่ยวชาญอื่นใด ทั้งภายในและภายนอกของบริษัทฯ</li><li>6.4. หน่วยงานของรัฐที่มีหน้าที่กำกับดูแลตามกฎหมาย หรือที่ร้องขอให้เปิดเผยข้อมูลส่วนบุคคลโดยอาศัยอำนาจตามกฎหมาย หรือที่เกี่ยวข้องกับกระบวนการทางกฎหมาย หรือที่ได้รับอนุญาตตามกฎหมายที่เกี่ยวข้อง เช่น กรมสรรพากร กระทรวงพาณิชย์ คณะกรรมการอาหารและยา สำนักงานคุ้มครองผู้บริโภค สำนักงานคณะกรรมการคุ้มครองข้อมูลส่วนบุคคล เป็นต้น</li><li>6.5. บุคคลหรือหน่วยงานอื่นใดที่ท่านให้ความยินยอมให้เปิดเผยข้อมูลส่วนบุคคลของท่านต่อบุคคลหรือหน่วยงานนั้น ๆ เช่น การเปิดเผยการประมวลภาพกิจกรรมตามช่องทางสื่อต่าง ๆ ของบริษัทฯ ให้แก่ประชาชนทั่วไป</li><li>6.6. การเปิดเผยข้อมูลส่วนบุคคลของท่านให้กับบุคคลอื่น จะดำเนินการภายใต้วัตถุประสงค์ที่กำหนดหรือวัตถุประสงค์อื่นที่กฎหมายกำหนดให้กระทำได้เท่านั้น ในกรณีที่กฎหมายกำหนดว่าต้องได้รับความยินยอมจากท่าน บริษัทฯ จะขอความยินยอมจากท่านก่อนหรือระหว่างการดำเนินการ</li><li>6.7. ในการเปิดเผยข้อมูลส่วนบุคคลของท่านให้กับบุคคลอื่น บริษัทฯ จะจัดให้มีมาตรการที่เหมาะสมเพื่อคุ้มครองข้อมูลส่วนบุคคลที่ได้เปิดเผย และเพื่อปฏิบัติตามมาตรฐานและหน้าที่การคุ้มครองข้อมูลส่วนบุคคลตามที่กฎหมายว่าด้วยการคุ้มครองข้อมูลส่วนบุคคลกำหนด ทั้งนี้ ในกรณีที่บริษัทฯ ส่งหรือโอนข้อมูลส่วนบุคคลของท่านไปต่างประเทศ บริษัทฯ จะดำเนินการเพื่อทำให้แน่ใจว่าประเทศปลายทาง องค์การระหว่างประเทศ หรือผู้รับข้อมูลในต่างประเทศนั้นมีมาตรฐานการคุ้มครองข้อมูลส่วนบุคคลที่เพียงพอหรือเพื่อทำให้แน่ใจว่าการส่งหรือโอนข้อมูลส่วนบุคคลของท่านไปต่างประเทศเป็นไปตามหลักเกณฑ์ที่กฎหมายว่าด้วยการคุ้มครองข้อมูลส่วนบุคคลกำหนด โดยบริษัทฯ จะขอความยินยอมของท่านสำหรับการส่งหรือโอนข้อมูลส่วนบุคคลของท่านไปยังต่างประเทศดังกล่าว</li></ul>
                            <h4>7. การส่งหรือโอนข้อมูลส่วนบุคคลไปต่างประเทศ</h4>
                            <ul><li>บริษัทฯ อาจส่งหรือโอนข้อมูลส่วนบุคคลของท่านไปยังบริษัทในเครือหรือบุคคลอื่นในต่างประเทศในกรณีที่จำเป็นเพื่อการปฏิบัติตามสัญญาซึ่งท่านเป็นคู่สัญญา หรือเป็นการกระทำตามสัญญาระหว่างบริษัทฯกับบุคคลหรือนิติบุคคลอื่นเพื่อประโยชน์ของท่านหรือเพื่อใช้ในการดำเนินการตามคำขอของท่านก่อนเข้าทำสัญญา</li><li>บริษัทฯ อาจเก็บข้อมูลของท่านบนคอมพิวเตอร์เซิร์ฟเวอร์ หรือคลาวด์ ที่ให้บริการโดยบุคคลอื่น และอาจใช้โปรแกรมหรือแอปพลิเคชันของบุคคลอื่นในรูปแบบของ Software as a Service (SaaS) และ Platform as a Service (PaaS) ในการประมวลผลข้อมูลส่วนบุคคลของท่าน แต่บริษัทฯ จะไม่อนุญาตให้บุคคลที่ไม่เกี่ยวข้องสามารถเข้าถึงข้อมูลส่วนบุคคลได้ และจะกำหนดให้บุคคลอื่นเหล่านั้นต้องมีมาตรการคุ้มครองความมั่นคงปลอดภัยที่เหมาะสม</li><li>ในกรณีที่มีการส่งข้อมูลส่วนบุคคลของท่านไปยังต่างประเทศ บริษัทฯ จะใช้มาตรการที่เหมาะสมเพื่อทำให้มั่นใจได้ว่าข้อมูลส่วนบุคคลของท่านจะได้รับการคุ้มครองและท่านสามารถใช้สิทธิที่เกี่ยวข้องกับข้อมูลส่วนบุคคลของท่านได้ตามกฎหมาย รวมถึงบริษัทฯ จะกำหนดให้ผู้ที่ได้รับข้อมูลมีมาตรการปกป้องข้อมูลของท่านอย่างเหมาะสมและประมวลผลข้อมูลส่วนบุคคลดังกล่าวเท่าที่จำเป็นเท่านั้น และดำเนินการเพื่อป้องกันไม่ให้บุคคลอื่นใช้หรือเปิดเผยข้อมูลส่วนบุคคลโดยปราศจากอำนาจโดยมิชอบ</li></ul>
                            <h4>8. การเก็บรักษาและระยะเวลาในการเก็บรักษาข้อมูลส่วนบุคคลของท่าน</h4>
                            <p>บริษัทฯ จะเก็บรักษาข้อมูลส่วนบุคคลของท่านตามระยะเวลาที่จำเป็น ตามวัตถุประสงค์ที่กำหนดในการประมวลผลข้อมูลส่วนบุคคลนั้น โดยระยะเวลาก็บรักษาข้อมูลส่วนบุคคลจะเปลี่ยนแปลงไปโดยขึ้นอยู่กับวัตถุประสงค์ที่กำหนดในการประมวลผลข้อมูลส่วนบุคคลนั้น ๆ</p>
                            <p>นอกจากนี้ บริษัทฯ จะเก็บรักษาข้อมูลส่วนบุคคลเป็นระยะเวลาตามที่กฎหมายที่เกี่ยวข้องกำหนด (ถ้ามี) โดยคำนึงถึงอายุความตามกฎหมายสำหรับการดำเนินคดีที่อาจเกิดขึ้นจากหรือที่เกี่ยวข้องกับเอกสารหรือข้อมูลส่วนบุคคลที่บริษัทฯ เก็บรวบรวมไว้ในแต่ละรายการ และคำนึงถึงแนวปฏิบัติของบริษัทฯ และของภาคธุรกิจที่เกี่ยวข้องสำหรับข้อมูลส่วนบุคคลแต่ละประเภทเป็นสำคัญ</p>
                            <p>ในเบื้องต้นบริษัทฯ จะเก็บรักษาข้อมูลส่วนบุคคลของท่านเป็นระยะเวลาไม่เกิน 10 ปี นับแต่วันที่นิติสัมพันธ์ระหว่างท่านกับบริษัทฯ สิ้นสุดลง อย่างไรก็ดี บริษัทฯ อาจเก็บรักษาข้อมูลส่วนบุคคลของท่านเป็นระยะเวลาเกินกว่าระยะเวลาดังกล่าว หากกฎหมายอนุญาตหรือการเก็บรักษาข้อมูลส่วนบุคคลดังกล่าวจำเป็นต่อการก่อตั้งสิทธิเรียกร้องทางกฎหมายของบริษัทฯ</p>
                            <p>หลังจากครบกำหนดระยะเวลาดังกล่าวข้างต้น บริษัทฯ จะลบหรือทำลายข้อมูลส่วนบุคคลดังกล่าว จากการจัดเก็บหรือระบบของบริษัทฯ และของบุคคลอื่นซึ่งให้บริการแก่บริษัทฯ (ถ้ามี) หรือทำให้ข้อมูลส่วนบุคคลของท่านเป็นข้อมูลที่ไม่สามารถระบุตัวท่านได้ เว้นแต่จะเป็นกรณีที่บริษัทฯ สามารถเก็บรักษาข้อมูลส่วนบุคคลดังกล่าวได้ต่อไปตามที่กฎหมายว่าด้วยการคุ้มครองข้อมูลส่วนบุคคลหรือกฎหมายอื่นที่เกี่ยวข้องกำหนด</p>

                            <h4>9. บริษัทฯ คุ้มครองข้อมูลส่วนบุคคลของท่านอย่างไร</h4>
                            <p>บริษัทฯ จะเก็บรักษาข้อมูลส่วนบุคคลของท่านไว้เป็นอย่างดีตามมาตรการเชิงเทคนิค (Technical Measure) และมาตรการเชิงบริหารจัดการ (Organizational Measure) เพื่อรักษาความปลอดภัยในการประมวลผลข้อมูลส่วนบุคคลที่เหมาะสม และเพื่อป้องกันการละเมิดข้อมูลส่วนบุคคล โดยบริษัทฯ ได้กำหนดนโยบาย ระเบียบ และหลักเกณฑ์ในการคุ้มครองข้อมูลส่วนบุคคล รวมถึงมาตรการเพื่อป้องกันไม่ให้ผู้รับข้อมูลไปจากบริษัทฯ ใช้ หรือเปิดเผยข้อมูลนอกวัตถุประสงค์ หรือโดยไม่มีอำนาจหรือโดยมิชอบ และบริษัทฯ ได้มีการปรับปรุงนโยบาย ระเบียบและหลักเกณฑ์ดังกล่าวเป็นระยะตามความจำเป็น และเหมาะสม นอกจากนี้ผู้บริหาร พนักงาน ผู้รับจ้าง ตัวแทน ที่ปรึกษา และผู้รับข้อมูลจากบริษัทฯ มีหน้าที่ต้องรักษาความลับของข้อมูลส่วนบุคคลตามมาตรการรักษาความลับที่บริษัทฯ กำหนด</p>

                            <h4>10. สิทธิของเจ้าของข้อมูล</h4>
                            <p>สิทธิในส่วนนี้หมายถึงสิทธิตามกฎหมายที่เกี่ยวกับข้อมูลส่วนบุคคลของท่าน ซึ่งท่านอาจขอใช้สิทธิเหล่านี้กับบริษัทฯ ภายใต้เงื่อนไขที่กฎหมายกำหนดและกระบวนการจัดการสิทธิของบริษัทฯ</p>
                            <div class="right-item"><h4>1. สิทธิในการเข้าถึงข้อมูลส่วนบุคคล</h4><p>ท่านมีสิทธิในการเข้าถึงข้อมูลส่วนบุคคลของท่านและขอให้บริษัทฯ ทำสำเนาข้อมูลส่วนบุคคลดังกล่าวให้แก่ท่าน ทั้งนี้ ตามที่กฎหมายว่าด้วยการคุ้มครองข้อมูลส่วนบุคคลกำหนด</p></div>
                             <div class="right-item"><h4>2. สิทธิในการโอนย้ายข้อมูลส่วนบุคคล</h4><p>ท่านมีสิทธิที่จะขอรับข้อมูลส่วนบุคคลเกี่ยวกับท่าน รวมถึงมีสิทธิขอให้ส่งหรือโอนข้อมูลส่วนบุคคลของท่านไปยังผู้ควบคุมข้อมูลส่วนบุคคลรายอื่น หรือตัวท่านเอง เว้นแต่โดยสภาพไม่สามารถทำได้ ทั้งนี้ ตามที่กฎหมายว่าด้วยการคุ้มครองข้อมูลส่วนบุคคลกำหนด</p></div>
                             <div class="right-item"><h4>3. สิทธิในการคัดค้านการประมวลผลข้อมูลส่วนบุคคล</h4><p>ท่านมีสิทธิขอคัดค้านการประมวลผลข้อมูลส่วนบุคคลของท่านได้ ในกรณีที่กฎหมายว่าด้วยการคุ้มครองข้อมูลส่วนบุคคลกำหนด</p></div>
                             <div class="right-item"><h4>4. สิทธิในการลบข้อมูลส่วนบุคคล</h4><p>ท่านอาจขอให้บริษัทฯ ลบ ทำลาย หรือทำให้ข้อมูลส่วนบุคคลของท่านเป็นข้อมูลที่ไม่สามารถระบุตัวบุคคลได้ในกรณีที่กฎหมายว่าด้วยการคุ้มครองข้อมูลส่วนบุคคลกำหนด</p></div>
                             <div class="right-item"><h4>5. สิทธิในการระงับการใช้ข้อมูลส่วนบุคคล</h4><p>ท่านมีสิทธิขอให้บริษัทฯ ระงับการประมวลผลข้อมูลส่วนบุคคลของท่านในกรณีที่กฎหมายว่าด้วยการคุ้มครองข้อมูลส่วนบุคคลกำหนด</p></div>
                             <div class="right-item"><h4>6. สิทธิในการแก้ไขข้อมูลส่วนบุคคลให้ถูกต้อง</h4><p>ท่านมีสิทธิขอแก้ไขข้อมูลส่วนบุคคลของท่านให้ถูกต้อง หากข้อมูลส่วนบุคคลของท่านนั้นไม่ถูกต้อง ไม่เป็นปัจจุบัน ไม่ครบถ้วนสมบูรณ์ หรือก่อให้เกิดความเข้าใจผิด</p></div>
                             <div class="right-item"><h4>7. สิทธิที่จะเพิกถอนความยินยอม</h4><p>ในกรณีที่บริษัทฯ อาศัยความยินยอมของท่านในการประมวลผลข้อมูลส่วนบุคคลฯ ของท่าน ท่านมีสิทธิในการเพิกถอนความยินยอมในการประมวลผลข้อมูลส่วนบุคคลที่ท่านได้ให้ความยินยอมกับบริษัทฯ ได้</p></div>
                             <div class="right-item"><h4>8. สิทธิในการยื่นข้อร้องเรียน</h4><p>หากท่านมีความกังวลหรือมีข้อสงสัยเกี่ยวกับแนวทางการปฏิบัติของบริษัทฯ เกี่ยวกับข้อมูลส่วนบุคคลของท่าน โปรดติดต่อบริษัทฯ โดยใช้รายละเอียดการติดต่อตามข้อ 13 ของประกาศฯ ฉบับนี้ ทั้งนี้ ในกรณีที่มีเหตุให้เชื่อได้ว่าบริษัทฯ ได้ทำการฝ่าฝืนกฎหมายว่าด้วยการคุ้มครองข้อมูลส่วนบุคคล ท่านมีสิทธิยื่นข้อร้องเรียน ต่อคณะกรรมการผู้เชี่ยวชาญที่ได้รับการแต่งตั้งโดยคณะกรรมการคุ้มครองข้อมูลส่วนบุคคลตามระเบียบและวิธีการตามที่กฎหมายว่าด้วยการคุ้มครองข้อมูลส่วนบุคคลกำหนด</p></div>
                            <p>ทั้งนี้บริษัทฯ ขอสงวนสิทธิในการพิจารณาคำร้องขอใช้สิทธิของท่าน โดยบริษัทฯ จะดำเนินการตามที่กฎหมายว่าด้วยการคุ้มครองข้อมูลส่วนบุคคลกำหนดไว้</p>
                            <p>การใช้สิทธิของท่านตามข้างต้นอาจถูกจำกัดภายใต้กฎหมายที่เกี่ยวข้อง และมีบางกรณีที่มีเหตุจำเป็นที่บริษัทฯ อาจปฏิเสธหรือไม่สามารถดำเนินการตามคำขอใช้สิทธิของท่านได้ เช่น บริษัทฯ จำเป็นต้องปฏิบัติตามกฎหมายหรือคำสั่งศาล หรือการใช้สิทธินั้นๆ อาจละเมิดสิทธิหรือเสรีภาพของบุคคลอื่น หรือบริษัทฯ จำเป็นต้องใช้สิทธิเรียกร้องตามกฎหมายที่เกี่ยวข้องในการเก็บรักษาข้อมูลดังกล่าว โดยบริษัทฯ จะแจ้งเหตุผลของการปฏิเสธให้ท่านทราบ</p>
                            <p>หากท่านต้องการใช้สิทธิตามข้างต้น ท่านสามารถยื่นคำขอมายังบริษัทฯ</p>
                            <p>ในกรณีที่มีการละเมิดข้อมูลส่วนบุคคล ให้ผู้ควบคุมข้อมูลนั้นแจ้งต่อ หัวหน้าหน่วยงาน ภายใน 24 ชั่วโมง โดยให้ทำการสรุปสาเหตุ ร่วมกับส่วนงานที่เกี่ยวข้อง ภายใน 24 ชม. และ ส่งข้อมูลต่อเจ้าหน้าที่คุ้มครองข้อมูลส่วนบุคคล (Data Protection Officer: DPO) ภายใน 24 ชั่วโมง เพื่อแจ้งและประสาน หน่วยงานกำกับ PDPA ที่เกี่ยวข้อง (โดยทั้งหมดไม่เกิน 72 ชั่วโมง นับตั้งแต่ทราบเรื่อง)</p>
                            <h4>11. ขอบเขตของประกาศเกี่ยวกับคุ้มครองข้อมูลส่วนบุคคล</h4>
                            <p>ประกาศเกี่ยวกับการคุ้มครองข้อมูลส่วนบุคคลฉบับนี้ ใช้เฉพาะการให้บริการของบริษัทฯ เท่านั้น ในกรณีที่ท่านเชื่อมต่อไปยังแพลตฟอร์มของบริษัทอื่น แม้จะเป็นการเชื่อมต่อผ่านลิงก์ที่อยู่ในเว็บไซต์ของบริษัทฯ ก็ตาม นโยบายคุ้มครองข้อมูลส่วนบุคคลฉบับนี้จะไม่มีผลผูกพัน ท่านจำเป็นต้องศึกษาและปฏิบัติตามนโยบายคุ้มครองข้อมูลส่วนบุคคลที่ปรากฏบนแพลตฟอร์มเหล่านั้น และบริษัทฯ จะไม่รับผิดชอบเกี่ยวกับการดำเนินการต่าง ๆ ของแพลตฟอร์มอื่นนั้นทั้งสิ้น</p>
                            <h4>12. การเปลี่ยนแปลงนโยบายคุ้มครองข้อมูลส่วนบุคคล</h4>
                            <p>บริษัทฯ จะทำการพิจารณาทบทวนนโยบายคุ้มครองข้อมูลส่วนบุคคลเป็นประจำเพื่อให้สอดคล้องกับแนวทางปฏิบัติ และกฎหมาย ข้อบังคับที่เกี่ยวข้อง ทั้งนี้ หากมีการเปลี่ยนแปลงนโยบายคุ้มครองข้อมูลส่วนบุคคล บริษัทฯ จะแจ้งให้ท่านทราบโดยการประกาศข้อมูลลงในเว็บไซต์ของบริษัทฯ</p>
                            <h4>13. ช่องทางการติดต่อบริษัทฯ และเจ้าหน้าที่คุ้มครองข้อมูลส่วนบุคคล</h4>
                            <p>ท่านสามารถติดต่อบริษัทฯ เพื่อเสนอแนะ หรือสอบถามรายละเอียดเพิ่มเติมเกี่ยวกับนโยบายคุ้มครองข้อมูลส่วนบุคคลได้ที่</p>
                            <p><strong>บริษัท โอเค นัมเบอร์ วัน จำกัด</strong></p>
                            <p><strong>13.1 เจ้าหน้าที่คุ้มครองข้อมูลส่วนบุคคล DPO (Data Protection Officer)</strong><br>เลขที่1อาคารศูนย์การค้าเซ็นเตอร์วัน ซอย เลิศปัญญา ถนนราชวิถี แขวงถนนพญาไท เขตราชเทวี กรุงเทพมหานคร 10400<br>E-mail: dpo@no1.email<br>Tel: 02-127-0010</p>
                            <p><strong>13.2 ผู้ควบคุมข้อมูลส่วนบุคคล (Data Controller)</strong><br>บริษัท โอเค นัมเบอร์ วัน จำกัด<br>เลขที่1อาคารศูนย์การค้าเซ็นเตอร์วัน ซอย เลิศปัญญา ถนนราชวิถี แขวงถนนพญาไท เขตราชเทวี กรุงเทพมหานคร 10400<br>E-mail: pdpa@no1.email<br>Tel: 02-127-0010</p>
                        </div><!-- End pdpa-scroll-container -->
                        <!-- Checkbox Section -->
                         <div class="pdpa-checkbox">
                             <input type="checkbox" id="pdpa-agreement" name="pdpa_agreement" value="accepted" required>
                             <label for="pdpa-agreement" class="pdpa-text">ข้าพเจ้าได้อ่านและเข้าใจ <a href="#" class="pdpa-link" onclick="document.getElementById('pdpa-full-text').scrollIntoView({ behavior: 'smooth', block: 'start' }); return false;">นโยบายความเป็นส่วนตัว</a> ฉบับนี้แล้ว และยินยอมให้บริษัทเก็บรวบรวม ใช้ และเปิดเผยข้อมูลส่วนบุคคลของข้าพเจ้าตามวัตถุประสงค์ที่ระบุไว้</label>
                         </div>
                         <div class="pdpa-checkbox">
                             <input type="checkbox" id="marketing-consent" name="marketing_consent" value="accepted">
                             <label for="marketing-consent" class="pdpa-text">ข้าพเจ้ายินยอมรับข้อมูลข่าวสาร โปรโมชั่น และข้อเสนอพิเศษต่างๆ จากบริษัทและบริษัทในกลุ่ม (เลือกได้)</label>
                         </div>

                    </div><!-- End pdpa-agreement -->

                     <!-- Button Group: Primary first -->
                    <div class="btn-group">
                        <button type="button" class="btn next-step btn-3d" id="accept-pdpa-btn" data-next="2" disabled>ยอมรับและดำเนินการต่อ <i class="fas fa-arrow-right"></i></button>
                        <!-- No Back button on first step -->
                    </div>

                    <div class="security-badge">
                        <i class="fas fa-lock"></i>
                        <span>ข้อมูลของคุณจะถูกเก็บเป็นความลับและปลอดภัยด้วยระบบ SSL</span>
                    </div>
                </div>

                <!-- Step 2: PIN Code Setup -->
                <div class="form-step" id="step-2">
                    <!-- ... Step 2 HTML ... -->
                     <h2><i class="fas fa-key step-icon"></i> ตั้งรหัส PIN</h2>
                    <p class="text-muted">กรุณาตั้งรหัส PIN 6 หลักสำหรับใช้ในการเข้าสู่ระบบ</p>

                    <div class="form-group pin-code-container">
                        <label class="input-label required-field">
                            <i class="fas fa-lock"></i>
                            <span>รหัส PIN (6 หลัก)</span>
                        </label>

                        <div class="pin-input-container">
                             <!-- PIN Display Fields -->
                            <div class="pin-input-fields">
                                <div class="pin-input-field" data-index="0"> <div class="pin-input-dot"></div> </div>
                                <div class="pin-input-field" data-index="1"> <div class="pin-input-dot"></div> </div>
                                <div class="pin-input-field" data-index="2"> <div class="pin-input-dot"></div> </div>
                                <div class="pin-input-field" data-index="3"> <div class="pin-input-dot"></div> </div>
                                <div class="pin-input-field" data-index="4"> <div class="pin-input-dot"></div> </div>
                                <div class="pin-input-field" data-index="5"> <div class="pin-input-dot"></div> </div>
                            </div>

                            <!-- Enhanced Keyboard Container -->
                            <div class="keyboard-container">
                                <div class="keyboard-title">กรุณากดรหัส PIN บนแป้นพิมพ์</div>
                                <div class="numeric-keyboard">
                                    <div class="numeric-key" data-value="1">1</div>
                                    <div class="numeric-key" data-value="2">2</div>
                                    <div class="numeric-key" data-value="3">3</div>
                                    <div class="numeric-key" data-value="4">4</div>
                                    <div class="numeric-key" data-value="5">5</div>
                                    <div class="numeric-key" data-value="6">6</div>
                                    <div class="numeric-key" data-value="7">7</div>
                                    <div class="numeric-key" data-value="8">8</div>
                                    <div class="numeric-key" data-value="9">9</div>
                                    <div class="numeric-key placeholder"></div> <!-- Styled Placeholder -->
                                    <div class="numeric-key" data-value="0">0</div>
                                    <div class="numeric-key backspace" data-action="backspace">
                                        <i class="fas fa-delete-left"></i> <!-- Changed Icon -->
                                    </div>
                                </div>
                                <div class="keyboard-note">ห้ามเปิดเผยรหัส PIN ให้ผู้อื่นทราบ</div>
                            </div>
                        </div>
                    </div>

                    <!-- Button Group: Primary first -->
                    <div class="btn-group">
                        <button type="button" class="btn next-step btn-3d" id="confirm-pin-btn" data-next="3" disabled>ยืนยันรหัส PIN <i class="fas fa-check"></i></button>
                        <button type="button" class="btn btn-outline prev-step" data-prev="1"><i class="fas fa-arrow-left"></i> ย้อนกลับ</button>
                    </div>
                </div>

                <!-- Step 3: Basic Information -->
                <div class="form-step" id="step-3">
                    <!-- ... Step 3 HTML ... -->
                     <h2><i class="fas fa-user-edit step-icon"></i> ข้อมูลเบื้องต้น</h2>
                    <p class="text-muted">กรุณากรอกข้อมูลพื้นฐานเพื่อเริ่มกระบวนการยืนยันตัวตน</p>

                    <div class="form-group">
                        <label class="input-label required-field" for="phone">
                            <i class="fas fa-phone"></i>
                            <span>หมายเลขโทรศัพท์</span>
                        </label>
                        <div class="input-with-icon">
                            <input type="tel" id="phone" placeholder="เช่น 0812345678" maxlength="10" inputmode="numeric">
                            <i class="fas fa-check-circle validation-icon hidden" id="phone-valid-icon" style="color: var(--success-color);"></i>
                        </div>
                        <small class="text-muted">ระบบจะส่ง OTP ไปยังหมายเลขนี้เพื่อยืนยัน</small>
                         <!-- Warning will be shown by JS only when needed -->
                        <div class="duplicate-warning" id="phone-warning">
                            <i class="fas fa-exclamation-circle"></i> หมายเลขโทรศัพท์นี้ถูกใช้งานแล้ว
                        </div>
                    </div>

                    <div class="form-group">
                        <label class="input-label required-field" for="id-number">
                             <i class="fas fa-id-card"></i>
                             <span>เลขบัตรประชาชน</span>
                         </label>
                        <div class="input-with-icon">
                            <input type="text" id="id-number" placeholder="เช่น 1234567890123" maxlength="13" inputmode="numeric">
                            <i class="fas fa-check-circle validation-icon hidden" id="id-valid-icon" style="color: var(--success-color);"></i>
                        </div>
                         <!-- Warning will be shown by JS only when needed -->
                         <div class="duplicate-warning" id="id-warning">
                             <i class="fas fa-exclamation-circle"></i> รูปแบบเลขบัตรประชาชนไม่ถูกต้อง
                         </div>
                    </div>

                    <div class="form-group">
                        <label class="input-label required-field">
                            <i class="fas fa-birthday-cake"></i>
                            <span>วันเดือนปีเกิด (พ.ศ.)</span>
                        </label>
                        <div class="birthdate-fields">
                            <div class="birthdate-field">
                                <select id="birth-day" class="form-control" aria-label="เลือกวันเกิด">
                                    <option value="" selected disabled>วัน</option>
                                </select>
                            </div>
                            <div class="birthdate-field">
                                <select id="birth-month" class="form-control" aria-label="เลือกเดือนเกิด">
                                    <option value="" selected disabled>เดือน</option>
                                    <option value="1">มกราคม</option>
                                    <option value="2">กุมภาพันธ์</option>
                                    <option value="3">มีนาคม</option>
                                    <option value="4">เมษายน</option>
                                    <option value="5">พฤษภาคม</option>
                                    <option value="6">มิถุนายน</option>
                                    <option value="7">กรกฎาคม</option>
                                    <option value="8">สิงหาคม</option>
                                    <option value="9">กันยายน</option>
                                    <option value="10">ตุลาคม</option>
                                    <option value="11">พฤศจิกายน</option>
                                    <option value="12">ธันวาคม</option>
                                </select>
                            </div>
                            <div class="birthdate-field">
                                <select id="birth-year" class="form-control" aria-label="เลือกปีเกิด พ.ศ.">
                                    <option value="" selected disabled>ปี</option>
                                </select>
                            </div>
                        </div>
                        <div class="duplicate-warning" id="birthdate-warning" style="display: none;">
                            <i class="fas fa-exclamation-circle"></i> อายุต้องอยู่ระหว่าง 18-65 ปี หรือ วันที่ไม่ถูกต้อง
                        </div>
                    </div>

                    <!-- <<< START: Current Address Section >>> -->
                    <div class="form-group">
                        <label class="input-label required-field" for="current-address">
                            <i class="fas fa-map-marker-alt"></i>
                            <span>ที่อยู่ปัจจุบัน (GPS)</span>
                        </label>
                        <textarea id="current-address" rows="3" placeholder="กดปุ่ม 'ค้นหาตำแหน่งปัจจุบัน' เพื่อดึงข้อมูล" readonly></textarea>
                        <button type="button" id="get-location-btn" class="btn btn-outline">
                            <i class="fas fa-location-crosshairs"></i> ค้นหาตำแหน่งปัจจุบัน
                        </button>
                         <div id="location-status" class="location-status"></div> <!-- Status messages -->
                        <!-- Map Container -->
                        <div id="map-container" class="hidden">
                            <div id="map"></div>
                            <small class="text-muted" style="display: block; text-align: center; margin-top: 5px;">แผนที่แสดงตำแหน่งปัจจุบันโดยประมาณ</small>
                        </div>
                         <!-- Warning for missing address -->
                         <div class="duplicate-warning" id="address-warning" style="display: none;">
                             <i class="fas fa-exclamation-circle"></i> กรุณากรอกหรือค้นหาที่อยู่ปัจจุบัน
                         </div>
                    </div>
                    <!-- <<< END: Current Address Section >>> -->


                    <!-- Button Group: Primary first -->
                    <div class="btn-group">
                        <button type="button" class="btn next-step btn-3d" id="send-otp-btn" data-next="4" disabled>ส่ง OTP <i class="fas fa-paper-plane"></i></button>
                        <button type="button" class="btn btn-outline prev-step" data-prev="2"><i class="fas fa-arrow-left"></i> ย้อนกลับ</button>
                    </div>
                </div>

                <!-- Step 4: OTP Verification -->
                <div class="form-step" id="step-4">
                     <!-- ... Step 4 HTML ... -->
                    <h2><i class="fas fa-sms step-icon"></i> ยืนยันหมายเลขโทรศัพท์</h2>
                    <p class="text-muted">กรุณากรอกรหัส OTP ที่ส่งไปยังหมายเลข <strong id="otp-phone-number" style="font-weight: 500; color: var(--primary-color);"></strong></p>

                    <div class="otp-container">
                        <input type="text" class="otp-input" maxlength="1" data-index="0" inputmode="numeric" pattern="[0-9]*" aria-label="OTP digit 1">
                        <input type="text" class="otp-input" maxlength="1" data-index="1" inputmode="numeric" pattern="[0-9]*" aria-label="OTP digit 2">
                        <input type="text" class="otp-input" maxlength="1" data-index="2" inputmode="numeric" pattern="[0-9]*" aria-label="OTP digit 3">
                        <input type="text" class="otp-input" maxlength="1" data-index="3" inputmode="numeric" pattern="[0-9]*" aria-label="OTP digit 4">
                        <input type="text" class="otp-input" maxlength="1" data-index="4" inputmode="numeric" pattern="[0-9]*" aria-label="OTP digit 5">
                        <input type="text" class="otp-input" maxlength="1" data-index="5" inputmode="numeric" pattern="[0-9]*" aria-label="OTP digit 6">
                    </div>

                    <!-- Updated OTP reference display -->
                    <div class="otp-reference"> <!-- Initially hidden -->
                        <p>รหัสอ้างอิง: <strong id="otp-reference-code">------</strong></p>
                    </div>

                    <div class="resend-otp">
                        ไม่ได้รับรหัส OTP? <a href="#" id="resend-otp-link" class="disabled">ส่งรหัสใหม่</a> (<span id="countdown">60s</span>)
                    </div>

                    <!-- Button Group: Primary first -->
                    <div class="btn-group">
                        <!-- Changed button type to button, handler added in JS -->
                        <button type="button" class="btn btn-3d" id="verify-otp-btn" data-next="5" disabled>ยืนยัน OTP <i class="fas fa-check"></i></button>
                        <button type="button" class="btn btn-outline prev-step" data-prev="3"><i class="fas fa-arrow-left"></i> ย้อนกลับ</button>
                    </div>
                </div>


                <!-- Step 5: ID Card Verification -->
                <div class="form-step" id="step-5">
                    <!-- ... Step 5 HTML ... -->
                    <h2><i class="fas fa-id-card step-icon"></i> ยืนยันตัวตนด้วยบัตรประชาชน</h2>
                    <p class="text-muted">กรุณาถ่ายภาพบัตรประชาชนทั้งด้านหน้าและด้านหลัง (หลังจากดูวิดีโอแนะนำ)</p>

                     <!-- Camera guide overlay (Common for both front and back) -->
                     <div class="camera-guide hidden" id="id-card-camera-guide">
                         <div class="id-card-frame"></div>
                         <div class="id-card-guide-text">วางบัตรประชาชนให้อยู่ในกรอบให้ชัดเจน</div>
                     </div>

                    <div class="id-card-guide">
                        <h4><i class="fas fa-info-circle"></i> วิธีการถ่ายภาพบัตรประชาชน</h4>
                        <ul>
                            <li>วางบัตรประชาชนบนพื้นผิวเรียบ ไม่สะท้อนแสง</li>
                            <li>ถ่ายในที่แสงสว่างเพียงพอ หลีกเลี่ยงเงาบนบัตร</li>
                            <li>ให้บัตรอยู่ในกรอบที่ปรากฏบนหน้าจอ</li>
                            <li>ตรวจสอบว่าข้อมูลบนบัตรอ่านได้ชัดเจน ไม่เบลอ</li>
                        </ul>
                    </div>

                    <div class="form-row">
                        <div class="form-col">
                            <div class="form-group">
                                <label class="input-label required-field" for="id-card-front">
                                    <i class="fas fa-id-card"></i>
                                    <span>บัตรประชาชนด้านหน้า</span>
                                </label>
                                <div class="upload-area disabled" id="id-card-front-drop">
                                    <i class="fas fa-camera"></i>
                                    <p>กดเพื่อถ่ายภาพบัตรด้านหน้า</p>
                                    <small>ต้องเห็นเลขบัตร, ชื่อ-นามสกุล และรูปภาพชัดเจน</small>
                                </div>
                                <input type="file" id="id-card-front" accept="image/jpeg, image/png, image/gif, image/heic, image/heif" class="hidden" capture="environment">
                                <div class="preview-container hidden" id="front-preview-container">
                                    <div class="preview-card">
                                        <img src="" alt="บัตรประชาชนด้านหน้า" class="preview-image" id="front-preview-image">
                                        <div class="preview-info"> <p>บัตรประชาชนด้านหน้า</p> </div>
                                        <button type="button" class="remove-btn" id="remove-front" aria-label="ลบรูปบัตรด้านหน้า"><i class="fas fa-times"></i></button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="form-col">
                            <div class="form-group">
                                <label class="input-label required-field" for="id-card-back">
                                    <i class="fas fa-id-card"></i>
                                    <span>บัตรประชาชนด้านหลัง</span>
                                </label>
                                <div class="upload-area disabled" id="id-card-back-drop">
                                    <i class="fas fa-camera"></i>
                                    <p>กดเพื่อถ่ายภาพบัตรด้านหลัง</p>
                                    <small>ต้องเห็น Laser ID (ถ้ามี) ชัดเจน</small>
                                </div>
                                <input type="file" id="id-card-back" accept="image/jpeg, image/png, image/gif, image/heic, image/heif" class="hidden" capture="environment">
                                <div class="preview-container hidden" id="back-preview-container">
                                    <div class="preview-card">
                                        <img src="" alt="บัตรประชาชนด้านหลัง" class="preview-image" id="back-preview-image">
                                        <div class="preview-info"> <p>บัตรประชาชนด้านหลัง</p> </div>
                                        <button type="button" class="remove-btn" id="remove-back" aria-label="ลบรูปบัตรด้านหลัง"><i class="fas fa-times"></i></button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="form-group hidden" id="trigger-ocr-group" style="text-align: center; margin-top: 20px;">
                        <button type="button" class="btn btn-3d" id="trigger-ocr-btn" style="width: auto; padding: 12px 24px;" disabled>
                            <i class="fas fa-sync-alt"></i> อ่านข้อมูลบัตร
                        </button>
                        <small class="text-muted" style="display: block; text-align: center; margin-top: 8px;">กดปุ่มนี้หลังจากอัปโหลดภาพบัตรทั้ง 2 ด้านแล้ว</small>
                    </div>

                    <div class="ocr-result hidden" id="ocr-result">
                        <h4><i class="fas fa-check-circle"></i> ตรวจสอบข้อมูลจากบัตรประชาชน</h4>
                        <p class="text-muted" style="margin-bottom: 15px;">กรุณาตรวจสอบและแก้ไขข้อมูลหากไม่ถูกต้อง</p>
                        <div class="form-row">
                            <div class="form-col">
                                <div class="form-group">
                                    <label class="input-label" for="id-number-kyc"><i class="fas fa-id-card"></i><span>เลขบัตรประชาชน</span></label>
                                    <input type="text" id="id-number-kyc"  >
                                </div>
                            </div>
                           <div class="form-col">
                               <div class="form-group">
                                   <label class="input-label" for="firstname-th"><i class="fas fa-user"></i><span>ชื่อ (ภาษาไทย)</span></label>
                                   <input type="text" id="firstname-th" placeholder="ชื่อตามบัตรประชาชน">
                               </div>
                           </div>
                        </div>
                         <div class="form-row">
                            <div class="form-col">
                                <div class="form-group">
                                    <label class="input-label" for="lastname-th"><i class="fas fa-user"></i><span>นามสกุล (ภาษาไทย)</span></label>
                                    <input type="text" id="lastname-th" placeholder="นามสกุลตามบัตรประชาชน">
                                </div>
                            </div>
                            <div class="form-col">
                                <div class="form-group">
                                    <label class="input-label" for="firstname-en"><i class="fas fa-user"></i><span>ชื่อ (ภาษาอังกฤษ)</span></label>
                                    <input type="text" id="firstname-en" placeholder="Firstname (optional)">
                                </div>
                            </div>
                         </div>
                        <div class="form-row">
                            <div class="form-col">
                                <div class="form-group">
                                    <label class="input-label" for="lastname-en"><i class="fas fa-user"></i><span>นามสกุล (ภาษาอังกฤษ)</span></label>
                                    <input type="text" id="lastname-en" placeholder="Lastname (optional)">
                                </div>
                            </div>
                             <div class="form-col">
                                <div class="form-group">
                                    <label class="input-label" for="birthdate-kyc"><i class="fas fa-birthday-cake"></i><span>วันเกิด (พ.ศ.)</span></label>
                                    <input type="text" id="birthdate-kyc" >
                                    <input type="hidden" id="birth-day-kyc">
                                    <input type="hidden" id="birth-month-kyc">
                                    <input type="hidden" id="birth-year-kyc">
                                </div>
                            </div>
                        </div>
                        <div class="form-row">
                            <div class="form-col">
                                <div class="form-group">
                                    <label class="input-label" for="address-kyc"><i class="fas fa-map-marker-alt"></i><span>ที่อยู่ตามบัตร</span></label>
                                    <textarea id="address-kyc" rows="3" placeholder="ที่อยู่ตามบัตรประชาชน"></textarea>
                                </div>
                            </div>
                        </div>
                        <div class="form-row">
                            <div class="form-col">
                                <div class="form-group">
                                    <label class="input-label" for="issue-date"><i class="fas fa-calendar-alt"></i><span>วันที่ออกบัตร (พ.ศ.)</span></label>
                                    <input type="text" id="issue-date" >
                                </div>
                            </div>
                            <div class="form-col">
                                <div class="form-group">
                                    <label class="input-label" for="expiry-date"><i class="fas fa-calendar-times"></i><span>วันหมดอายุ (พ.ศ.)</span></label>
                                    <input type="text" id="expiry-date" >
                                </div>
                            </div>
                        </div>
                         <div class="form-row">
                             <div class="form-col">
                                 <div class="form-group">
                                     <label class="input-label" for="laser-id-kyc"><i class="fas fa-barcode"></i><span>Laser ID (หลังบัตร)</span></label>
                                     <input type="text" id="laser-id-kyc" >
                                 </div>
                             </div>
                         </div>
                    </div>

                    <div class="btn-group">
                        <button type="button" class="btn next-step btn-3d" id="verify-id-card-btn" data-next="6" disabled>ยืนยันข้อมูลบัตร <i class="fas fa-check"></i></button>
                        <button type="button" class="btn btn-outline prev-step" data-prev="4"><i class="fas fa-arrow-left"></i> ย้อนกลับ</button>
                    </div>
                </div>

                <!-- Step 6: Face Verification & Video Recording (Modified HTML Structure) -->
                <div class="form-step" id="step-6">
                    <h2><i class="fas fa-user-check step-icon"></i> ยืนยันตัวตนด้วยใบหน้าและวิดีโอ</h2>
                    <p class="text-muted">กรุณาทำตามขั้นตอนด้านล่างเพื่อยืนยันตัวตนของคุณ (หลังจากดูวิดีโอแนะนำ)</p>

                    <div class="face-verification">
                        <!-- Face Capture Section (Contains Face Verification Elements) -->
                        <div id="face-capture-section">
                            <p class="text-muted" style="margin-bottom: 15px;">ส่วนที่ 1: บันทึกภาพใบหน้าตามคำแนะนำ</p>
                            <!-- Webcam Container for Face Verification -->
                            <div class="webcam-container" id="webcam-container-face">
                                <video id="webcam-face" autoplay playsinline muted></video>
                                <!-- Added Face Verification Elements -->
                                <div id="face-guide-frame"></div> <!-- Guide Frame -->
                                <div id="debug-info" class="hidden"></div> <!-- Debug Info -->
                                <div class="face-status-text hidden" id="face-status-text"></div>
                                <div class="face-action-text hidden" id="face-action-text"></div>
                                <div class="face-countdown-text hidden" id="face-countdown-text"></div>
                                <!-- Loading/Instruction Overlay for Face -->
                                <div class="webcam-overlay" id="webcam-face-overlay">
                                    <i class="fas fa-camera-retro" style="font-size: 30px; margin-bottom: 10px;"></i>
                                    <p>กำลังเตรียมกล้อง...</p>
                                    <p style="font-size: 13px; margin-top: 10px;">
                                        ต้องเป็นภาพล่าสุด ห้ามใส่แว่นตาดำ หมวก หรือสิ่งปกปิดใบหน้า
                                    </p>
                                </div>
                            </div>
                            <!-- Action Buttons for Face Verification (Styled via CSS) -->
                            <div class="action-buttons">
                                <button type="button" class="btn btn-3d" id="start-face-capture" disabled>
                                    <i class="fas fa-camera"></i> เริ่มบันทึกภาพใบหน้า
                                </button>
                                <button type="button" class="btn btn-outline hidden" id="retake-face-capture" disabled>
                                    <i class="fas fa-redo"></i> บันทึกใบหน้าใหม่
                                </button>
                            </div>
                             <!-- Container for Captured Faces -->
                             <div class="captured-faces-container hidden" id="captured-faces-container"></div>
                        </div>

                        <!-- Video Recording Section (Initially Hidden) -->
                        <div class="video-recording-container hidden" id="video-recording-section">
                             <h4><i class="fas fa-video"></i> ส่วนที่ 2: บันทึกวิดีโอเพื่อยืนยัน</h4>
                            <p class="text-muted" style="margin-bottom: 10px;">กรุณาอ่านออกเสียงตามข้อความต่อไปนี้ให้ชัดเจน:</p>
                            <!-- Webcam Container for Video Recording -->
                            <div class="webcam-container" style="margin-bottom: 10px;">
                                <video id="webcam-video" autoplay playsinline muted></video>
                                <div id="recording-instruction-container">
                                    <p id="recording-instruction">
                                        "ข้าพเจ้า [ชื่อ-นามสกุล] ขอยืนยันว่าข้อมูลทั้งหมดที่ให้ไว้เป็นความจริงและถูกต้องทุกประการ"
                                    </p>
                                </div>
                                 <div class="recording-indicator hidden" id="recording-indicator">
                                    <div class="pulse-dot"></div>
                                    <span>กำลังบันทึก...</span>
                                </div>
                            </div>
                            <!-- Action Buttons for Video Recording (Styled via CSS) -->
                            <div class="action-buttons">
                                <button type="button" class="btn btn-3d" id="start-recording" disabled>
                                    <i class="fas fa-microphone"></i> เริ่มบันทึกวิดีโอ
                                </button>
                                <button type="button" class="btn hidden" id="stop-recording" style="background: var(--danger-color);" disabled>
                                    <i class="fas fa-stop"></i> หยุดบันทึก
                                </button>
                            </div>
                            <!-- Video Preview -->
                            <div class="preview-container hidden" id="video-preview-container" style="margin-top: 20px;">
                                 <div class="preview-card">
                                      <video controls controlsList="nodownload noremoteplayback" disablePictureInPicture class="preview-image" id="video-preview"></video>
                                      <div class="preview-info">
                                          <p>วิดีโอการยืนยันของคุณ</p>
                                      </div>
                                      <button type="button" class="remove-btn" id="remove-video" aria-label="ลบวิดีโอ"><i class="fas fa-times"></i></button>
                                 </div>
                             </div>
                        </div>
                    </div> <!-- End face-verification -->

                    <!-- Button Group -->
           <div class="btn-group">
    <button type="button" class="btn btn-3d hidden" id="submit-kyc-btn" disabled>ส่งข้อมูลเพื่อตรวจสอบ <i class="fas fa-paper-plane"></i></button>
    <button type="button" class="btn btn-outline prev-step" data-prev="5"><i class="fas fa-arrow-left"></i> ย้อนกลับ</button>
</div>

<!-- แยก progress bar ออกมา -->
<div class="progress-container" style="display: none; margin: 20px 0;">
    <label for="upload-progress">กำลังอัปโหลดวิดีโอ:</label>
    <div class="progress-wrapper" style="position: relative; margin-top: 8px;">
        <progress id="upload-progress" value="0" max="100" style="width: 100%; height: 20px;"></progress>
        <div id="progress-text" style="position: absolute; top: 0; left: 0; right: 0; text-align: center; line-height: 20px; color: #000;">0%</div>
    </div>
</div>
                </div>

                <!-- Success Step -->
                <div class="form-step" id="success-step">
                     <!-- ... Step Success HTML ... -->
                    <div class="success-message">
                        <div class="pulse" style="margin-bottom: 20px;">
                             <i class="fas fa-check-circle success-icon"></i>
                        </div>
                        <h2>ส่งข้อมูลสำเร็จ!</h2>
                        <p>ระบบได้รับข้อมูลการยืนยันตัวตนของคุณเรียบร้อยแล้ว</p>
                        <p>กรุณารอการตรวจสอบและอนุมัติจากเจ้าหน้าที่ ซึ่งอาจใช้เวลา 1-3 วันทำการ</p>
                        <p>คุณจะได้รับการแจ้งเตือนผ่าน LINE หรือ SMS เมื่อสถานะมีการเปลี่ยนแปลง</p>
                        <div class="status-pending" style="margin: 20px auto;">
                            <i class="fas fa-clock"></i> อยู่ระหว่างการตรวจสอบ
                        </div>
                        <button type="button" class="btn btn-3d" id="close-app-btn">
                            <i class="fas fa-times"></i> ปิดหน้าต่างนี้
                        </button>
                    </div>
                </div>
            </div> <!-- End card-body -->
        </div> <!-- End registration-card -->
    </div> <!-- End container -->
    <!-- <<< END: Main Registration Container >>> -->

    <!-- Scripts (JavaScript will be provided separately) -->
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script src="https://cdn.jsdelivr.net/npm/swiper@11/swiper-bundle.min.js"></script>
  <script type="module">

    document.addEventListener('DOMContentLoaded', function() {

        // --- Swiper Slider Initialization and Control ---
        const fullscreenSlider = document.getElementById('fullscreen-slider');
        const registrationContainer = document.getElementById('registration-container');
        const bodyElement = document.body;

        const swiper = new Swiper('#fullscreen-slider .swiper', {
            direction: 'horizontal',
            loop: true,
            autoplay: {
                delay: 5000,
                disableOnInteraction: false,
            },
            pagination: {
                el: '.swiper-pagination',
                clickable: true,
            },
            navigation: {
                nextEl: '.swiper-button-next',
                prevEl: '.swiper-button-prev',
            },
            grabCursor: true,
        });
        const sliderRegisterButtons = document.querySelectorAll('.slider-register-btn');
        sliderRegisterButtons.forEach(button => {
            button.addEventListener('click', () => {
                console.log("Register button clicked - hiding slider, showing form");
                unlockAudioContext(); // Unlock context on first interaction
                if (swiper && swiper.autoplay && swiper.autoplay.running) swiper.autoplay.stop();
                if (fullscreenSlider) fullscreenSlider.style.display = 'none';
                if (registrationContainer) registrationContainer.style.display = 'block';
                if (bodyElement) bodyElement.style.overflowY = 'auto';
                if (registrationContainer) registrationContainer.scrollIntoView({ behavior: 'auto', block: 'start' });
            }, { once: true });
        });
        const sliderLearnMoreButtons = document.querySelectorAll('.slider-learn-more-btn');
        sliderLearnMoreButtons.forEach(button => {
            button.addEventListener('click', () => {
                console.log("Learn More button clicked");
                Swal.fire({
                    title: 'รายละเอียดเพิ่มเติม',
                    text: 'ส่วนนี้สำหรับแสดงข้อมูลเพิ่มเติมเกี่ยวกับบริการหรือโปรโมชั่น',
                    icon: 'info',
                    confirmButtonText: 'ตกลง',
                    confirmButtonColor: 'var(--primary-color)',
                });
            });
        });


        // --- Registration Form Logic ---
        const nextButtons = document.querySelectorAll('.next-step');
        const prevButtons = document.querySelectorAll('.prev-step');
        const steps = document.querySelectorAll('.form-step');
        const cardBody = registrationContainer?.querySelector('.card-body');
        const flashEffect = document.getElementById('flash-effect');
        const closeAppBtn = document.getElementById('close-app-btn');
        const pdpaCheckbox = document.getElementById('pdpa-agreement');
        const marketingCheckbox = document.getElementById('marketing-consent');
        const acceptPdpaBtn = document.getElementById('accept-pdpa-btn');
        const pinFields = document.querySelectorAll('.pin-input-field');
        const numericKeys = document.querySelectorAll('.numeric-key[data-value]');
        const backspaceKey = document.querySelector('.numeric-key.backspace');
        const confirmPinBtn = document.getElementById('confirm-pin-btn');
        const phoneInput = document.getElementById('phone');
        const idInput = document.getElementById('id-number');
        const birthDaySelect = document.getElementById('birth-day');
        const birthMonthSelect = document.getElementById('birth-month');
        const birthYearSelect = document.getElementById('birth-year');
        const phoneValidIcon = document.getElementById('phone-valid-icon');
        const idValidIcon = document.getElementById('id-valid-icon');
        const phoneWarning = document.getElementById('phone-warning');
        const idWarning = document.getElementById('id-warning');
        const birthdateWarning = document.getElementById('birthdate-warning');
        const sendOtpBtn = document.getElementById('send-otp-btn');
        const currentAddressTextarea = document.getElementById('current-address');
        const getLocationBtn = document.getElementById('get-location-btn');
        const mapContainer = document.getElementById('map-container');
        const mapElement = document.getElementById('map');
        const locationStatus = document.getElementById('location-status');
        const addressWarning = document.getElementById('address-warning');
        const otpInputs = document.querySelectorAll('.otp-input');
        const otpPhoneNumber = document.getElementById('otp-phone-number');
        const otpReferenceCode = document.getElementById('otp-reference-code');
        const otpReference = document.querySelector('.otp-reference');
        const countdownElement = document.getElementById('countdown');
        const resendOtpLink = document.getElementById('resend-otp-link');
        const verifyOtpBtn = document.getElementById('verify-otp-btn');
        const idCardFrontInput = document.getElementById('id-card-front');
        const idCardBackInput = document.getElementById('id-card-back');
        const idCardFrontDrop = document.getElementById('id-card-front-drop');
        const idCardBackDrop = document.getElementById('id-card-back-drop');
        const frontPreviewContainer = document.getElementById('front-preview-container');
        const backPreviewContainer = document.getElementById('back-preview-container');
        const frontPreviewImage = document.getElementById('front-preview-image');
        const backPreviewImage = document.getElementById('back-preview-image');
        const removeFrontBtn = document.getElementById('remove-front');
        const removeBackBtn = document.getElementById('remove-back');
        const ocrResultDiv = document.getElementById('ocr-result');
        const verifyIdCardBtn = document.getElementById('verify-id-card-btn');
        const idCardCameraGuide = document.getElementById('id-card-camera-guide');
        const ocrFieldsIds = ['id-number-kyc', 'firstname-th', 'lastname-th', 'firstname-en', 'lastname-en', 'birthdate-kyc', 'address-kyc', 'issue-date', 'expiry-date', 'laser-id-kyc'];
        const videoElementFace = document.getElementById('webcam-face');
        const videoElementVideo = document.getElementById('webcam-video');
        const faceCaptureSection = document.getElementById('face-capture-section');
        const videoRecordingSection = document.getElementById('video-recording-section');
        const startRecordingBtn = document.getElementById('start-recording');
        const stopRecordingBtn = document.getElementById('stop-recording');
        const recordingIndicator = document.getElementById('recording-indicator');
        const recordingInstructionContainer = document.getElementById('recording-instruction-container');
        const recordingInstruction = document.getElementById('recording-instruction');
        const videoPreviewContainer = document.getElementById('video-preview-container');
        const videoPreview = document.getElementById('video-preview');
        const removeVideoBtn = document.getElementById('remove-video');
        const submitKycBtn = document.getElementById('submit-kyc-btn');
        const triggerOcrGroup = document.getElementById('trigger-ocr-group');
        const triggerOcrBtn = document.getElementById('trigger-ocr-btn');

        // --- Face Verification DOM Elements ---
        const webcamContainerFace = document.getElementById('webcam-container-face');
        const overlayFace = document.getElementById("webcam-face-overlay");
        const startFaceCaptureBtn = document.getElementById("start-face-capture");
        const retakeFaceCaptureBtn = document.getElementById("retake-face-capture");
        const instructionTextEl = document.getElementById("face-action-text");
        const countdownTextEl = document.getElementById("face-countdown-text");
        const statusTextEl = document.getElementById("face-status-text");
        const capturedFacesContainer = document.getElementById("captured-faces-container");
        const debugInfoEl = document.getElementById("debug-info");
        const faceGuideFrame = document.getElementById("face-guide-frame");
        const shutterSound = document.getElementById("shutter-sound");
        const faceStepEl = document.getElementById("step-6");
        const successStepEl = document.getElementById("success-step");

        // *** UPDATED: Audio Element Reference for the mixed KYC sound ***
        const mixedKycSound = document.getElementById("mixed-kyc-sound");

        // --- State Variables ---
        let currentStep = 1;
        const totalLogicalSteps = 6;
        let stream = null;
        let mediaRecorder;
        let recordedChunks = [];
        let pinCode = ''; // Store the actual PIN temporarily
        let currentPinIndex = 0;
        const MIN_AGE = 18;
        const MAX_AGE = 65;
        let isTransitioning = false;
        let step5VideoWatched = false;
        let step6VideoWatched = false;
        let leafletMap = null;
        let leafletMarker = null;
        let currentCoords = null;
        let ocrDataStore = {};
        let isOcrRunning = false;
        let requestToken = '';
        let otpReferenceNumber = '';
        let otpSent = false;
        let otpVerified = false;
        let countdownInterval;
        let timeLeft = 60;
        // ** Variables to store LIFF profile data **
        let liffUserId = '';
        let liffDisplayName = '';
        let liffPictureUrl = '';
      let idCardFrontFileObject = null;
      let idCardBackFileObject = null;
       let recordedVideoBlob = null;

        // --- Face Verification State Variables ---
        const DEBUG_MODE = false; // Set true for more console logs and on-screen debug info
        let faceMesh; // This variable will hold the FaceMesh instance
        let mediaPipeCamera;
        let faceActionsSource = [
            { label: "กรุณามองตรง", detector: isLookingStraight, duration: 3, captured: false, thresholdDebug: `tolX: 0.20, tolY: 0.15` },
            { label: "กรุณายิ้ม", detector: isSmiling, duration: 3, captured: false, thresholdDebug: `ratio > 4.0` },
            { label: "กรุณาอ้าปาก", detector: isMouthOpen, duration: 3, captured: false, thresholdDebug: `ratio > 0.12` },
            { label: "กรุณาหันหน้าซ้าย", detector: isTurnedLeft, duration: 3, captured: false, thresholdDebug: `yaw < -12` },
            { label: "กรุณาหันหน้าขวา", detector: isTurnedRight, duration: 3, captured: false, thresholdDebug: `yaw > 12` }
        ];
        let currentFaceActionIndex = 0;
        let faceActionStartTime = null;
        let isProcessing = false; // General processing lock for intensive tasks
        let isFaceProcessing = false; // Specific lock for faceMesh.send to prevent overlap
        let noFaceDetectedTimeout = null;
        let debugData = {};
        let capturedFaces = [];
        let audioCtx; // AudioContext for unlocking
        let currentSegmentTimeout = null; // To clear previous pause timeouts

        // *** ADDED: Segment Times based on user request ***
        const segmentTimes = [
            { start: 0, duration: 5 },  // 0: Button Click -> มองตรง instruction
            { start: 5, duration: 4 },  // 1: มองตรง complete -> ยิ้ม instruction
            { start: 9, duration: 4 },  // 2: ยิ้ม complete -> อ้าปาก instruction
            { start: 13, duration: 4 }, // 3: อ้าปาก complete -> หันซ้าย instruction
            { start: 17, duration: 4 }, // 4: หันซ้าย complete -> หันขวา instruction
            { start: 21, duration: 5 }  // 5: หันขวา complete -> Completion
        ];

        // --- Constants ---
        const ID_CARD_GUIDE_VIDEO_URL = "https://no1.email/vdo/step1.mp4";
        const FACE_VIDEO_GUIDE_URL = "https://www.w3schools.com/howto/rain.mp4"; // Example URL
        const INITIAL_DATA_API_URL = "https://mg-no1member.vercel.app/api/upsertUser"; 
        const registeredUsers = [
            { phone: "0812345678", idNumber: "1111111111111" },
            { phone: "0898765432", idNumber: "2222222222222" }
        ];
        const THAI_MONTHS_ABBR = ["", "ม.ค.", "ก.พ.", "มี.ค.", "เม.ย.", "พ.ค.", "มิ.ย.", "ก.ค.", "ส.ค.", "ก.ย.", "ต.ค.", "พ.ย.", "ธ.ค."];
        const OTP_REQUEST_URL = 'https://us-central1-no1-money.cloudfunctions.net/requestOTP';
        const OTP_VERIFY_URL = 'https://us-central1-no1-money.cloudfunctions.net/verifyOTP';
        const OCR_API_URL = 'https://no1ocr.vercel.app/';
        const OCR_FRONT_ENDPOINT = '/ocr/front';
        const OCR_BACK_ENDPOINT = '/ocr/back';


        // --- MediaPipe Initialization ---
        // This is the *correct* place to initialize the FaceMesh instance
        try {
            // Create the FaceMesh instance and store it in the faceMesh variable
            faceMesh = new FaceMesh({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}` });
            faceMesh.setOptions({
                maxNumFaces: 1,
                refineLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            faceMesh.onResults(onFaceResults); // Set the callback on the instance
            console.log("FaceMesh initialized successfully.");
            if(debugInfoEl) debugInfoEl.classList.toggle('hidden', !DEBUG_MODE);
        } catch (error) {
            console.error("FaceMesh initialization error:", error);
            showError("ข้อผิดพลาดในการโหลด", "ไม่สามารถโหลดโมเดลตรวจจับใบหน้าได้ กรุณาลองรีเฟรชหน้า");
            // Disable face capture buttons if initialization fails
            if(startFaceCaptureBtn) startFaceCaptureBtn.disabled = true;
            if(retakeFaceCaptureBtn) retakeFaceCaptureBtn.disabled = true;
        }


        // --- Initialization ---
        initializeDateSelectors();
        setupPinInput();
        updateStep3ButtonState();
        if(verifyIdCardBtn) verifyIdCardBtn.disabled = true;
        if(idCardFrontDrop) idCardFrontDrop.classList.add('disabled');
        if(idCardBackDrop) idCardBackDrop.classList.add('disabled');
        if(startFaceCaptureBtn) startFaceCaptureBtn.disabled = true; // Start disabled
        if(retakeFaceCaptureBtn) { retakeFaceCaptureBtn.disabled = true; retakeFaceCaptureBtn.classList.add('hidden'); }
        if(startRecordingBtn) startRecordingBtn.disabled = true;
        if(submitKycBtn) { submitKycBtn.classList.add('hidden'); submitKycBtn.disabled = true; }
        if(triggerOcrGroup) triggerOcrGroup.classList.add('hidden');
        if(triggerOcrBtn) triggerOcrBtn.disabled = true;


        // --- Event Listeners ---
        nextButtons.forEach(button => button.addEventListener('click', handleNextStep));
        prevButtons.forEach(button => button.addEventListener('click', handlePrevStep));
        closeAppBtn?.addEventListener('click', closeWindow);
        pdpaCheckbox?.addEventListener('change', () => { if (acceptPdpaBtn) acceptPdpaBtn.disabled = !pdpaCheckbox.checked; });
        phoneInput?.addEventListener('input', () => { validatePhoneNumberFormat(); updateStep3ButtonState(); });
        idInput?.addEventListener('input', () => { validateIdNumberFormat(); updateStep3ButtonState(); });
        birthDaySelect?.addEventListener('change', () => { validateBirthdate(); updateStep3ButtonState(); });
        birthMonthSelect?.addEventListener('change', () => { validateBirthdate(); updateStep3ButtonState(); });
        birthYearSelect?.addEventListener('change', () => { validateBirthdate(); updateStep3ButtonState(); });
        getLocationBtn?.addEventListener('click', handleGetLocation);
        currentAddressTextarea?.addEventListener('input', updateStep3ButtonState);
        resendOtpLink?.addEventListener('click', async (e) => {
             e.preventDefault();
             if (resendOtpLink.classList.contains('disabled')) return;
             resendOtpLink.classList.add('disabled');
             const phone = phoneInput.value;
             if (!validatePhoneNumberFormat()) {
                  // NOTE: This validation error is NOT related to OTP success/failure, so it remains.
                  showError('เบอร์โทรไม่ถูกต้อง', 'กรุณากลับไปแก้ไขหมายเลขโทรศัพท์');
                  resendOtpLink.classList.remove('disabled');
                  return;
              }
              await requestOTP(phone);
              // Re-enable link happens inside requestOTP's error handling or countdown end
         });
        verifyOtpBtn?.addEventListener('click', async () => {
             if (isTransitioning) return;
             // validateOTP now returns true on FULL success (OTP verify + API call)
             const isValidAndSaved = await validateOTP();
             if (isValidAndSaved) {
                 // Only proceed if BOTH OTP verification AND the initial data save succeeded
                 setTimeout(() => { goToStep(5, 'next'); }, 800); // Delay allows user to see success state briefly
             }
         });
        otpInputs.forEach((input, index) => { input.addEventListener('input', async (e) => { let value = e.target.value.replace(/\D/g, ''); e.target.value = value; input.classList.remove('error'); if (value && index < otpInputs.length - 1) { otpInputs[index + 1].focus(); } input.classList.toggle('filled', !!value); const filledCount = [...otpInputs].filter(x => x.value).length; if(verifyOtpBtn) verifyOtpBtn.disabled = filledCount !== 6 || otpVerified; if (filledCount === 6 && !otpVerified && !isTransitioning) { const isValidAndSaved = await validateOTP(); if (isValidAndSaved) { setTimeout(() => { goToStep(5, 'next'); }, 800); } } }); input.addEventListener('keydown', (e) => { input.classList.remove('error'); if (e.key === 'Backspace') { if (!e.target.value && index > 0) { otpInputs[index - 1].focus(); otpInputs[index - 1].value = ''; otpInputs[index - 1].classList.remove('filled', 'success'); } else { e.target.value = ''; e.target.classList.remove('filled', 'success'); } const filledCount = [...otpInputs].filter(x => x.value).length; if(verifyOtpBtn) verifyOtpBtn.disabled = filledCount !== 6 || otpVerified; } else if (e.key === 'ArrowLeft' && index > 0) { e.preventDefault(); otpInputs[index - 1].focus(); } else if (e.key === 'ArrowRight' && index < otpInputs.length - 1) { e.preventDefault(); otpInputs[index + 1].focus(); } else if (e.key.length === 1 && /\D/.test(e.key) && !e.ctrlKey && !e.metaKey) { e.preventDefault(); } }); input.addEventListener('paste', handleOtpPaste); input.addEventListener('focus', () => input.select()); });
        // *** เพิ่มพารามิเตอร์ตัวสุดท้าย (isFront) ***
setupFileUpload('id-card-front', 'id-card-front-drop', 'front-preview-container', 'front-preview-image', 'remove-front', true); // true สำหรับด้านหน้า
setupFileUpload('id-card-back', 'id-card-back-drop', 'back-preview-container', 'back-preview-image', 'remove-back', false); // false สำหรับด้านหลัง
        triggerOcrBtn?.addEventListener('click', () => { if (!triggerOcrBtn.disabled && !isOcrRunning) { processRealOCR(); } });
        ocrFieldsIds.forEach(id => { const input = document.getElementById(id); if (input && (input.tagName === 'INPUT' || input.tagName === 'TEXTAREA')) { input.addEventListener('input', () => { if (!input.readOnly) { input.style.borderColor = '#ccc'; updateStep5ButtonState(); } }); } });

        // --- Face Verification Listeners (Sound playback added) ---
        startFaceCaptureBtn?.addEventListener('click', async () => {
            console.log("Start Face Capture button clicked.");
            if (startFaceCaptureBtn.disabled) {
                console.warn("Start button is disabled, likely stream not ready or video not watched.");
                if (!step6VideoWatched) {
                     showFaceVideoGuide();
                } else {
                     if (!stream || !stream.active) {
                          console.log("Attempting to re-initialize stream on disabled button click.");
                          await initWebcamStreamOnly();
                          if (stream && stream.active) {
                               startFaceCaptureBtn.disabled = false; // Enable if successful
                               console.log("Stream initialized, button enabled. Please click again.");
                               showSuccess("กล้องพร้อมแล้ว", "กรุณากดปุ่ม 'เริ่มบันทึกภาพใบหน้า' อีกครั้ง");
                          }
                     }
                }
                return;
            }
            unlockAudioContext(); // Attempt unlock first
            // *** Play the FIRST audio segment (index 0) ***
            playSegment(segmentTimes[0].start, segmentTimes[0].duration);
            startFaceCaptureProcess(); // Start the visual process
        });

        retakeFaceCaptureBtn?.addEventListener('click', async () => {
             console.log("Retake Face Capture button clicked.");
             if (retakeFaceCaptureBtn.disabled) return;
             unlockAudioContext(); // Attempt unlock first
             // *** Play the FIRST audio segment (index 0) on retake ***
             playSegment(segmentTimes[0].start, segmentTimes[0].duration);
             retakeFaceCapture(); // Start the visual retake process
        });

        // Video Recording Listeners
        startRecordingBtn?.addEventListener('click', showRecordingInstructionAlert);
        stopRecordingBtn?.addEventListener('click', stopRecording);
        removeVideoBtn?.addEventListener('click', removeVideo);
        // Submission Listener
        submitKycBtn?.addEventListener('click', handleSubmitKyc);
        // Cleanup Listener
        window.addEventListener('beforeunload', cleanupResources);
// <<< *** START REPLACEMENT for sendOcrDataAndImages *** >>>
async function sendOcrAndIdFilesStep5() {
    console.log("Attempting to send OCR data AND ID card files in Step 5...");

    // 1. Check for essential LIFF User ID
    if (!liffUserId) {
        showError("ข้อผิดพลาด", "ไม่พบข้อมูลผู้ใช้ LINE กรุณาลองรีเฟรช");
        return false;
    }
    // 2. Check if OCR section is visible and files seem ready (basic check)
    if (!ocrResultDiv || ocrResultDiv.classList.contains('hidden')) {
        showError("ข้อผิดพลาด", "ไม่พบข้อมูลที่อ่านจากบัตร กรุณากด 'อ่านข้อมูลบัตร' ก่อน");
        return false;
    }
    if (!idCardFrontFileObject || !idCardBackFileObject) {
         showError('รูปภาพไม่ครบ', 'ไม่พบไฟล์รูปบัตรประชาชนด้านหน้าหรือด้านหลัง กรุณาอัปโหลดใหม่อีกครั้ง');
         return false;
    }

    // 3. Create FormData
    const formData = new FormData();
    const userIdSuffix = liffUserId || 'unknownUser';

    // 4. Append LIFF User ID and potentially other essential fields
    formData.append('line_user_id', liffUserId);
    if (liffDisplayName) formData.append('line_display_name', liffDisplayName);
    if (liffPictureUrl) formData.append('line_profile_url', liffPictureUrl);
    // Add other fields from *previous* steps if your API needs them NOW
    if (phoneInput?.value) formData.append('phone', phoneInput.value); // Example
    if (pinCode) formData.append('pin', pinCode); // Example (Consider security)

    // 5. Append OCR Text Fields (using current values)
    const ocrMap = { /* ... (same ocrMap as in handleSubmitKyc) ... */
        'id-number-kyc': 'ocr_cardNumber',
        'firstname-th': 'ocr_firstnameTH',
        'lastname-th': 'ocr_lastnameTH',
        'firstname-en': 'ocr_firstnameEN',
        'lastname-en': 'ocr_lastnameEN',
        'birthdate-kyc': 'ocr_birthDateRaw',
        'address-kyc': 'ocr_address',
        'issue-date': 'ocr_issueDate',
        'expiry-date': 'ocr_expiryDate',
        'laser-id-kyc': 'ocr_laserId'
    };
    ocrFieldsIds.forEach(id => {
        const el = document.getElementById(id);
        const backendKey = ocrMap[id];
        if (el?.value && backendKey) {
            formData.append(backendKey, el.value);
            console.log(`Appended OCR field: ${backendKey} = ${el.value}`);
        }
    });
    // Append parsed date parts if available and needed
     const bdKyc = document.getElementById('birth-day-kyc'), bmKyc = document.getElementById('birth-month-kyc'), byKyc = document.getElementById('birth-year-kyc');
     if (bdKyc?.value) formData.append('ocr_birthDay_parsed', bdKyc.value);
     if (bmKyc?.value) formData.append('ocr_birthMonth_parsed', bmKyc.value);
     if (byKyc?.value) formData.append('ocr_birthYear_parsed', byKyc.value);

    // 6. Append ID Card File Objects
    try {
        const frontFileName = `id_front_${userIdSuffix}_${Date.now()}.${idCardFrontFileObject.name.split('.').pop() || 'jpg'}`;
        formData.append('id_card_front', idCardFrontFileObject, frontFileName);
        console.log(`Appended id_card_front: ${frontFileName} (Size: ${idCardFrontFileObject.size})`);

        const backFileName = `id_back_${userIdSuffix}_${Date.now()}.${idCardBackFileObject.name.split('.').pop() || 'jpg'}`;
        formData.append('id_card_back', idCardBackFileObject, backFileName);
        console.log(`Appended id_card_back: ${backFileName} (Size: ${idCardBackFileObject.size})`);
    } catch (fileError) {
        console.error("Error appending file objects:", fileError);
        showError('เกิดข้อผิดพลาด', 'ไม่สามารถเตรียมไฟล์รูปภาพบัตรเพื่อส่งได้');
        return false;
    }


    // 7. Log FormData content (for debugging, Blobs/Files won't show content)
    console.log("--- FormData to be sent (Step 5) ---");
    for (let pair of formData.entries()) {
        if (pair[1] instanceof File || pair[1] instanceof Blob) {
            console.log(`${pair[0]}: [File/Blob] Name: ${pair[1].name || 'N/A'}, Size: ${pair[1].size}, Type: ${pair[1].type}`);
        } else {
            console.log(`${pair[0]}: ${pair[1]}`);
        }
    }
    console.log("--- End FormData ---");


    // 8. Update UI for Loading State
    if (verifyIdCardBtn) {
        verifyIdCardBtn.disabled = true;
        verifyIdCardBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> กำลังส่งข้อมูลและรูปบัตร...';
    }

    // 9. Send FormData to the Upsert API
    try {
        const response = await fetch(INITIAL_DATA_API_URL, { // Use the same API endpoint
            method: 'POST',
            // <<<===== *** NO 'Content-Type' header *** =====>>>
            // The browser sets it automatically for FormData
            body: formData,
        });

        const result = await response.json(); // Attempt to parse response JSON

        if (!response.ok) {
            const errorMsg = result.message || result.error || `API Error: ${response.status}`;
            console.error('API Error Saving OCR/ID Data & Files (Step 5):', result);
            throw new Error(errorMsg);
        }

        // --- Success ---
        console.log("OCR/ID data and files sent successfully (Step 5):", result);
        showSuccess('บันทึกข้อมูลบัตรสำเร็จ', 'ข้อมูลและรูปภาพบัตรประชาชนถูกส่งไปบันทึกเรียบร้อย');
        if (verifyIdCardBtn) {
            verifyIdCardBtn.innerHTML = '<i class="fas fa-check"></i> บันทึกข้อมูลบัตรแล้ว';
            // Keep it disabled or enable based on your flow. Let's keep it disabled here.
            // verifyIdCardBtn.disabled = true;
        }
        return true; // Signal success to handleNextStep

    } catch (error) {
        // --- Failure ---
        console.error("Error sending OCR/ID data and files (Step 5) to API:", error);
        showError('บันทึกข้อมูลบัตรไม่สำเร็จ', `เกิดข้อผิดพลาด: ${error.message}. กรุณาลองกดปุ่มยืนยันอีกครั้ง`);
        // Re-enable button to allow retry
        if (verifyIdCardBtn) {
            verifyIdCardBtn.disabled = false; // Re-enable on failure
            verifyIdCardBtn.innerHTML = 'ยืนยันข้อมูลบัตร <i class="fas fa-check"></i>';
        }
        return false; // Signal failure to handleNextStep
    }
}

  async function handleNextStep(event) {
      if (isTransitioning) return;
      const button = event.target.closest('button');
      if (!button || button.disabled) return;

      const nextLogicalStep = parseInt(button.getAttribute('data-next'));
      let canProceed = false;

      console.log(`handleNextStep called for step ${currentStep}, attempting to go to ${nextLogicalStep}`);

      switch (currentStep) {
          case 1:
              canProceed = validateStep1();
              break;
          case 2:
              canProceed = validateStep2();
              break;
          case 3:
              // ... (Case 3 - Send OTP - remains the same) ...
              canProceed = validateStep3(true);
              if (canProceed) {
                  const phone = phoneInput.value;
                  button.disabled = true; button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> กำลังส่ง...';
                  requestOTP(phone).then(() => {
                      if (otpSent) { if(otpPhoneNumber) otpPhoneNumber.textContent = phone; goToStep(nextLogicalStep, 'next'); }
                      else { button.disabled = false; button.innerHTML = 'ส่ง OTP <i class="fas fa-paper-plane"></i>'; }
                  }).catch(err => { console.error("OTP req error:", err); button.disabled = false; button.innerHTML = 'ส่ง OTP <i class="fas fa-paper-plane"></i>'; });
                  return; // Important: Prevent default navigation below
              }
              break; // Added break
          case 4:
              // OTP verification handles its own progression
              console.warn("Generic 'next-step' on Step 4. Use 'Verify OTP'.");
              return; // Important: Prevent default navigation below

          // --- *** START REVISED CASE 5 *** ---
          case 5:
              // This button is 'verify-id-card-btn'
              if (button.id !== 'verify-id-card-btn') {
                  console.warn("Unexpected button triggered next step from Step 5.");
                  return;
              }

              // 1. Validate Step 5 data (including OCR fields being filled)
              canProceed = validateStep5(true); // Show errors if validation fails

              if (canProceed) {
                  // 2. If valid, attempt to send OCR data and images to the API
                  console.log("Step 5 validated. Attempting to send OCR data and images...");
                   const dataSentSuccessfully = await sendOcrAndIdFilesStep5();

                  if (dataSentSuccessfully) {
                      // 3. If API call is successful, prepare for and go to Step 6
                      console.log("API call successful. Preparing and moving to Step 6.");
                      handleVerifyIdCard(nextLogicalStep); // Prepare recording instructions
                      goToStep(nextLogicalStep, 'next');   // Navigate
                  } else {
                      // 4. If API call fails, stay on Step 5 (error message shown by sending function)
                      console.log("API call failed. Staying on Step 5.");
                      // The sendOcrDataAndImages function should handle re-enabling the button
                  }
              } else {
                   // Validation failed, stay on Step 5 (error shown by validateStep5)
                   console.log("Step 5 validation failed.");
              }
              return; // Important: Stop further execution in handleNextStep for case 5
          // --- *** END REVISED CASE 5 *** ---

          case 6:
              console.warn("Generic 'next-step' on Step 6. Use 'Submit KYC'.");
              return; // Important: Prevent default navigation below
          default:
              console.log(`Default case for currentStep ${currentStep}`);
              canProceed = true;
              break;
      }

      // Default navigation for other steps (e.g., Step 1 -> 2, Step 2 -> 3)
      // Condition updated to exclude steps that handle their own navigation or return early
      if (canProceed && ![3, 4, 5, 6].includes(currentStep)) {
          console.log(`Default navigation proceeding from step ${currentStep} to ${nextLogicalStep}`);
          goToStep(nextLogicalStep, 'next');
      } else if (!canProceed) {
          console.log(`Navigation stopped at step ${currentStep}.`);
      }
  }    
      

        function handlePrevStep(event) {
            if (isTransitioning) return;
            const button = event.target.closest('button');
            if (!button || button.disabled) return;
            const prevLogicalStep = parseInt(button.getAttribute('data-prev'));
            if (prevLogicalStep >= 1) {
                 // *** Stop sound if going back from step 6 ***
                 if (currentStep === 6) {
                      if (mixedKycSound && !mixedKycSound.paused) {
                           mixedKycSound.pause();
                           console.log("Paused KYC sound on step 6 back navigation.");
                      }
                      if (currentSegmentTimeout) {
                           clearTimeout(currentSegmentTimeout);
                           currentSegmentTimeout = null;
                      }
                 }
                // Cleanup specific to the step we are LEAVING
                if (currentStep === 4) {
                    otpSent = false; otpVerified = false; requestToken = ''; otpReferenceNumber = '';
                    clearInterval(countdownInterval);
                    clearOtpInputs();
                    if(resendOtpLink) resendOtpLink.classList.add('disabled');
                    if(countdownElement) countdownElement.textContent = '60s';
                    if (otpReference) otpReference.style.display = 'none';
                    // Note: We don't reset the API submission status here.
                    // If the user goes back and forth, the API call might happen again if OTP is re-verified.
                }
                if (currentStep === 5) {
                    step5VideoWatched = false; // Require re-watch if going back
                    resetOcrFields(true); // Clear OCR results
                    if(triggerOcrGroup) triggerOcrGroup.classList.add('hidden');
                    if(triggerOcrBtn) triggerOcrBtn.disabled = true;
                    // Reset file previews and inputs as well
                    resetPreview(frontPreviewImage, frontPreviewContainer, idCardFrontDrop);
                    resetPreview(backPreviewImage, backPreviewContainer, idCardBackDrop);
                    if(idCardFrontInput) idCardFrontInput.value = '';
                    if(idCardBackInput) idCardBackInput.value = '';
                    if(idCardFrontDrop) idCardFrontDrop.classList.add('disabled');
                    if(idCardBackDrop) idCardBackDrop.classList.add('disabled');
                    if(verifyIdCardBtn) verifyIdCardBtn.disabled = true;
                }
                if (currentStep === 6) {
                    step6VideoWatched = false; // Require re-watch if going back
                    cleanupResources(); // Stop cameras, etc.
                    resetStep6UI(); // Reset the entire UI for step 6
                }
                goToStep(prevLogicalStep, 'prev');
            }
        }

        function goToStep(stepNumber, direction = 'next') {
            if (stepNumber < 1 || stepNumber > totalLogicalSteps + 1 || isTransitioning) {
                console.warn(`goToStep blocked: stepNumber=${stepNumber}, isTransitioning=${isTransitioning}`);
                return;
            }
            console.log(`Transitioning from step ${currentStep} to ${stepNumber} (${direction})`);
            isTransitioning = true;
            const currentStepElement = document.getElementById(`step-${currentStep}`) || document.getElementById('success-step');
            const targetStepId = stepNumber <= totalLogicalSteps ? `step-${stepNumber}` : 'success-step';
            const targetStepElement = document.getElementById(targetStepId);

            if (!currentStepElement || !targetStepElement) {
                console.error(`Error finding step elements: current=step-${currentStep}, target=${targetStepId}`);
                isTransitioning = false;
                return;
            }

            const outAnimation = direction === 'next' ? 'slide-out-left' : 'slide-out-right';
            const inAnimation = direction === 'next' ? 'slide-in-right' : 'slide-in-left';

            currentStepElement.classList.add(outAnimation);

            // Use animationend for smoother transitions
            currentStepElement.addEventListener('animationend', function handler() {
                this.removeEventListener('animationend', handler); // Clean up listener
                currentStepElement.classList.remove('active', outAnimation);

                targetStepElement.classList.remove('slide-out-left', 'slide-out-right', 'slide-in-left', 'slide-in-right'); // Clear any previous animation classes
                targetStepElement.classList.add('active', inAnimation);
                currentStep = stepNumber; // Update currentStep AFTER hiding the old one

                // --- Step Initialization Logic (runs AFTER animation starts) ---
                console.log(`Initializing step ${currentStep}`);
                if (currentStep === 3) {
                    phoneInput?.focus();
                    updateStep3ButtonState();
                    if (!leafletMap && currentCoords && mapContainer && !mapContainer.classList.contains('hidden')) {
                        initMap(currentCoords.lat, currentCoords.lon);
                    }
                } else if (currentStep === 4) {
                    otpInputs[0]?.focus();
                    if(verifyOtpBtn) verifyOtpBtn.disabled = true; // Ensure verify button is disabled initially
                    otpVerified = false; // Reset OTP verified status when entering step 4
                    clearOtpInputs(); // Clear inputs visually
                } else if (currentStep === 5) {
                    updateTriggerOcrButtonState();
                    updateStep5ButtonState();
                    if (!step5VideoWatched) {
                        showIdCardVideoGuide(); // Show guide if not watched
                    } else {
                        enableStep5Actions(); // Enable if already watched
                    }
                } else if (currentStep === 6) {
                    resetStep6UI(); // Reset UI first
                    if (!step6VideoWatched) {
                        showFaceVideoGuide(); // Show guide if not watched
                    } else {
                        enableStep6Actions(); // Prepare stream, enable start button if watched
                    }
                }

                cardBody?.scrollTo({ top: 0, behavior: 'smooth' });

                // Use animationend on the target element to unlock isTransitioning
                targetStepElement.addEventListener('animationend', function targetHandler() {
                    this.removeEventListener('animationend', targetHandler);
                    targetStepElement.classList.remove(inAnimation); // Clean up animation class
                    isTransitioning = false;
                    console.log(`Transition complete. Current step: ${currentStep}. isTransitioning: ${isTransitioning}`);
                }, { once: true });

            }, { once: true }); // Ensure the listener runs only once
        }


        function closeWindow() {
            cleanupResources(); // Ensure resources are released before closing
            console.log("Attempting to close window...");
            try {
                // LIFF specific way (Recommended when running in LIFF)
                if (typeof liff !== 'undefined' && liff.isInClient()) {
                    console.log("Closing LIFF window...");
                    liff.closeWindow();
                } else {
                    // Fallback message if not in LIFF or if close fails
                    console.log('Not in LIFF or close failed. Please close manually.');
                    showError('ปิดหน้าต่าง', 'กรุณาปิดหน้าต่างนี้ด้วยตนเอง');
                }
            } catch (e) {
                console.error("Error closing window:", e);
                alert('กรุณาปิดหน้าต่างนี้ด้วยตนเอง'); // Simple alert as a last resort
            }
        }

        function cleanupResources() {
            console.log("Cleaning up resources...");
            stopWebcamAndRecording(); // Stops stream, mediapipe, recorder

            // *** Stop mixed KYC sound if playing ***
            if (mixedKycSound && !mixedKycSound.paused) {
                 mixedKycSound.pause();
                 console.log("Paused KYC sound during cleanup.");
            }

            if (countdownInterval) clearInterval(countdownInterval);
            if (noFaceDetectedTimeout) clearTimeout(noFaceDetectedTimeout);
            if (currentSegmentTimeout) clearTimeout(currentSegmentTimeout); // Clear scheduled pause

            if (videoPreview?.src) {
                 try { URL.revokeObjectURL(videoPreview.src); console.log("Revoked video preview URL."); } catch (e) {}
            }
            // Explicitly clear MediaPipe resources if stopWebcamAndRecording didn't catch it
            if (mediaPipeCamera) { try { mediaPipeCamera.stop(); console.log("Force stop MediaPipe camera."); } catch (e) {} mediaPipeCamera = null; }
            // if (faceMesh) { try { faceMesh.close(); console.log("Closed FaceMesh."); } catch (e) { console.warn("Error closing FaceMesh:", e); } faceMesh = null; } // Be cautious closing FaceMesh if you might reuse it without full reload


            if (leafletMap) {
                try { leafletMap.remove(); console.log("Removed Leaflet map."); } catch (e) { console.warn("Error removing map:", e); }
                leafletMap = null;
                leafletMarker = null;
            }
            // Close AudioContext if it exists
            if (audioCtx && audioCtx.state !== 'closed') {
                audioCtx.close().then(() => console.log("AudioContext closed.")).catch(e => console.warn("Error closing AudioContext:", e));
                audioCtx = null;
            }
            console.log("Resource cleanup finished.");
        }

        // --- Step Specific Logic ---
        function validateStep1() {
            if (!pdpaCheckbox?.checked) {
                showError('จำเป็นต้องยอมรับ PDPA', 'กรุณายอมรับนโยบายความเป็นส่วนตัว (PDPA) ก่อนดำเนินการต่อ');
                if(pdpaCheckbox) shakeElement(pdpaCheckbox.closest('.pdpa-agreement'));
                return false;
            }
            return true;
        }
        function setupPinInput() {
            numericKeys.forEach(key => key.addEventListener('click', () => handlePinKeyPress(key.getAttribute('data-value'))));
            backspaceKey?.addEventListener('click', () => handlePinKeyPress(null, true));
            updatePinDisplay(); // Initial display setup
        }
        function handlePinKeyPress(value, isBackspace = false) {
            if (isBackspace) {
                if (currentPinIndex > 0) {
                    currentPinIndex--;
                    pinCode = pinCode.slice(0, -1);
                }
            } else if (value !== null && currentPinIndex < pinFields.length) {
                pinCode += value;
                currentPinIndex++;
            }
            updatePinDisplay();
            updateStep2ButtonState();
        }
        function updatePinDisplay() {
            pinFields.forEach((field, index) => {
                const dot = field.querySelector('.pin-input-dot');
                const isFilled = index < currentPinIndex;
                const isActive = index === currentPinIndex && currentPinIndex < pinFields.length;
                field.classList.toggle('filled', isFilled);
                field.classList.toggle('active', isActive);
                if (dot) {
                    dot.style.opacity = isFilled ? '1' : '0';
                    dot.style.transform = isFilled ? 'scale(1)' : 'scale(0.5)';
                }
            });
        }
        function updateStep2ButtonState() {
            if(confirmPinBtn) confirmPinBtn.disabled = pinCode.length !== 6;
        }
        function validateStep2() {
            if (pinCode.length !== 6) {
                showError('PIN ไม่ครบ', 'กรุณากรอก PIN Code 6 หลักให้ครบถ้วน');
                shakeElement(document.querySelector('.pin-input-container'));
                return false;
            }
            console.log("PIN Set (masked): ******"); // Avoid logging the actual PIN
            return true;
        }
        function initializeDateSelectors() {
            if (!birthDaySelect || !birthYearSelect) return;
            // Clear existing options first
            birthDaySelect.innerHTML = '<option value="" selected disabled>วัน</option>';
            birthYearSelect.innerHTML = '<option value="" selected disabled>ปี</option>';
            const currentYearBE = new Date().getFullYear() + 543;
            for (let i = 1; i <= 31; i++) {
                birthDaySelect.appendChild(new Option(i, i));
            }
            for (let i = currentYearBE - MIN_AGE; i >= currentYearBE - MAX_AGE; i--) {
                birthYearSelect.appendChild(new Option(i, i));
            }
        }
        function validatePhoneNumberFormat() {
            if (!phoneInput) return false;
            const phone = phoneInput.value;
            const isValid = /^[0][689]\d{8}$/.test(phone);
            phoneValidIcon?.classList.toggle('hidden', !isValid);
            phoneInput.style.borderColor = isValid ? 'var(--success-color)' : '#ccc';
            if (phone.length > 0 && !isValid) {
                phoneInput.style.borderColor = 'var(--danger-color)';
            }
            // Hide warning initially, let checkDuplicateData handle showing it
            if (phoneWarning) phoneWarning.style.display = 'none';
            return isValid;
        }
        function validateIdNumberFormat() {
            if (!idInput) return false;
            const idNumber = idInput.value;
            // Reset warning style first
            if (idWarning) idWarning.style.display = 'none';
            if (idWarning) idWarning.innerHTML = '<i class="fas fa-exclamation-circle"></i> รูปแบบเลขบัตรประชาชนไม่ถูกต้อง'; // Default format warning
            let isValid = false;

            if (idNumber.length === 13 && /^[0-9]+$/.test(idNumber)) {
                let sum = 0;
                for (let i = 0; i < 12; i++) {
                    sum += parseFloat(idNumber.charAt(i)) * (13 - i);
                }
                const checkDigit = (11 - (sum % 11)) % 10;
                isValid = (checkDigit === parseFloat(idNumber.charAt(12)));
            }

            idValidIcon?.classList.toggle('hidden', !isValid);
            idInput.style.borderColor = isValid ? 'var(--success-color)' : '#ccc';

            // Set danger border for invalid states
            if (idNumber.length > 0 && idNumber.length < 13) { // Incomplete
                idInput.style.borderColor = 'var(--danger-color)';
            } else if (idNumber.length === 13 && !isValid) { // Complete but invalid format
                idInput.style.borderColor = 'var(--danger-color)';
                if (idWarning) idWarning.style.display = 'flex'; // Show format warning
            }
            return isValid;
        }
        function validateBirthdate() {
            if (!birthDaySelect || !birthMonthSelect || !birthYearSelect || !birthdateWarning) return false;
            const day = birthDaySelect.value;
            const month = birthMonthSelect.value;
            const year = birthYearSelect.value;
            birthdateWarning.style.display = 'none'; // Hide warning initially

            if (!day || !month || !year) {
                 // Ensure dropdowns are styled neutrally if not selected
                 [birthDaySelect, birthMonthSelect, birthYearSelect].forEach(el => {
                     if (!el.value) el.style.borderColor = '#ccc';
                 });
                return false; // Incomplete selection
            }

            const currentYearBE = new Date().getFullYear() + 543;
            const age = currentYearBE - parseInt(year);
            let isValidAge = age >= MIN_AGE && age <= MAX_AGE;
            let isValidDate = true;

            // Check if date is valid for the selected month/year
            const yearCE = parseInt(year) - 543;
            const daysInMonth = new Date(yearCE, parseInt(month), 0).getDate();
            if (parseInt(day) > daysInMonth) {
                isValidDate = false;
                birthdateWarning.innerHTML = '<i class="fas fa-exclamation-circle"></i> วันที่ไม่ถูกต้องสำหรับเดือนนี้';
                birthdateWarning.style.display = 'flex';
            } else if (!isValidAge) {
                birthdateWarning.innerHTML = `<i class="fas fa-exclamation-circle"></i> อายุต้องอยู่ระหว่าง ${MIN_AGE}-${MAX_AGE} ปี`;
                birthdateWarning.style.display = 'flex';
            }

             // Style dropdowns based on validation result
            [birthDaySelect, birthMonthSelect, birthYearSelect].forEach(el => {
                el.style.borderColor = (isValidDate && isValidAge) ? 'var(--success-color)' : 'var(--danger-color)';
            });

            return isValidAge && isValidDate;
        }
        function validateCurrentAddress() {
            if (!currentAddressTextarea || !addressWarning) return false;
            const address = currentAddressTextarea.value.trim();
            const isValid = address.length > 0;
            addressWarning.style.display = isValid ? 'none' : 'flex';
            if (!isValid) {
                currentAddressTextarea.style.borderColor = 'var(--danger-color)';
            } else {
                // If it's readonly (from GPS), it's valid (green), otherwise neutral
                currentAddressTextarea.style.borderColor = currentAddressTextarea.readOnly ? 'var(--success-color)' : '#ccc';
            }
            return isValid;
        }
        function updateStep3ButtonState() {
            if (!sendOtpBtn) return;
            // Check individual format validations WITHOUT showing warnings yet
            const isPhoneFormatValid = phoneInput ? /^[0][689]\d{8}$/.test(phoneInput.value) : false;
            let isIdFormatValid = false;
            if (idInput && idInput.value.length === 13 && /^[0-9]+$/.test(idInput.value)) {
                let sum = 0; for (let i = 0; i < 12; i++) sum += parseFloat(idInput.value.charAt(i)) * (13 - i); const checkDigit = (11 - (sum % 11)) % 10; isIdFormatValid = (checkDigit === parseFloat(idInput.value.charAt(12)));
            }
            const isDobComplete = birthDaySelect?.value && birthMonthSelect?.value && birthYearSelect?.value;
            let isDobValid = false;
            if (isDobComplete) { const currentYearBE = new Date().getFullYear() + 543; const age = currentYearBE - parseInt(birthYearSelect.value); const yearCE = parseInt(birthYearSelect.value) - 543; const daysInMonth = new Date(yearCE, parseInt(birthMonthSelect.value), 0).getDate(); isDobValid = age >= MIN_AGE && age <= MAX_AGE && parseInt(birthDaySelect.value) <= daysInMonth; }
            const isAddressEntered = currentAddressTextarea ? currentAddressTextarea.value.trim().length > 0 : false;

            // Button is enabled only if all formats are valid AND required fields are filled
            sendOtpBtn.disabled = !(isPhoneFormatValid && isIdFormatValid && isDobValid && isAddressEntered);
        }
        function checkDuplicateData(phone, idNumber) {
            if (!phoneWarning || !idWarning) return false; // Ensure elements exist

            let phoneDuplicate = registeredUsers.some(user => user.phone === phone);
            let idDuplicate = registeredUsers.some(user => user.idNumber === idNumber);

            // Reset warnings first
            phoneWarning.style.display = 'none';
            // Only hide the ID warning if it's not showing the format error
            if (!idWarning.innerHTML.includes('รูปแบบเลขบัตร')) {
                 idWarning.style.display = 'none';
            }


            if (phoneDuplicate) {
                phoneWarning.innerHTML = '<i class="fas fa-exclamation-circle"></i> หมายเลขโทรศัพท์นี้ถูกใช้งานแล้ว';
                phoneWarning.style.display = 'flex';
                if (phoneInput) phoneInput.style.borderColor = 'var(--danger-color)';
            } else {
                // If no duplicate, rely on format validation for border color
                 if (phoneInput && validatePhoneNumberFormat()) phoneInput.style.borderColor = 'var(--success-color)';
            }

            if (idDuplicate) {
                idWarning.innerHTML = '<i class="fas fa-exclamation-circle"></i> เลขบัตรประชาชนนี้ถูกใช้งานแล้ว';
                idWarning.style.display = 'flex';
                if (idInput) idInput.style.borderColor = 'var(--danger-color)';
            } else {
                // If no duplicate, rely on format validation for border color
                if (idInput && validateIdNumberFormat()) idInput.style.borderColor = 'var(--success-color)';
            }

            return phoneDuplicate || idDuplicate;
        }
        function validateStep3(checkDuplicates = true) {
            let isFormatValid = true;
            let firstInvalidElement = null;

            // Run individual validations which will update UI borders/warnings
            if (!validatePhoneNumberFormat()) {
                isFormatValid = false;
                if (!firstInvalidElement) firstInvalidElement = phoneInput;
            }
            if (!validateIdNumberFormat()) {
                isFormatValid = false;
                if (!firstInvalidElement) firstInvalidElement = idInput;
            }
            if (!validateBirthdate()) {
                isFormatValid = false;
                if (!firstInvalidElement) firstInvalidElement = birthDaySelect;
            }
            if (!validateCurrentAddress()) {
                isFormatValid = false;
                if (!firstInvalidElement) firstInvalidElement = currentAddressTextarea;
            }

            let hasDuplicates = false;
            // Only check duplicates if format is valid and requested
            if (isFormatValid && checkDuplicates && phoneInput && idInput) {
                hasDuplicates = checkDuplicateData(phoneInput.value, idInput.value);
                if (hasDuplicates && !firstInvalidElement) {
                     // Determine which duplicate caused the issue for focus
                     if (phoneWarning && phoneWarning.style.display === 'flex') firstInvalidElement = phoneInput;
                     else if (idWarning && idWarning.style.display === 'flex') firstInvalidElement = idInput;
                }
            }

            const isValid = isFormatValid && !hasDuplicates;

            // Show generic error message if invalid and focus on first issue
            if (!isValid && checkDuplicates) { // Only show popup on final submit check
                let errorTitle = 'ข้อมูลไม่ถูกต้อง';
                let errorText = 'กรุณาตรวจสอบข้อมูลที่กรอกและแก้ไขให้ถูกต้อง';

                if (hasDuplicates) {
                    errorText = 'ข้อมูลหมายเลขโทรศัพท์ หรือ เลขบัตรประชาชน ซ้ำกับที่มีอยู่ในระบบ กรุณาตรวจสอบ';
                } else if (!validateCurrentAddress()) {
                     errorText = 'กรุณากรอกหรือค้นหาที่อยู่ปัจจุบันของคุณ';
                } else if (!isFormatValid) {
                     errorText = 'รูปแบบข้อมูลบางอย่างไม่ถูกต้อง หรือยังไม่ได้กรอกข้อมูล กรุณาตรวจสอบ';
                }
                // Ensure warnings related to format/age are visible if they caused the failure
                if (!validateIdNumberFormat() && idWarning) idWarning.style.display = 'flex';
                if (!validateBirthdate() && birthdateWarning) birthdateWarning.style.display = 'flex';
                if (!validateCurrentAddress() && addressWarning) addressWarning.style.display = 'flex';


                showError(errorTitle, errorText);
                if (firstInvalidElement) {
                    firstInvalidElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    setTimeout(() => {
                        if(firstInvalidElement.focus && typeof firstInvalidElement.focus === 'function') firstInvalidElement.focus();
                        shakeElement(firstInvalidElement.closest('.form-group') || firstInvalidElement);
                    }, 300);
                }
            }

            return isValid;
        }
        function handleGetLocation() {
            if (!navigator.geolocation) {
                showError('ไม่รองรับ Geolocation', 'เบราว์เซอร์ของคุณไม่รองรับการค้นหาตำแหน่ง');
                if (locationStatus) locationStatus.textContent = 'ไม่รองรับ Geolocation';
                return;
            }

            if (getLocationBtn) getLocationBtn.disabled = true;
            if (getLocationBtn) getLocationBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> กำลังค้นหา...';
            if (locationStatus) locationStatus.textContent = 'กำลังขออนุญาตและค้นหาตำแหน่ง...';
            // Reset address field and map while searching
            if (currentAddressTextarea) currentAddressTextarea.value = '';
            if (currentAddressTextarea) currentAddressTextarea.readOnly = true; // Make it readonly until result comes back
            if (mapContainer) mapContainer.classList.add('hidden');
            if (currentAddressTextarea) currentAddressTextarea.style.borderColor = '#ccc'; // Reset border
            if (addressWarning) addressWarning.style.display = 'none'; // Hide warning


            navigator.geolocation.getCurrentPosition(
                showPosition,
                showLocationError,
                { enableHighAccuracy: true, timeout: 15000, maximumAge: 0 } // Use high accuracy, reasonable timeout
            );
        }
        function showPosition(position) {
            currentCoords = { lat: position.coords.latitude, lon: position.coords.longitude };
            console.log(`Location found: Lat: ${currentCoords.lat}, Lon: ${currentCoords.lon}, Accuracy: ${position.coords.accuracy}m`);
            if (locationStatus) locationStatus.textContent = `พบตำแหน่งแล้ว (ความแม่นยำ: ${position.coords.accuracy.toFixed(0)} เมตร)`;
            // Now try to get the address name
            reverseGeocode(currentCoords.lat, currentCoords.lon);
        }
        function showLocationError(error) {
            // Re-enable button
            if (getLocationBtn) getLocationBtn.disabled = false;
            if (getLocationBtn) getLocationBtn.innerHTML = '<i class="fas fa-location-crosshairs"></i> ค้นหาตำแหน่งปัจจุบัน';
            // Allow manual input if location fails
            if (currentAddressTextarea) currentAddressTextarea.readOnly = false;
            if (currentAddressTextarea) currentAddressTextarea.placeholder = 'ไม่สามารถค้นหาตำแหน่งได้ กรุณากรอกที่อยู่ปัจจุบันด้วยตนเอง';

            let title = 'ค้นหาตำแหน่งไม่สำเร็จ';
            let message = '';
            let advice = 'เคล็ดลับ: ลองย้ายไปใกล้หน้าต่างหรือที่โล่ง, ตรวจสอบว่าเปิด Location Services ในเครื่องแล้ว และอนุญาตให้เบราว์เซอร์ใช้งานได้ แล้วลองกดปุ่มค้นหาอีกครั้ง หรือกรอกที่อยู่ด้วยตนเอง';

            switch (error.code) {
                case error.PERMISSION_DENIED:
                    message = "คุณไม่ได้อนุญาตให้แอปนี้เข้าถึงตำแหน่ง โปรดตรวจสอบการตั้งค่า Location Services ของอุปกรณ์และเบราว์เซอร์";
                    advice = "โปรดไปที่การตั้งค่าและอนุญาตการเข้าถึงตำแหน่งสำหรับเบราว์เซอร์นี้ หรือกรอกที่อยู่ด้วยตนเอง";
                    break;
                case error.POSITION_UNAVAILABLE:
                    message = "ไม่สามารถระบุตำแหน่งปัจจุบันของคุณได้ในขณะนี้ อาจเกิดจากสัญญาณ GPS/Wi-Fi อ่อน หรือปัญหาชั่วคราว";
                    advice = 'เคล็ดลับ: ลองย้ายไปใกล้หน้าต่างหรือที่โล่ง, ตรวจสอบการเชื่อมต่ออินเทอร์เน็ต แล้วลองกดปุ่มค้นหาอีกครั้ง หรือกรอกที่อยู่ด้วยตนเอง';
                    break;
                case error.TIMEOUT:
                    message = "หมดเวลาในการค้นหาตำแหน่ง อาจใช้เวลานานเกินไปเนื่องจากสัญญาณอ่อน";
                    advice = "เคล็ดลับ: ตรวจสอบสัญญาณ GPS/Wi-Fi/Cellular และลองอีกครั้ง หรือกรอกที่อยู่ด้วยตนเอง";
                    break;
                default:
                    message = `เกิดข้อผิดพลาดที่ไม่ทราบสาเหตุในการค้นหาตำแหน่ง (รหัส: ${error.code})`;
                    advice = "เคล็ดลับ: ลองรีสตาร์ทเบราว์เซอร์ หรืออุปกรณ์ แล้วลองอีกครั้ง หรือกรอกที่อยู่ด้วยตนเอง";
                    break;
            }
            console.error("Geolocation Error:", error);
            showError(title, `${message}\n\n${advice}`);
            if (locationStatus) locationStatus.textContent = message;
            // Update button state (might be disabled if other fields are invalid)
            updateStep3ButtonState();
        }
        async function reverseGeocode(lat, lon) {
            if (!currentAddressTextarea || !locationStatus) return;
            const url = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${lat}&lon=${lon}&accept-language=th`;
            locationStatus.textContent += ' | กำลังดึงข้อมูลที่อยู่...';

            try {
                const response = await fetch(url, {
                    headers: { 'User-Agent': 'PremiumFinanceApp/1.0 (Verification Process)' } // More specific user agent
                });
                if (!response.ok) {
                    throw new Error(`Geocoding failed: ${response.status} ${response.statusText}`);
                }
                const data = await response.json();
                console.log("Nominatim Response:", data);

                if (data && data.display_name) {
                    currentAddressTextarea.value = data.display_name;
                    locationStatus.textContent = `พบตำแหน่ง: ${data.display_name.split(',')[0].trim()}`;
                    currentAddressTextarea.style.borderColor = 'var(--success-color)'; // Mark as valid
                    currentAddressTextarea.readOnly = true; // Keep it readonly after successful GPS fetch
                    initMap(lat, lon, data.display_name); // Initialize map with address
                    if (mapContainer) mapContainer.classList.remove('hidden');
                    if (mapContainer) mapContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                } else {
                    throw new Error("No address found in Nominatim response.");
                }
            } catch (error) {
                console.error("Reverse Geocoding Error:", error);
                currentAddressTextarea.value = `Lat: ${lat.toFixed(5)}, Lon: ${lon.toFixed(5)} (ไม่พบชื่อที่อยู่)`;
                currentAddressTextarea.style.borderColor = 'var(--warning-color)'; // Indicate partial success
                locationStatus.textContent = 'ดึงข้อมูลที่อยู่ไม่สำเร็จ';
                currentAddressTextarea.readOnly = false; // Allow manual input if reverse geocoding fails
                currentAddressTextarea.placeholder = 'ไม่สามารถดึงชื่อที่อยู่ได้ กรุณากรอกหรือแก้ไขด้วยตนเอง';
                showError('ดึงที่อยู่ไม่สำเร็จ', 'ไม่สามารถแปลงพิกัดเป็นชื่อที่อยู่ได้: ' + error.message + '. กรุณากรอกด้วยตนเอง');
            } finally {
                // Re-enable button regardless of success/failure of geocoding
                if (getLocationBtn) getLocationBtn.disabled = false;
                if (getLocationBtn) getLocationBtn.innerHTML = '<i class="fas fa-location-crosshairs"></i> ค้นหาตำแหน่งปัจจุบัน';
                // Update overall step validation state
                updateStep3ButtonState();
            }
        }
        function initMap(lat, lon, address = `ตำแหน่งปัจจุบัน`) {
            if (typeof L === 'undefined' || !mapElement) {
                console.error("Leaflet library (L) not loaded or map element (#map) not found.");
                return;
            }
            const mapZoom = 17;
            const position = [lat, lon];

            // Clear previous map instance if it exists
            if (leafletMap) {
                 console.log("Removing previous Leaflet map instance.");
                 try { leafletMap.remove(); } catch(e){ console.warn("Error removing previous map:", e);}
                 leafletMap = null;
                 leafletMarker = null;
            }

            // Ensure map container is clean before initializing
            mapElement.innerHTML = '';

            try {
                console.log(`Initializing Leaflet map at [${lat}, ${lon}] with zoom ${mapZoom}`);
                leafletMap = L.map(mapElement).setView(position, mapZoom);

                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                    maxZoom: 19,
                }).addTo(leafletMap);

                // Create marker and popup
                const popupContent = `<p style="font-weight: bold; margin-bottom: 5px !important;">${address.split(',')[0]}</p><p style="font-size: 0.9em;">${address.substring(address.indexOf(',')+1).trim()}</p>`;
                leafletMarker = L.marker(position, { draggable: false }) // Marker should not be draggable
                    .addTo(leafletMap)
                    .bindPopup(popupContent)
                    .openPopup(); // Open popup immediately

                // Invalidate size after a short delay to ensure correct rendering
                setTimeout(() => {
                    if (leafletMap) {
                         leafletMap.invalidateSize();
                         console.log("Leaflet map size invalidated.");
                    }
                }, 200); // 200ms delay might be sufficient

            } catch (e) {
                console.error("Leaflet map initialization error:", e);
                showError("Map Error", "Could not display the map.");
                if (mapContainer) mapContainer.classList.add('hidden'); // Hide container on error
                if (leafletMap) try { leafletMap.remove(); } catch(err){} // Attempt cleanup
                leafletMap = null;
                leafletMarker = null;
            }
        }

        async function requestOTP(phone) {
            if(!sendOtpBtn) return; // Should already be disabled, but check anyway
            // UI already updated by caller (handleNextStep)

            try {
                console.log(`Requesting OTP for phone: ${phone}`);
                const formatted = '66' + phone.slice(1); // Format to E.164 for backend
                const res = await fetch(OTP_REQUEST_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ to: formatted })
                });

                const data = await res.json();
                console.log("OTP Request Response:", data);

                if (!res.ok || !data.result?.token) {
                    throw new Error(data.message || data.msg || 'ขอ OTP ไม่สำเร็จ (ไม่พบ token)');
                }

                requestToken = data.result.token;
                otpReferenceNumber = data.result.ref || '';

                // Update UI with reference number
                if(otpReferenceCode) otpReferenceCode.textContent = otpReferenceNumber || '------';
                if (otpReference) otpReference.style.display = otpReferenceNumber ? 'block' : 'none';

                otpSent = true; // Mark OTP as sent
                clearOtpInputs(); // Clear previous inputs
                startOtpCountdown(); // Start the timer
                // REMOVED SweetAlert for OTP Success
                console.log(`OTP requested successfully. Token: ${requestToken}, Ref: ${otpReferenceNumber}`);

            } catch (err) {
                console.error('Error requesting OTP:', err);
                // REMOVED SweetAlert for OTP Error
                otpSent = false; // Mark as failed
                console.log("OTP request failed, user might need to retry or use resend link when available.");
            }
            // NOTE: No finally block needed here for button re-enabling, as handleNextStep manages its button,
            // and the resend link is handled by countdown timer logic.
        }

        async function validateOTP() {
            const pin = [...otpInputs].map(i => i.value).join('');
            if (pin.length !== 6 || !verifyOtpBtn) return false; // Basic check

            // Disable button immediately
            verifyOtpBtn.disabled = true;
            verifyOtpBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> กำลังตรวจสอบ...';

            try {
                console.log(`Verifying OTP: ${pin} with token: ${requestToken}`);
                const res = await fetch(OTP_VERIFY_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ pin, token: requestToken })
                });
                const data = await res.json();
                console.log("OTP Verify Response:", data);

                // Check for success based on backend response structure
                if (!res.ok || !(data.result?.status === 'success' || data.msg?.toLowerCase().includes('success'))) {
                     throw new Error(data.message || data.msg || 'ยืนยัน OTP ไม่สำเร็จ หรือรหัสไม่ถูกต้อง');
                }

                // --- OTP Success Case ---
                otpVerified = true;
                clearInterval(countdownInterval); // Stop timer
                if(resendOtpLink) resendOtpLink.classList.add('disabled'); // Keep resend disabled

                // Style inputs as success and disable them
                otpInputs.forEach(input => {
                    input.classList.remove('error');
                    input.classList.add('success');
                    input.disabled = true;
                });
                verifyOtpBtn.innerHTML = '<i class="fas fa-check"></i> OTP ถูกต้อง'; // Indicate OTP success
                console.log("OTP Verification successful.");

                // --- NOW, SEND INITIAL DATA TO YOUR API ---
                verifyOtpBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> กำลังบันทึก...'; // Update button for save state
                const dataSaved = await sendInitialData();

                if (dataSaved) {
                    console.log("Initial data saved successfully.");
                    verifyOtpBtn.innerHTML = '<i class="fas fa-check"></i> บันทึกสำเร็จ'; // Final success state
                    return true; // Indicate overall success (OTP + API)
                } else {
                    // Error handled within sendInitialData, message already shown.
                    // Reset OTP state to allow retry
                    otpVerified = false;
                    clearOtpInputs();
                    otpInputs.forEach(input => input.classList.remove('success'));
                    if (timeLeft <= 0) { // Re-enable resend if timer was already finished
                         if(resendOtpLink) resendOtpLink.classList.remove('disabled');
                    } else { // Otherwise, restart countdown slightly
                        startOtpCountdown();
                    }
                    return false; // Indicate failure (API save failed)
                }

            } catch (err) {
                 // --- OTP Failure Case ---
                console.error('OTP Verification failed:', err);
                otpVerified = false;
                // REMOVED SweetAlert for OTP Verification Error
                clearOtpInputs(); // Clear inputs for re-entry
                otpInputs.forEach(input => input.classList.add('error')); // Add error style
                shakeElement(document.querySelector('.otp-container'));
                if(otpInputs.length > 0) otpInputs[0]?.focus(); // Focus first input
                return false; // Indicate failure
            } finally {
                // Re-enable button ONLY if verification or API save failed
                if (!otpVerified) {
                    verifyOtpBtn.disabled = false; // Re-enable for another try
                    verifyOtpBtn.innerHTML = '<i class="fas fa-check"></i> ยืนยัน OTP';
                }
            }
        }

          
        async function sendInitialData() {
            const day = birthDaySelect.value;
            const month = birthMonthSelect.value.padStart(2, '0'); // Ensure 2 digits for month
            const year = birthYearSelect.value;
            const birthDateBE = (day && month && year) ? `${day}/${month}/${year}` : '';

            const dataToSend = {
                pdpa_accepted: pdpaCheckbox?.checked || false,
                marketing_consent: marketingCheckbox?.checked || false,
                pin: pinCode, 
                phone: phoneInput?.value || '',
                id_number: idInput?.value || '',
                birthdate_be: birthDateBE, // Sending as DD/MM/YYYY (BE)
                current_address: currentAddressTextarea?.value || '',
                line_user_id: liffUserId, // Use stored LIFF data
                line_display_name: liffDisplayName, // Use stored LIFF data
                line_profile_url: liffPictureUrl, // Use stored LIFF data
                // --- ADDED LATITUDE AND LONGITUDE ---
                latitude: currentCoords?.lat || null, // Add latitude, use null if not available
                longitude: currentCoords?.lon || null // Add longitude, use null if not available
                
            };

            console.log("Sending initial data to API:", JSON.stringify(dataToSend, (key, value) => key === 'pin' ? '******' : value)); // Mask PIN in log

            try {
                const response = await fetch(INITIAL_DATA_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        // Add any other headers if required by your API (e.g., Authorization)
                    },
                    body: JSON.stringify(dataToSend)
                });

                if (!response.ok) {
                    // Try to get error details from response body
                    let errorMsg = `HTTP error ${response.status}`;
                    try {
                        const errorData = await response.json();
                        errorMsg = errorData.message || errorData.error || errorMsg;
                    } catch (e) {
                        // Ignore if response body is not JSON
                    }
                    throw new Error(`API Error: ${errorMsg}`);
                }

                // Optionally process the response data if needed
                const responseData = await response.json();
                console.log("API Response:", responseData);

                return true; // Indicate success

            } catch (error) {
                console.error("Error sending initial data to API:", error);
                showError('บันทึกข้อมูลไม่สำเร็จ', `เกิดข้อผิดพลาดในการบันทึกข้อมูลเริ่มต้น: ${error.message}. กรุณาลองยืนยัน OTP ใหม่อีกครั้ง`);
                return false; // Indicate failure
            }
        }


        function startOtpCountdown() {
            timeLeft = 60; // Reset timer
            if(resendOtpLink) resendOtpLink.classList.add('disabled'); // Disable resend link
            if(countdownElement) countdownElement.textContent = `${timeLeft}s`;
            clearInterval(countdownInterval); // Clear any existing timer

            countdownInterval = setInterval(() => {
                timeLeft--;
                if (timeLeft <= 0) {
                    clearInterval(countdownInterval);
                    if(resendOtpLink) resendOtpLink.classList.remove('disabled'); // Enable resend link
                    if(countdownElement) countdownElement.textContent = 'ส่งใหม่';
                } else {
                    if(countdownElement) countdownElement.textContent = `${timeLeft}s`;
                }
            }, 1000);
        }
        function clearOtpInputs() {
            otpInputs.forEach(i => {
                i.value = '';
                i.classList.remove('filled', 'error', 'success');
                i.disabled = false; // Ensure inputs are enabled
            });
            if (otpInputs.length > 0) otpInputs[0]?.focus(); // Focus the first input
            if(verifyOtpBtn) verifyOtpBtn.disabled = true; // Disable verify button until 6 digits are entered
        }
        function handleOtpPaste(e) {
            if (!otpInputs || otpInputs.length === 0) return;
            e.preventDefault();
            const pasteData = (e.clipboardData || window.clipboardData).getData('text').replace(/\D/g, ''); // Get digits only
            if (!pasteData) return;

            // Determine starting index for pasting
            let currentFocusIndex = Array.from(otpInputs).findIndex(el => el === document.activeElement);
            if (currentFocusIndex === -1 && otpInputs[0]) {
                otpInputs[0].focus(); // If no input is focused, start from the first one
                currentFocusIndex = 0;
            } else if (currentFocusIndex === -1) {
                return; // Should not happen if inputs exist
            }

            // Clear existing errors/success styles
            otpInputs.forEach(input => input.classList.remove('error', 'success'));

            // Distribute pasted digits
            let pasteIndex = 0;
            for (let i = currentFocusIndex; i < otpInputs.length && pasteIndex < pasteData.length; i++) {
                otpInputs[i].value = pasteData[pasteIndex];
                otpInputs[i].classList.add('filled');
                pasteIndex++;
                // Move focus to the next input if not the last one
                if (i < otpInputs.length - 1) {
                     otpInputs[i + 1].focus();
                } else {
                     otpInputs[otpInputs.length - 1].blur(); // Optionally blur the last input after pasting
                }
            }

            updateStep4ButtonState(); // Check if verify button should be enabled

            // Automatically trigger verification if 6 digits are now filled and button is enabled
            const filledCount = [...otpInputs].filter(x => x.value).length;
            if (filledCount === 6 && verifyOtpBtn && !verifyOtpBtn.disabled && !isTransitioning) {
                validateOTP().then(isValidAndSaved => {
                    if (isValidAndSaved) {
                        setTimeout(() => { goToStep(5, 'next'); }, 800); // Transition on success
                    }
                });
            }
        }
        function updateStep4ButtonState() {
            if (!verifyOtpBtn) return;
            const filledCount = [...otpInputs].filter(x => x.value).length;
            // Enable only if 6 digits are filled AND OTP hasn't been successfully verified yet
            verifyOtpBtn.disabled = filledCount !== 6 || otpVerified;
        }
        async function callOcrApi(apiUrlBase, endpointPath, base64Data) {
            // Basic validation
            if (!apiUrlBase || !endpointPath || !base64Data || !base64Data.startsWith('data:image')) {
                console.error("callOcrApi: Invalid arguments provided.");
                throw new Error("Invalid arguments: apiUrlBase, endpointPath, or base64Data.");
            }
            if (!endpointPath.startsWith('/')) {
                console.error("callOcrApi: endpointPath must start with '/'");
                throw new Error("endpointPath must start with a '/' character.");
            }

            // Construct full URL safely
            const fullApiUrl = apiUrlBase.endsWith('/') ? apiUrlBase.slice(0, -1) + endpointPath : apiUrlBase + endpointPath;
            console.log(`Calling OCR API: ${fullApiUrl}`);

            try {
                const response = await fetch(fullApiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ base64: base64Data })
                });

                let responseData;
                const responseText = await response.text(); // Get text first to handle potential JSON errors

                try {
                    responseData = JSON.parse(responseText);
                } catch (jsonError) {
                     // Handle non-JSON responses or errors during parsing
                     console.error(`OCR API (${endpointPath}) response is not valid JSON. Status: ${response.status}. Body:`, responseText);
                    if (!response.ok) {
                         // Try to extract a meaningful error from the text if possible, otherwise use status
                         const extractedError = responseText.substring(0, 100); // Limit length
                        throw new Error(`API Error: ${response.status} ${response.statusText}. Response: ${extractedError}...`);
                    } else {
                         // Successful status but invalid JSON body
                        throw new Error("Received successful but non-JSON response from OCR API.");
                    }
                }

                // Handle JSON responses with error status codes
                if (!response.ok) {
                    const errorMessage = responseData?.error || responseData?.message || responseData?.msg || `API Error ${response.status}: ${response.statusText}`;
                    console.error(`OCR API (${endpointPath}) failed with status ${response.status}. Error: ${errorMessage}`, responseData);
                    throw new Error(errorMessage);
                }

                // Handle successful JSON responses (check for expected data structure)
                if (responseData && typeof responseData.result !== 'undefined') {
                     console.log(`OCR API (${endpointPath}) success. Result:`, responseData.result);
                    return responseData.result;
                } else {
                    console.warn(`OCR API (${endpointPath}) response successful but missing 'result' key:`, responseData);
                    return null;
                }

            } catch (error) {
                // Catch fetch errors (network issues) or errors thrown above
                console.error(`Error calling OCR API (${endpointPath}):`, error);
                throw error;
            }
        }
        async function processRealOCR() {
            if (isOcrRunning) {
                console.log("OCR process is already running.");
                return false;
            }
            const frontBase64 = frontPreviewImage?.src;
            const backBase64 = backPreviewImage?.src;

            if (!frontBase64 || !backBase64 || !frontBase64.startsWith('data:image') || !backBase64.startsWith('data:image')) {
                console.warn("OCR processRealOCR: Preview image sources missing or invalid.");
                showError('ข้อมูลไม่ครบ', 'ไม่พบรูปภาพตัวอย่างของบัตรประชาชน กรุณาอัปโหลดใหม่อีกครั้ง');
                return false;
            }

            isOcrRunning = true;
            if (triggerOcrBtn) {
                triggerOcrBtn.disabled = true;
                triggerOcrBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> กำลังอ่าน...';
            }
            ocrDataStore = {}; // Reset stored data
            resetOcrFields(false); // Clear form fields but keep section visible if already shown

            console.log("Starting OCR process...");

            let frontSuccess = false;
            let backSuccess = false;

            try {
                console.log("Calling Front OCR API...");
                const frontResult = await callOcrApi(OCR_API_URL, OCR_FRONT_ENDPOINT, frontBase64);
                if (frontResult) {
                     ocrDataStore.front = frontResult;
                     console.log("Front OCR Success:", frontResult);
                     frontSuccess = true;
                } else {
                     console.warn("Front OCR API returned null/undefined result.");
                     throw new Error("ไม่พบข้อมูลจากการสแกนบัตรด้านหน้า");
                }


                console.log("Calling Back OCR API...");
                try {
                    const backResult = await callOcrApi(OCR_API_URL, OCR_BACK_ENDPOINT, backBase64);
                    ocrDataStore.back = backResult;
                    console.log("Back OCR Result (might be null):", backResult);
                    backSuccess = true;
                } catch (backError) {
                    console.warn("Back OCR API call failed, proceeding with front data only:", backError.message);
                    ocrDataStore.back = null;
                     backSuccess = false;
                }

                populateOcrFields(ocrDataStore.front, ocrDataStore.back);


            } catch (error) {
                console.error("OCR API Error during process:", error);
                showError('สแกนข้อมูลไม่สำเร็จ', `เกิดข้อผิดพลาด: ${error.message}. กรุณาถ่ายภาพใหม่อีกครั้งให้ชัดเจน`);
                frontSuccess = false;
            } finally {
                isOcrRunning = false;
                const overallSuccess = frontSuccess;

                if (triggerOcrBtn) {
                    triggerOcrBtn.disabled = overallSuccess;
                    triggerOcrBtn.innerHTML = '<i class="fas fa-sync-alt"></i> อ่านข้อมูลบัตร';
                }

                if(ocrResultDiv) ocrResultDiv.classList.toggle('hidden', !overallSuccess);

                if (overallSuccess) {
                    ocrResultDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    showSuccess('สแกนข้อมูลสำเร็จ', 'กรุณาตรวจสอบความถูกต้องของข้อมูล และแก้ไขหากจำเป็น');
                    ['firstname-th', 'lastname-th', 'firstname-en', 'lastname-en', 'address-kyc'].forEach(id => {
                        const el = document.getElementById(id);
                        if (el) el.readOnly = false;
                    });
                } else {
                    resetOcrFields(true);
                }
                updateStep5ButtonState();
            }
            return frontSuccess;
        }
        function populateOcrFields(frontData, backData) {
            console.log("Populating OCR fields. Front:", frontData, "Back:", backData);
            if (!frontData) {
                console.warn("Cannot populate fields, frontData is missing.");
                 resetOcrFields(false);
                return;
            }

            const setVal = (id, value) => {
                const el = document.getElementById(id);
                if (el) {
                     el.value = value || '';
                     el.style.borderColor = '#ccc';
                } else {
                     console.warn(`Element with ID ${id} not found for OCR population.`);
                }
            };

            const setReadOnly = (id, isReadOnly) => {
                const el = document.getElementById(id);
                if (el) el.readOnly = isReadOnly;
            };

            setVal('id-number-kyc', frontData.cardNumber);
            setVal('firstname-th', frontData.firstname);
            setVal('lastname-th', frontData.lastname);
            setVal('firstname-en', frontData.firstnameEng);
            setVal('lastname-en', frontData.lastnameEng);
            setVal('issue-date', frontData.issueDate);
            setVal('expiry-date', frontData.expiryDate);
            setVal('address-kyc', frontData.address);

            const dobBE = frontData.birthDate || '';
            setVal('birthdate-kyc', dobBE);
            setVal('birth-day-kyc', '');
            setVal('birth-month-kyc', '');
            setVal('birth-year-kyc', '');
            try {
                if (dobBE) {
                    const dobParts = dobBE.replace('.', '').split(' ');
                    if (dobParts.length >= 3) {
                        const day = parseInt(dobParts[0]);
                        const monthStr = dobParts[1];
                        const year = parseInt(dobParts[2]);
                        const monthIndex = THAI_MONTHS_ABBR.findIndex(m => monthStr.includes(m.replace('.','')));

                        if (!isNaN(day) && monthIndex > 0 && !isNaN(year)) {
                            setVal('birth-day-kyc', day);
                            setVal('birth-month-kyc', monthIndex);
                            setVal('birth-year-kyc', year);
                            console.log("Parsed DOB (D/M/Y BE):", day, monthIndex, year);
                        } else {
                            console.warn("Could not parse DOB parts from OCR:", dobParts);
                        }
                    } else {
                         console.warn("Could not split DOB from OCR into 3 parts:", dobBE);
                    }
                }
            } catch (e) {
                console.warn("Error parsing DOB from OCR:", dobBE, e);
            }

            const laserIdValue = (backData && backData.laserCode) ? backData.laserCode : '';
            setVal('laser-id-kyc', laserIdValue);

            setReadOnly('id-number-kyc', true);
            setReadOnly('birthdate-kyc', true);
            setReadOnly('issue-date', true);
            setReadOnly('expiry-date', true);
            setReadOnly('laser-id-kyc', true);

            setReadOnly('firstname-th', false);
            setReadOnly('lastname-th', false);
            setReadOnly('firstname-en', false);
            setReadOnly('lastname-en', false);
            setReadOnly('address-kyc', false);
        }
        function showIdCardVideoGuide() {
            if (typeof Swal === 'undefined') { console.error("SweetAlert not loaded."); return; }
            Swal.fire({
                title: 'แนะนำการถ่ายภาพบัตรประชาชน',
                html: `<p>กรุณาดูวิดีโอแนะนำวิธีการถ่ายภาพบัตรประชาชนให้ชัดเจนก่อนดำเนินการต่อ</p>
                       <video id="swal-video-step5" controls playsinline autoplay  width="100%" src="${ID_CARD_GUIDE_VIDEO_URL}" preload="metadata">
                           เบราว์เซอร์ของคุณไม่รองรับวิดีโอ HTML5. <a href="${ID_CARD_GUIDE_VIDEO_URL}" target="_blank">ดูวิดีโอที่นี่</a>
                       </video>
                       <p style="font-size: 0.9em; margin-top: 10px;">(ปุ่ม "ดำเนินการต่อ" จะเปิดใช้งานเมื่อดูวิดีโอจบ)</p>`,
                icon: 'info',
                allowOutsideClick: false,
                allowEscapeKey: false,
                confirmButtonText: 'กรุณาดูวิดีโอให้จบ',
                confirmButtonColor: 'var(--primary-color)',
                didOpen: () => {
                    const confirmButton = Swal.getConfirmButton();
                    const videoElement = document.getElementById('swal-video-step5');

                    if (confirmButton && videoElement) {
                        confirmButton.disabled = true;
                        videoElement.addEventListener('ended', () => {
                            confirmButton.disabled = false;
                            confirmButton.textContent = 'ดูจบแล้ว ดำเนินการต่อ';
                            console.log("Step 5 Video ended, enabling button.");
                        });
                        videoElement.addEventListener('error', (e) => {
                            console.error("Video Error (Step 5 Guide):", e);
                            showError("วิดีโอผิดพลาด", "ไม่สามารถเล่นวิดีโอแนะนำได้ กรุณาลองรีเฟรช หรือกดดำเนินการต่อ");
                            confirmButton.disabled = false;
                            confirmButton.textContent = 'ดำเนินการต่อ (วิดีโอขัดข้อง)';
                        });
                        videoElement.play().catch(error => {
                            console.warn("Autoplay prevented for Step 5 guide video:", error);
                            Swal.update({ html: Swal.getHtmlContainer().innerHTML + '<p style="color: orange; font-size: 0.9em;">กรุณากดปุ่ม Play บนวิดีโอ</p>' });
                           confirmButton.disabled = false;
                            confirmButton.textContent = 'ดูจบแล้ว ดำเนินการต่อ';
                        });
                    } else {
                        console.error("Could not find Swal confirm button or video element for Step 5.");
                        if (confirmButton) {
                            confirmButton.disabled = false;
                            confirmButton.textContent = 'ดำเนินการต่อ (เกิดข้อผิดพลาด)';
                        }
                    }
                },
            }).then((result) => {
                if (result.isConfirmed) {
                    console.log("Step 5 video confirmation received.");
                    step5VideoWatched = true;
                    enableStep5Actions();
                }
            });
        }
        function enableStep5Actions() {
            console.log("Enabling Step 5 actions (file uploads).");
            if (idCardFrontDrop) idCardFrontDrop.classList.remove('disabled');
            if (idCardBackDrop) idCardBackDrop.classList.remove('disabled');
             if (idCardFrontDrop) idCardFrontDrop.style.borderColor = '#bdbdbd';
             if (idCardBackDrop) idCardBackDrop.style.borderColor = '#bdbdbd';
        }
              // --- Function to setup file upload listeners ---
        // *** เพิ่มพารามิเตอร์ isFront ใน signature ของฟังก์ชัน ***
        function setupFileUpload(inputId, dropZoneId, previewContainerId, previewImageId, removeButtonId, isFront) { // <--- เพิ่ม isFront ตรงนี้
            const fileInput = document.getElementById(inputId);
            const dropZone = document.getElementById(dropZoneId);
            const previewContainer = document.getElementById(previewContainerId);
            const previewImage = document.getElementById(previewImageId);
            const removeButton = document.getElementById(removeButtonId);

            if (!fileInput || !dropZone || !previewContainer || !previewImage || !removeButton) {
                console.error(`Missing elements for file upload setup: inputId=${inputId}`);
                return;
            }

            dropZone.addEventListener('click', () => {
                if (!dropZone.classList.contains('disabled')) {
                     console.log(`Dropzone clicked: ${dropZoneId}. Triggering input: ${inputId}`);
                     if (idCardCameraGuide) idCardCameraGuide.classList.add('visible');
                     setTimeout(() => fileInput.click(), 50);
                } else {
                    console.log(`Upload area ${dropZoneId} is disabled, likely video not watched.`);
                     if (!step5VideoWatched) {
                          showIdCardVideoGuide();
                     } else {
                          console.warn(`Upload area ${dropZoneId} disabled, but step 5 video already watched.`);
                     }
                }
            });

            // fileChangeHandler จะสามารถเข้าถึง isFront จาก scope ของ setupFileUpload ได้
            const fileChangeHandler = async function() {
                 console.log(`File input changed: ${this.id}`);
                 if (idCardCameraGuide) idCardCameraGuide.classList.remove('visible');

                if (this.files && this.files[0]) {
                    const file = this.files[0];
                    console.log(`File selected: ${file.name}, Type: ${file.type}, Size: ${file.size}`);
                    const acceptedTypes = (this.accept || "image/*").split(',').map(t => t.trim().toLowerCase());
                    const fileTypeLower = file.type?.toLowerCase() || '';
                    const fileNameLower = file.name?.toLowerCase() || '';
                     const isAccepted = acceptedTypes.some(type =>
                         (type === 'image/*' && fileTypeLower.startsWith('image/')) ||
                         fileTypeLower === type ||
                         (type === 'image/heic' && fileNameLower.endsWith('.heic')) ||
                         (type === 'image/heif' && fileNameLower.endsWith('.heif'))
                     );

                     if (!isAccepted) {
                          showError('ไฟล์ไม่รองรับ', `กรุณาเลือกไฟล์ภาพที่รองรับ (${this.accept || 'JPG, PNG, HEIC'})`);
                          resetPreview(previewImage, previewContainer, dropZone);
                          // --- Clear stored file object if type is wrong ---
                          if (isFront) { idCardFrontFileObject = null; } else { idCardBackFileObject = null; }
                          // ----------------------------------------------
                          updateTriggerOcrButtonState();
                          this.value = ''; // Clear the input field
                          return;
                     }

                    try {
                        // *** ส่งค่า isFront ที่ได้รับมาจาก setupFileUpload เข้าไป ***
                        await handleFileDisplay(file, previewImage, previewContainer, dropZone, isFront); // <--- แก้ตรงนี้
                        updateTriggerOcrButtonState();
                    } catch (error) {
                        console.error("Error handling file display:", error);
                        showError('แสดงตัวอย่างไม่ได้', `เกิดข้อผิดพลาดในการแสดงภาพ: ${error.message}`);
                        resetPreview(previewImage, previewContainer, dropZone);
                        // --- Clear stored file object on display error ---
                        if (isFront) { idCardFrontFileObject = null; } else { idCardBackFileObject = null; }
                        // ----------------------------------------------
                        updateTriggerOcrButtonState();
                         this.value = ''; // Clear the input field
                    }
                } else {
                     console.log(`No file selected or selection cancelled for ${this.id}.`);
                     resetPreview(previewImage, previewContainer, dropZone);
                     // --- Clear stored file object if selection cancelled ---
                     if (isFront) { idCardFrontFileObject = null; } else { idCardBackFileObject = null; }
                     // ---------------------------------------------------
                     updateTriggerOcrButtonState();
                }
            };
            fileInput.addEventListener('change', fileChangeHandler);

            // Listener ของ removeButton ถูกต้องแล้ว ไม่ต้องแก้
            removeButton.addEventListener('click', (e) => {
                e.stopPropagation();
                console.log(`Remove button clicked for: ${removeButtonId}`);
                fileInput.value = ''; // Clear the input element's value
                resetPreview(previewImage, previewContainer, dropZone);
                resetOcrFields(true);

                // --- Clear the stored File object ---
                const isFrontRemove = removeButtonId === 'remove-front'; // ใช้ตัวแปรใหม่จะได้ไม่งง
                if (isFrontRemove) {
                    idCardFrontFileObject = null;
                    console.log("Cleared idCardFrontFileObject");
                } else {
                    idCardBackFileObject = null;
                    console.log("Cleared idCardBackFileObject");
                }
                // ------------------------------------

                updateTriggerOcrButtonState();
                updateStep5ButtonState();
            });


            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, (e) => {
                    e.preventDefault(); e.stopPropagation();
                    if (!dropZone.classList.contains('disabled')) dropZone.classList.add('dragover');
                });
            });
            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, (e) => {
                    e.preventDefault(); e.stopPropagation();
                    dropZone.classList.remove('dragover');
                    if (eventName === 'drop' && !dropZone.classList.contains('disabled') && e.dataTransfer?.files) {
                        const files = e.dataTransfer.files;
                        if (files.length > 0) {
                            fileInput.files = files; // Assign dropped files to the input
                            fileChangeHandler.call(fileInput); // Trigger handler
                        }
                    }
                }, false);
            });
        } // <-- ปิดฟังก์ชัน setupFileUpload
    // --- Utility Function (จำเป็นต้องมีอยู่) ---
function dataURItoBlob(dataURI) {
    if (!dataURI?.includes(',')) {
        console.error("Invalid data URI:", dataURI?.substring(0, 50));
        return null;
    }
    try {
        // convert base64 to raw binary data held in a string
        const byteString = atob(dataURI.split(',')[1]);
        // separate out the mime component
        const mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];
        // write the bytes of the string to an ArrayBuffer
        const ab = new ArrayBuffer(byteString.length);
        const ia = new Uint8Array(ab);
        for (let i = 0; i < byteString.length; i++) {
            ia[i] = byteString.charCodeAt(i);
        }
        return new Blob([ab], { type: mimeString });
    } catch (e) {
        console.error("Error converting data URI to Blob:", e);
        return null;
    }
}


 async function handleFileDisplay(file, imgElement, containerElement, dropZoneElement, isFront) {
            console.log(`Handling file display with browser-image-compression for ${file.name}, isFront: ${isFront}`);
            // Show loading indicator immediately
            Swal.fire({
                title: 'กำลังประมวลผลรูปภาพ...',
                text: 'กรุณารอสักครู่ ระบบกำลังปรับขนาดและบีบอัดรูปภาพ',
                allowOutsideClick: false,
                didOpen: () => { Swal.showLoading(); }
            });

            // Store the original file object initially (in case compression fails)
            let originalFileForUpload = file;
             if (isFront) { idCardFrontFileObject = originalFileForUpload; }
             else { idCardBackFileObject = originalFileForUpload; }

            try {
                // ** Configuration Options for the library **
                // (Adjust these values based on your needs and testing)
                const options = {
                    maxSizeMB: 0.5,          // Set maximum file size in MB (e.g., 1.5MB)
                    maxWidthOrHeight: 1280, // Set maximum width or height (e.g., 1280px)
                    useWebWorker: true,    // Use Web Worker for better performance (highly recommended)
                    initialQuality: 0.8,   // Initial quality (0 to 1) - library might adjust further
                    // Optional: Specify output format if needed, default is input type or jpeg for heic
                    // fileType: 'image/jpeg',
                    // Optional: Handle EXIF orientation - Library attempts this by default
                    // exifOrientation: true, // Default behavior, can specify number if needed
                };

                console.log(`Compressing image with options:`, options);

                // Call the compression library
                // The library should handle HEIC/HEIF automatically (check documentation if issues)
                const compressedFile = await imageCompression(file, options);

                console.log(`Compression complete. Original size: ${(file.size / 1024 / 1024).toFixed(2)} MB, Compressed size: ${(compressedFile.size / 1024 / 1024).toFixed(2)} MB`);

                // --- Store the COMPRESSED File/Blob for Upload ---
                if (isFront) {
                    idCardFrontFileObject = compressedFile; // Store the compressed file
                    console.log("Stored COMPRESSED idCardFrontFileObject.");
                } else {
                    idCardBackFileObject = compressedFile; // Store the compressed file
                    console.log("Stored COMPRESSED idCardBackFileObject.");
                }

                // --- Update Preview using the compressed file ---
                // The library provides a helper to get Data URL directly
                try {
                    const previewDataUrl = await imageCompression.getDataUrlFromFile(compressedFile);
                    imgElement.src = previewDataUrl;
                    containerElement.classList.remove('hidden');
                    dropZoneElement.classList.add('hidden');
                    console.log("Preview updated with compressed image.");
                } catch (previewError) {
                     console.error("Error generating preview Data URL from compressed file:", previewError);
                     // Fallback: Try showing original if preview fails, or just show error?
                     // For now, just log the error and proceed without preview update if it fails
                     showError('แสดงตัวอย่างไม่ได้', 'เกิดข้อผิดพลาดในการสร้างภาพตัวอย่างหลังบีบอัด');
                     // Keep the dropzone hidden as the file *is* processed
                     containerElement.classList.remove('hidden');
                     dropZoneElement.classList.add('hidden');
                     imgElement.alt = "เกิดข้อผิดพลาดในการแสดงตัวอย่าง"; // Show alt text
                     imgElement.src = ''; // Clear src
                }

            } catch (error) {
                console.error("Error during browser-image-compression or preview:", error);
                showError('ข้อผิดพลาดในการประมวลผลภาพ', `เกิดปัญหา: ${error.message || error}. กรุณาลองเลือกไฟล์ใหม่อีกครั้ง`);
                resetPreview(imgElement, containerElement, dropZoneElement);
                // Clear the stored object back to null on error
                if (isFront) { idCardFrontFileObject = null; }
                else { idCardBackFileObject = null; }
                 // Clear the file input value to allow re-selection
                 const fileInput = document.getElementById(isFront ? 'id-card-front' : 'id-card-back');
                 if (fileInput) fileInput.value = '';
            } finally {
                // Ensure loading indicator is always closed
                if (typeof Swal !== 'undefined' && Swal.isVisible()) {
                    Swal.close();
                }
                updateTriggerOcrButtonState(); // Update OCR button state after processing
            }
        }
        function resetPreview(imgElement, containerElement, dropZoneElement) {
            if (!imgElement || !containerElement || !dropZoneElement) return;
            console.log(`Resetting preview for dropzone: ${dropZoneElement.id}`);
            imgElement.src = ''; containerElement.classList.add('hidden'); dropZoneElement.classList.remove('hidden');
            dropZoneElement.style.borderColor = dropZoneElement.classList.contains('disabled') ? '#ccc' : '#bdbdbd';
            const pElement = dropZoneElement.querySelector('p');
            if(pElement) {
                const defaultText = dropZoneElement.id.includes('front') ? 'กดเพื่อถ่ายภาพบัตรด้านหน้า' : 'กดเพื่อถ่ายภาพบัตรด้านหลัง';
                pElement.textContent = defaultText;
            }
            dropZoneElement.style.cursor = dropZoneElement.classList.contains('disabled') ? 'not-allowed' : 'pointer';
        }
        function resetOcrFields(hideSection = true) {
            console.log(`Resetting OCR fields. Hide section: ${hideSection}`);
            ocrDataStore = {};
            ocrFieldsIds.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') {
                        element.value = ''; element.style.borderColor = '#ccc';
                    }
                    element.readOnly = !(id === 'firstname-th' || id === 'lastname-th' || id === 'firstname-en' || id === 'lastname-en' || id === 'address-kyc');
                }
            });
            const bd = document.getElementById('birth-day-kyc'), bm = document.getElementById('birth-month-kyc'), by = document.getElementById('birth-year-kyc');
            if (bd) bd.value = ''; if (bm) bm.value = ''; if (by) by.value = '';
            if (ocrResultDiv && hideSection) ocrResultDiv.classList.add('hidden');
            updateStep5ButtonState();
        }
        function handleVerifyIdCard(nextStep) {
            if (!recordingInstruction || !recordingInstructionContainer) { console.error("Recording instruction elements not found."); return; }
            const firstName = document.getElementById('firstname-th')?.value.trim() || '';
            const lastName = document.getElementById('lastname-th')?.value.trim() || '';
            const nameText = (firstName && lastName) ? `${firstName} ${lastName}` : 'ข้าพเจ้า';
            recordingInstruction.textContent = `"${nameText} ขอยืนยันว่าข้อมูลทั้งหมดที่ให้ไว้เป็นความจริงและถูกต้องทุกประการ"`;
            console.log(`Prepared recording instruction for Step 6: ${recordingInstruction.textContent}`);
            if(recordingInstructionContainer) recordingInstructionContainer.classList.remove('visible');
        }
        function updateTriggerOcrButtonState() {
            if (!triggerOcrGroup || !triggerOcrBtn) return;
            const frontReady = idCardFrontInput?.files[0] && frontPreviewImage?.src.startsWith('data:image');
            const backReady = idCardBackInput?.files[0] && backPreviewImage?.src.startsWith('data:image');
            const shouldShow = frontReady && backReady;
            triggerOcrGroup.classList.toggle('hidden', !shouldShow);
            triggerOcrBtn.disabled = !shouldShow || isOcrRunning;
            if (!shouldShow && ocrResultDiv && !ocrResultDiv.classList.contains('hidden')) { resetOcrFields(true); }
            updateStep5ButtonState();
        }
        function updateStep5ButtonState() {
            if (!verifyIdCardBtn) return;
            const ocrRanSuccessfully = ocrResultDiv && !ocrResultDiv.classList.contains('hidden');
            const isDataValid = validateStep5(false);
            verifyIdCardBtn.disabled = !(step5VideoWatched && ocrRanSuccessfully && isDataValid);
            if (DEBUG_MODE) { console.log(`Update Step 5 Btn: Watched=${step5VideoWatched}, OCR OK=${ocrRanSuccessfully}, Data Valid=${isDataValid}, Disabled=${verifyIdCardBtn.disabled}`); }
        }
        function validateStep5(showErrorOnFail = true) {
            let isValid = true; let firstInvalidElement = null;
            if (!step5VideoWatched) { isValid = false; if (showErrorOnFail) { showError('วิดีโอยังไม่ได้ดู', 'กรุณาดูวิดีโอแนะนำการถ่ายภาพบัตรก่อน'); showIdCardVideoGuide(); firstInvalidElement = idCardFrontDrop || idCardBackDrop; } if(idCardFrontDrop) idCardFrontDrop.classList.add('disabled'); if(idCardBackDrop) idCardBackDrop.classList.add('disabled'); if(idCardFrontDrop) idCardFrontDrop.style.borderColor = '#ccc'; if(idCardBackDrop) idCardBackDrop.style.borderColor = '#ccc'; } else { if(idCardFrontDrop) idCardFrontDrop.classList.remove('disabled'); if(idCardBackDrop) idCardBackDrop.classList.remove('disabled'); }
            const frontFiles = idCardFrontInput?.files, backFiles = idCardBackInput?.files;
            const frontPreviewReady = frontFiles?.length > 0 && frontPreviewImage?.src.startsWith('data:image');
            const backPreviewReady = backFiles?.length > 0 && backPreviewImage?.src.startsWith('data:image');
            if (isValid && !frontPreviewReady) { isValid = false; if (showErrorOnFail && !firstInvalidElement) { firstInvalidElement = idCardFrontDrop; showError('ข้อมูลไม่ครบ', 'กรุณาถ่ายภาพบัตรประชาชนด้านหน้า'); } if (idCardFrontDrop) idCardFrontDrop.style.borderColor = 'var(--danger-color)'; } else if (idCardFrontDrop && frontPreviewReady) { idCardFrontDrop.style.borderColor = idCardFrontDrop.classList.contains('disabled') ? '#ccc' : '#bdbdbd'; }
            if (isValid && !backPreviewReady) { isValid = false; if (showErrorOnFail && !firstInvalidElement) { firstInvalidElement = idCardBackDrop; showError('ข้อมูลไม่ครบ', 'กรุณาถ่ายภาพบัตรประชาชนด้านหลัง'); } if (idCardBackDrop) idCardBackDrop.style.borderColor = 'var(--danger-color)'; } else if (idCardBackDrop && backPreviewReady) { idCardBackDrop.style.borderColor = idCardBackDrop.classList.contains('disabled') ? '#ccc' : '#bdbdbd'; }
            const ocrRanSuccessfully = ocrResultDiv && !ocrResultDiv.classList.contains('hidden');
            if (isValid && !ocrRanSuccessfully) { isValid = false; if (showErrorOnFail && !firstInvalidElement) { firstInvalidElement = triggerOcrBtn || idCardFrontDrop || idCardBackDrop; showError('ยังไม่ได้อ่านข้อมูลบัตร', 'กรุณากดปุ่ม "อ่านข้อมูลบัตร" หลังจากอัปโหลดภาพทั้งสองด้าน'); } }
            if (isValid && ocrRanSuccessfully) { const requiredOcrFormFields = ['id-number-kyc', 'firstname-th', 'lastname-th', 'birthdate-kyc', 'address-kyc', 'issue-date', 'expiry-date']; for (const fieldId of requiredOcrFormFields) { const input = document.getElementById(fieldId); if (!input || !input.value.trim()) { isValid = false; if (showErrorOnFail && !firstInvalidElement) { let labelText = `ข้อมูล "${fieldId}"`; const labelElement = document.querySelector(`label[for="${fieldId}"] span`); if (labelElement) labelText = `"${labelElement.textContent}"`; showError('ข้อมูลจากบัตรไม่ครบถ้วน', `กรุณาตรวจสอบ ${labelText} ที่ได้จากบัตร (สามารถแก้ไขได้หากไม่ถูกต้อง หรือกดอ่านข้อมูลบัตรอีกครั้ง)`); firstInvalidElement = input || ocrResultDiv; } if (input) input.style.borderColor = 'var(--danger-color)'; } else if (input && input.style.borderColor === 'var(--danger-color)') { input.style.borderColor = '#ccc'; } } }
            if (!isValid && showErrorOnFail && firstInvalidElement) { firstInvalidElement.scrollIntoView({ behavior: 'smooth', block: 'center' }); setTimeout(() => { if (firstInvalidElement.focus && typeof firstInvalidElement.focus === 'function') firstInvalidElement.focus(); shakeElement(firstInvalidElement.closest('.form-group') || firstInvalidElement.closest('.upload-area') || firstInvalidElement); }, 300); }
            if (DEBUG_MODE && !showErrorOnFail) { console.log(`Internal Validate Step 5 result: ${isValid}`); }
            return isValid;
        }


        // --- Step 6: Face & Video Verification ---

        function unlockAudioContext() { if (audioCtx) { if (audioCtx.state === 'suspended') audioCtx.resume().catch(e => console.error("Error resuming AudioContext:", e)); return; } try { console.log("Attempting to create/unlock AudioContext..."); audioCtx = new (window.AudioContext || window.webkitAudioContext)(); const buffer = audioCtx.createBuffer(1, 1, 22050); const source = audioCtx.createBufferSource(); source.buffer = buffer; source.connect(audioCtx.destination); source.start(0); source.onended = () => source.disconnect(); console.log("AudioContext created/unlocked."); if (audioCtx.state === 'suspended') audioCtx.resume(); } catch (e) { console.error("Error creating/unlocking AudioContext:", e); } }
        function playActionSound(audioElement) { if (!audioElement) return; if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume().catch(e => console.error("Error resuming AC:", e)); console.log(`Playing sound: ${audioElement.id}`); audioElement.currentTime = 0; const playPromise = audioElement.play(); if (playPromise !== undefined) playPromise.catch(error => { if (error.name === 'NotAllowedError' || error.name === 'NotSupportedError') console.log(`Sound ${audioElement.id} play prevented.`); else console.error(`Sound ${audioElement.id} playback failed:`, error); }); }
        function playShutterSound() { const shutterAudio = new Audio(shutterSound.src); shutterAudio.preload = 'auto'; playActionSound(shutterAudio); }
        function playSegment(start, duration) { if (currentSegmentTimeout) { clearTimeout(currentSegmentTimeout); currentSegmentTimeout = null; } if (!mixedKycSound) return; console.log(`Playing KYC sound segment: Start=${start}s, Duration=${duration}s`); if (!mixedKycSound.paused) mixedKycSound.pause(); mixedKycSound.currentTime = start; const kycPlayPromise = mixedKycSound.play(); if (kycPlayPromise !== undefined) kycPlayPromise.then(() => { console.log(`KYC sound started playing from ${start}s.`); currentSegmentTimeout = setTimeout(() => { if (mixedKycSound && !mixedKycSound.paused) { mixedKycSound.pause(); console.log(`Paused KYC sound after ${duration}s`); } currentSegmentTimeout = null; }, duration * 1000); }).catch(error => { if (error.name === 'NotAllowedError' || error.name === 'NotSupportedError') console.log(`KYC sound play prevented.`); else console.error(`KYC sound playback failed:`, error); }); }
        function startColorFlashSequence(currentAction) { if (!flashEffect || !faceGuideFrame) return; console.log("Starting color flash for:", currentAction.label); isProcessing = true; const flashDuration = 400; faceGuideFrame.classList.remove('visible'); flashEffect.style.backgroundColor='rgba(76, 175, 80, 0.75)'; flashEffect.style.opacity='1'; setTimeout(() => { flashEffect.style.backgroundColor='rgba(244, 67, 54, 0.75)'; setTimeout(() => { flashEffect.style.backgroundColor='rgba(33, 150, 243, 0.75)'; setTimeout(() => { flashEffect.style.opacity='0'; setTimeout(() => { flashEffect.style.backgroundColor='#fff'; }, 300); console.log(`Capturing image post-flash for: ${currentAction.label}`); playShutterSound(); captureFaceImageMediaPipe(currentAction.label); currentAction.captured = true; playSegment(segmentTimes[1].start, segmentTimes[1].duration); resetFaceActionTimer(); moveToNextAction(); setTimeout(() => { isProcessing = false; console.log("Processing unlocked post-flash."); }, 50); }, flashDuration); }, flashDuration); }, flashDuration); }
        async function initWebcamStreamOnly() { if (stream && stream.active && stream.getVideoTracks()[0]?.readyState === 'live') { console.log("Stream already active."); if (videoElementFace && videoElementFace.srcObject !== stream) videoElementFace.srcObject = stream; if (videoElementVideo && videoElementVideo.srcObject !== stream) videoElementVideo.srcObject = stream; if (videoElementFace?.paused) videoElementFace.play().catch(e => console.warn("Could not play face video", e)); if (videoElementVideo?.paused) videoElementVideo.play().catch(e => console.warn("Could not play record video", e)); return stream; } stopWebcamAndRecording(); console.log("Initializing new webcam stream..."); if(overlayFace) { overlayFace.querySelector('p').textContent = 'กำลังเตรียมกล้อง...'; overlayFace.querySelector('i').className = 'fas fa-camera-retro'; overlayFace.classList.remove('hidden'); } try { const constraints = { video: { facingMode: 'user', width: { ideal: 640 }, height: { ideal: 480 } }, audio: true }; stream = await navigator.mediaDevices.getUserMedia(constraints); console.log("Webcam stream acquired."); if (videoElementFace) { videoElementFace.srcObject = stream; videoElementFace.muted = true; await videoElementFace.play(); } if (videoElementVideo) { videoElementVideo.srcObject = stream; videoElementVideo.muted = true; await videoElementVideo.play(); } console.log("Webcam stream setup complete."); if(overlayFace) overlayFace.classList.add('hidden'); if(webcamContainerFace) webcamContainerFace.classList.add('playing'); return stream; } catch (error) { console.error("getUserMedia error:", error); stream = null; if(overlayFace) { overlayFace.querySelector('p').textContent = 'เปิดกล้อง/ไมค์ไม่ได้'; overlayFace.querySelector('i').className = 'fas fa-exclamation-triangle'; overlayFace.classList.remove('hidden'); } let userMessage = `เกิดข้อผิดพลาด: ${error.name}. `; if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') userMessage += 'กรุณาอนุญาตให้แอปนี้เข้าถึงกล้องและไมโครโฟน'; else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') userMessage += 'ไม่พบกล้องหรือไมโครโฟน'; else userMessage += 'กรุณาตรวจสอบการเชื่อมต่อกล้อง/ไมค์'; showError('เข้าถึงกล้อง/ไมค์ไม่ได้', userMessage); if(startFaceCaptureBtn) startFaceCaptureBtn.disabled = true; if(retakeFaceCaptureBtn) retakeFaceCaptureBtn.disabled = true; return null; } }
        function stopWebcamAndRecording() { console.log("Stopping webcam/recording..."); isProcessing = false; isFaceProcessing = false; if (mediaPipeCamera) { try { mediaPipeCamera.stop(); console.log("MP Camera stopped."); } catch (e) {} mediaPipeCamera = null; } if (mediaRecorder && mediaRecorder.state !== 'inactive') { try { mediaRecorder.stop(); console.log("Recorder stopped."); } catch(e){} } mediaRecorder = null; if (stream) stream.getTracks().forEach(track => { if (track.readyState === 'live') track.stop(); }); stream = null; try { if(videoElementFace?.srcObject) videoElementFace.srcObject = null; if(videoElementVideo?.srcObject) videoElementVideo.srcObject = null; } catch(e) {} if (noFaceDetectedTimeout) clearTimeout(noFaceDetectedTimeout); noFaceDetectedTimeout = null; if (currentSegmentTimeout) clearTimeout(currentSegmentTimeout); currentSegmentTimeout = null; faceActionStartTime = null; if(webcamContainerFace) webcamContainerFace.classList.remove('playing'); if(overlayFace) { overlayFace.querySelector('p').textContent = 'กล้องหยุดทำงาน'; overlayFace.querySelector('i').className = 'fas fa-video-slash'; overlayFace.classList.remove('hidden'); } if(faceGuideFrame) faceGuideFrame.classList.remove('visible', 'invalid'); if(statusTextEl) statusTextEl.classList.add('hidden'); if(instructionTextEl) instructionTextEl.classList.add('hidden'); if(countdownTextEl) countdownTextEl.classList.add('hidden'); if(recordingIndicator) recordingIndicator.classList.add('hidden'); if(videoRecordingSection) videoRecordingSection.classList.remove('active'); if(recordingInstructionContainer) recordingInstructionContainer.classList.remove('visible'); console.log("Webcam/MediaPipe/Recorder released."); }
        async function startFaceCaptureProcess() { if (isProcessing || !faceMesh) { console.warn(`Cannot start face capture: isProcessing=${isProcessing}, faceMesh initialized=${!!faceMesh}`); if (!faceMesh) showError("ข้อผิดพลาด", "โมเดลตรวจจับใบหน้ายังไม่พร้อมใช้งาน"); return; } await Swal.fire({ icon: 'info', title: 'ปรับความสว่างหน้าจอ', text: 'เพื่อการตรวจจับใบหน้าที่แม่นยำยิ่งขึ้น โปรดปรับความสว่างหน้าจอของท่านให้สูงสุดก่อนดำเนินการต่อ', confirmButtonText: 'รับทราบ', confirmButtonColor: 'var(--primary-color)' }); console.log("Starting face capture process..."); isProcessing = true; if(startFaceCaptureBtn) { startFaceCaptureBtn.disabled = true; startFaceCaptureBtn.classList.add("hidden"); } if(retakeFaceCaptureBtn) { retakeFaceCaptureBtn.disabled = false; retakeFaceCaptureBtn.classList.remove("hidden"); } hideStatus(); if(capturedFacesContainer) { capturedFacesContainer.innerHTML = ""; capturedFacesContainer.classList.add("hidden"); } if(countdownTextEl) countdownTextEl.classList.add("hidden"); if(instructionTextEl) instructionTextEl.classList.remove("detected", "hidden"); if(submitKycBtn) { submitKycBtn.classList.add("hidden"); submitKycBtn.disabled = true; } if(faceGuideFrame) faceGuideFrame.classList.remove('invalid'); if(overlayFace) overlayFace.classList.add('hidden'); currentFaceActionIndex = 0; faceActionStartTime = null; faceActionsSource.forEach(a => a.captured = false); capturedFaces = []; if (!stream || !stream.active) { stream = await initWebcamStreamOnly(); if (!stream) { console.error("Failed stream init in startFaceCaptureProcess."); isProcessing = false; if(startFaceCaptureBtn) { startFaceCaptureBtn.classList.remove("hidden"); startFaceCaptureBtn.disabled = true; } if(retakeFaceCaptureBtn) { retakeFaceCaptureBtn.classList.add("hidden"); } return; } } else { console.log("Using existing active stream."); if (videoElementFace?.paused) videoElementFace.play().catch(e => console.warn("Could not play face video", e)); if (videoElementVideo?.paused) videoElementVideo.play().catch(e => console.warn("Could not play record video", e)); } try { if (mediaPipeCamera) { try { mediaPipeCamera.stop(); } catch(e) {} mediaPipeCamera = null; } console.log("Creating new MediaPipe Camera instance."); mediaPipeCamera = new Camera(videoElementFace, { onFrame: async () => { if (videoElementFace.readyState >= 3 && faceMesh && !isFaceProcessing) { try { isFaceProcessing = true; await faceMesh.send({ image: videoElementFace }); } catch (e) { console.error("Error sending frame to FaceMesh:", e); isFaceProcessing = false; } } }, width: 640, height: 480 }); await mediaPipeCamera.start(); console.log("MediaPipe Camera started."); if(webcamContainerFace) webcamContainerFace.classList.add('playing'); if(overlayFace) overlayFace.classList.add('hidden'); if(faceGuideFrame) faceGuideFrame.classList.add('visible'); if (faceActionsSource.length > 0) updateInstruction(faceActionsSource[0].label); else if(instructionTextEl) instructionTextEl.classList.add("hidden"); isProcessing = false; console.log("Face capture process initiated."); } catch (error) { console.error("Error starting MediaPipe Camera:", error); showError('เกิดข้อผิดพลาด', 'ไม่สามารถเริ่มการทำงานของกล้องตรวจจับใบหน้าได้'); stopWebcamAndRecording(); isProcessing = false; if(startFaceCaptureBtn) { startFaceCaptureBtn.classList.remove("hidden"); startFaceCaptureBtn.disabled = true; } if(retakeFaceCaptureBtn) { retakeFaceCaptureBtn.classList.add("hidden"); retakeFaceCaptureBtn.disabled = true; } if(faceGuideFrame) faceGuideFrame.classList.remove('visible'); } }
        function onFaceResults(results) { isFaceProcessing = false; if (currentStep !== 6 || isProcessing) return; clearTimeout(noFaceDetectedTimeout); noFaceDetectedTimeout = null; const faceDetected = results.multiFaceLandmarks?.length > 0; if (!faceDetected) { const processActive = retakeFaceCaptureBtn && !retakeFaceCaptureBtn.classList.contains('hidden'); if (processActive) { showStatus("ไม่พบใบหน้า กรุณาอยู่ในกรอบ"); if(faceGuideFrame) faceGuideFrame.classList.remove('invalid'); if (!noFaceDetectedTimeout) noFaceDetectedTimeout = setTimeout(hideStatus, 2000); } if (faceActionStartTime) resetFaceActionTimer(); updateDebugInfo(null); return; } const landmarks = results.multiFaceLandmarks[0]; updateDebugInfo(landmarks); if (currentFaceActionIndex >= faceActionsSource.length) { if(faceGuideFrame) faceGuideFrame.classList.remove('invalid'); return; } const currentAction = faceActionsSource[currentFaceActionIndex]; if (currentAction.captured) { moveToNextAction(); return; } if(instructionTextEl?.classList.contains('hidden')) updateInstruction(currentAction.label); if (!isFaceInGuide(landmarks)) { showStatus("กรุณาจัดใบหน้าให้อยู่ในกรอบ", true); if (faceActionStartTime) resetFaceActionTimer(); if(instructionTextEl) instructionTextEl.classList.remove("detected"); return; } hideStatus(); if(faceGuideFrame) faceGuideFrame.classList.remove('invalid'); let actionDetected = false; if (currentAction.detector) try { actionDetected = currentAction.detector(landmarks); } catch (e){ console.error(`Detector error: ${e}`); } if (actionDetected) { if(instructionTextEl) instructionTextEl.classList.add("detected"); if (faceActionStartTime === null) { console.log(`Detected: "${currentAction.label}". Starting timer.`); faceActionStartTime = Date.now(); if(countdownTextEl) countdownTextEl.classList.remove("hidden"); } const elapsed = (Date.now() - faceActionStartTime) / 1000; const remaining = Math.max(0, currentAction.duration - elapsed); if(countdownTextEl) countdownTextEl.textContent = `ค้างไว้ ${Math.ceil(remaining)} วินาที`; if (remaining <= 0 && !currentAction.captured && !isProcessing) { console.log(`Hold met for "${currentAction.label}". Capturing...`); isProcessing = true; const completedActionIndex = currentFaceActionIndex; if (currentAction.label === "กรุณามองตรง") { startColorFlashSequence(currentAction); } else { console.log(`Capturing directly: ${currentAction.label}`); playShutterSound(); captureFaceImageMediaPipe(currentAction.label); currentAction.captured = true; const nextSegmentIndex = completedActionIndex + 1; if (nextSegmentIndex < segmentTimes.length) playSegment(segmentTimes[nextSegmentIndex].start, segmentTimes[nextSegmentIndex].duration); resetFaceActionTimer(); moveToNextAction(); isProcessing = false; console.log(`Processing unlocked after direct capture: ${currentAction.label}.`); } } } else { if (faceActionStartTime !== null) resetFaceActionTimer(); if(instructionTextEl) instructionTextEl.classList.remove("detected"); } }
        function resetFaceActionTimer() { faceActionStartTime = null; if(countdownTextEl) countdownTextEl.classList.add("hidden"); if(instructionTextEl) instructionTextEl.classList.remove("detected"); }
                // --- *** ฟังก์ชันใหม่: ส่งรูปภาพใบหน้าที่บันทึกไว้ *** ---
        // --- *** NEW FUNCTION: Send Captured Face Images *** ---
        async function sendCapturedFaceImages() {
            // ตรวจสอบว่ามี LIFF User ID หรือไม่
            if (!liffUserId) {
                showError("ข้อผิดพลาด", "ไม่พบข้อมูลผู้ใช้ LINE กรุณาลองรีเฟรช");
                return false; // ไม่สามารถดำเนินการต่อได้หากไม่มี User ID
            }
            // ตรวจสอบว่ามีรูปภาพใบหน้าที่บันทึกไว้หรือไม่
            if (!capturedFaces || capturedFaces.length === 0) {
                showError("ข้อผิดพลาด", "ไม่พบข้อมูลรูปภาพใบหน้าที่บันทึกไว้");
                return false; // ไม่สามารถดำเนินการต่อได้หากไม่มีรูปภาพ
            }

            // ดึงข้อมูล base64 จากอาร์เรย์ capturedFaces
            // Extract base64 data only
            const faceImageBase64Array = capturedFaces.map(face => face.data).filter(Boolean);

            // ตรวจสอบว่าข้อมูล base64 ครบถ้วนหรือไม่ (เผื่อกรณีมีข้อผิดพลาด)
            if (faceImageBase64Array.length !== capturedFaces.length) {
                 console.warn("ข้อมูลรูปภาพใบหน้าบางส่วนอาจไม่มี base64 string.");
                 // อาจจะดำเนินการต่อ หรือแจ้งเตือน ตรงนี้เลือกที่จะดำเนินการต่อแต่ log ไว้
                 // Decide if this is critical - maybe proceed anyway? Or return false?
                 // For now, let's proceed but log it.
            }
            // ตรวจสอบว่ามี base64 string อย่างน้อย 1 รูปหรือไม่
            if (faceImageBase64Array.length === 0) {
                 showError("ข้อผิดพลาด", "ไม่สามารถดึงข้อมูลรูปภาพใบหน้า (Base64) ได้");
                 return false;
            }

            // เตรียมข้อมูลที่จะส่งไปยัง API
            // Prepare the payload
            const payload = {
                line_user_id: liffUserId,
                face_images: faceImageBase64Array // ส่งอาร์เรย์ของ base64 strings
                // เพิ่มข้อมูลอื่นๆ ที่จำเป็นสำหรับ API ในขั้นตอนนี้ (ถ้ามี)
                // Add any other necessary identifiers if your API requires them at this stage
            };

            // แสดง Log ข้อมูลที่จะส่ง (ซ่อน base64 เต็ม)
            // Log the payload (masking full base64)
            console.log("Sending Captured Face Images Payload:", JSON.stringify(
                 payload,
                 (key, value) => (key === 'face_images' && Array.isArray(value))
                     ? value.map(img => img ? img.substring(0, 60) + '...' : null) // แสดง base64 แค่บางส่วน
                     : value
             ));

            // แสดงสถานะกำลังโหลด (เช่น อัปเดตข้อความแนะนำ หรือใช้ SweetAlert)
            // Show loading indicator (e.g., update instruction text)
            if (instructionTextEl) updateInstruction("กำลังบันทึกภาพใบหน้า...", false);
            // หรือใช้ Swal แสดง popup loading:
            // Swal.fire({ title: 'กำลังบันทึกภาพใบหน้า...', allowOutsideClick: false, didOpen: () => Swal.showLoading() });

            try {
                // ใช้ API URL *เดียวกัน* กับการอัปเดตข้อมูลอื่นๆ
                // Use the *SAME* API URL as other upserts
                const response = await fetch(INITIAL_DATA_API_URL, {
                    method: 'POST', // หรือ PUT ถ้า API ของคุณใช้ PUT สำหรับการอัปเดต
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });

                // พยายามแปลงผลลัพธ์เป็น JSON
                // Attempt to parse response
                const result = await response.json();

                // จัดการข้อผิดพลาดจาก API (เช่น status 4xx, 5xx)
                if (!response.ok) {
                    const errorMsg = result.message || result.error || `API Error: ${response.status}`;
                    console.error('API Error Saving Face Images:', result);
                    throw new Error(errorMsg); // โยน error เพื่อไปจัดการใน catch block
                }

                // --- กรณีสำเร็จ ---
                // --- Success ---
                console.log("Face images sent successfully:", result);
                showSuccess('บันทึกภาพใบหน้าสำเร็จ', 'รูปภาพใบหน้าของคุณถูกส่งไปบันทึกเรียบร้อย');
                // if (Swal.isLoading()) Swal.close(); // ปิด popup loading (ถ้าใช้)
                return true; // คืนค่า true เพื่อบอกว่าสำเร็จ

            } catch (error) {
                // --- กรณีล้มเหลว (Network หรือ API error) ---
                // --- Failure ---
                console.error("Error sending face images to API:", error);
                showError('บันทึกภาพใบหน้าไม่สำเร็จ', `เกิดข้อผิดพลาด: ${error.message}. กรุณาลองถ่ายภาพใบหน้าใหม่อีกครั้ง`);
                // if (Swal.isLoading()) Swal.close(); // ปิด popup loading (ถ้าใช้)
                // รีเซ็ตข้อความ loading กลับเป็นข้อความเดิม (ถ้าใช้)
                 if (instructionTextEl) updateInstruction("บันทึกภาพใบหน้าครบแล้ว 🎉", true);
                return false; // คืนค่า false เพื่อบอกว่าล้มเหลว
            }
        }
        // --- *** จบฟังก์ชันใหม่ *** ---
        // --- *** END NEW FUNCTION *** ---
      async function moveToNextAction() { // <<< เพิ่ม async ตรงนี้
            resetFaceActionTimer();
            currentFaceActionIndex++;
            console.log("กำลังไปยังท่าทางถัดไป ลำดับที่: (Moving to face action index:)", currentFaceActionIndex);

            if (currentFaceActionIndex < faceActionsSource.length) {
                // --- ยังมีท่าทางต่อไป ---
                const nextAction = faceActionsSource[currentFaceActionIndex];
                updateInstruction(nextAction.label);
                if(countdownTextEl) countdownTextEl.classList.add("hidden");
                if(instructionTextEl) instructionTextEl.classList.remove("detected");
                if(faceGuideFrame) {
                    faceGuideFrame.classList.add('visible');
                    faceGuideFrame.classList.remove('invalid');
                }
            } else {
                // --- *** บันทึกภาพใบหน้าครบทุกท่าทางแล้ว *** ---
                console.log("บันทึกภาพใบหน้าครบทุกท่าทางแล้ว! (All face actions completed!)");

                // 1. อัปเดต UI แสดงสถานะว่าเสร็จสิ้น
                updateInstruction("บันทึกภาพใบหน้าครบแล้ว 🎉", true);
                if(countdownTextEl) countdownTextEl.classList.add("hidden");
                if(faceGuideFrame) faceGuideFrame.classList.remove('visible', 'invalid');
                if(debugInfoEl) debugInfoEl.classList.add('hidden');

                // 2. หยุดการทำงานของกล้อง MediaPipe
                if (mediaPipeCamera) {
                    try{ mediaPipeCamera.stop(); console.log("MediaPipe Camera stopped after face capture."); } catch(e){}
                    mediaPipeCamera = null;
                }

                // 3. ปิดการใช้งานปุ่ม "ถ่ายใหม่" ชั่วคราวระหว่างส่งข้อมูล
                if(retakeFaceCaptureBtn) retakeFaceCaptureBtn.disabled = true;

                // 4. แสดงรูปภาพที่บันทึกไว้ให้ผู้ใช้ดู
                displayCapturedFaces();

                // 5. *** เรียกฟังก์ชันส่งรูปภาพไปบันทึก ***
                const imagesSent = await sendCapturedFaceImages(); // รอผลลัพธ์

                if (imagesSent) {
                    // --- กรณีส่งสำเร็จ: เตรียมไปยังขั้นตอนวิดีโอ ---
                    console.log("ส่งรูปภาพสำเร็จ กำลังเตรียมไปยังขั้นตอนวิดีโอ");
                    // ซ่อนปุ่ม "ถ่ายใหม่" ถาวร
                    if(retakeFaceCaptureBtn) {
                        retakeFaceCaptureBtn.classList.add("hidden");
                        retakeFaceCaptureBtn.disabled = true;
                    }

                    // ตั้งเวลาเพื่อเปลี่ยนไปแสดงส่วนบันทึกวิดีโอ
                    setTimeout(() => {
                        if (currentStep !== 6) return; // ตรวจสอบเผื่อผู้ใช้ออกไปก่อน
                        if(faceCaptureSection) faceCaptureSection.classList.add('hidden'); // ซ่อนส่วนถ่ายภาพ
                        if(videoRecordingSection) videoRecordingSection.classList.remove('hidden'); // แสดงส่วนวิดีโอ
                        if(startRecordingBtn) startRecordingBtn.disabled = false; // เปิดปุ่มเริ่มบันทึกวิดีโอ
                        if (recordingInstructionContainer) recordingInstructionContainer.classList.remove('visible');
                        videoRecordingSection.scrollIntoView({ behavior: 'smooth', block: 'start' }); // เลื่อนหน้าจอ

                        // ตรวจสอบและเตรียม stream สำหรับวิดีโอ
                        if (stream?.active && videoElementVideo) {
                            if (videoElementVideo.srcObject !== stream) videoElementVideo.srcObject = stream;
                            if (videoElementVideo.paused) videoElementVideo.play().catch(e => console.error("Error playing video for recording:", e));
                        } else {
                            console.warn("Stream not active for video recording. Re-init.");
                            initWebcamStreamOnly(); // เริ่ม stream ใหม่ถ้าจำเป็น
                        }
                    }, 1500); // รอ 1.5 วินาที

                } else {
                    // --- กรณีส่งล้มเหลว: อยู่ที่หน้าตรวจสอบภาพ ---
                    console.log("ส่งรูปภาพล้มเหลว เปิดใช้งานปุ่มถ่ายใหม่");
                    // เปิดใช้งานปุ่ม "ถ่ายใหม่" อีกครั้ง
                    if(retakeFaceCaptureBtn) {
                        retakeFaceCaptureBtn.disabled = false;
                        retakeFaceCaptureBtn.classList.remove("hidden"); // ทำให้ปุ่มแสดง (ถ้าเคยซ่อนไป)
                         // อาจจะ focus ที่ปุ่มเลยก็ได้
                         // retakeFaceCaptureBtn.focus();
                    }
                    // ไม่ต้องทำอะไรต่อ ให้ผู้ใช้อยู่ที่หน้าเดิมเพื่อกด "ถ่ายใหม่"
                }
            }
        }
        function captureFaceImageMediaPipe(actionLabel) { const canvas = document.createElement("canvas"); if (!videoElementFace || !videoElementFace.videoWidth || videoElementFace.readyState < 3) { console.error("Face video element not ready for capture."); isProcessing = false; return; } canvas.width = videoElementFace.videoWidth; canvas.height = videoElementFace.videoHeight; const ctx = canvas.getContext("2d"); if (!ctx) { console.error("Failed to get 2D context"); isProcessing = false; return; } ctx.translate(canvas.width, 0); ctx.scale(-1, 1); ctx.drawImage(videoElementFace, 0, 0, canvas.width, canvas.height); const imageDataUrl = canvas.toDataURL("image/jpeg", 0.85); capturedFaces.push({ instruction: actionLabel, data: imageDataUrl }); const card = document.createElement('div'); card.className = 'preview-card'; const img = document.createElement("img"); img.src = imageDataUrl; img.className = 'preview-image'; img.alt = `Captured: ${actionLabel}`; const info = document.createElement('div'); info.className = 'preview-info'; info.innerHTML = `<p>${actionLabel}</p>`; card.appendChild(img); card.appendChild(info); if (capturedFacesContainer) capturedFacesContainer.appendChild(card); console.log(`Face image captured for: ${actionLabel}`); }
        function displayCapturedFaces() { if (!capturedFacesContainer) return; if (capturedFaces.length > 0) { console.log(`Displaying ${capturedFaces.length} captured faces.`); capturedFacesContainer.innerHTML = ''; capturedFaces.forEach((face, index) => { const faceCard = document.createElement('div'); faceCard.className = 'preview-card'; faceCard.innerHTML = `<img src="${face.data}" alt="ภาพใบหน้า ${index + 1}: ${face.instruction}" class="preview-image" loading="lazy"><div class="preview-info"><p>${face.instruction}</p></div>`; capturedFacesContainer.appendChild(faceCard); }); capturedFacesContainer.classList.remove("hidden"); } else { capturedFacesContainer.classList.add("hidden"); } }
        function retakeFaceCapture() { console.log("Retaking face capture..."); if (isProcessing) { console.warn("Cannot retake while processing."); return; } if (mixedKycSound && !mixedKycSound.paused) { mixedKycSound.pause(); } if (currentSegmentTimeout) clearTimeout(currentSegmentTimeout); currentSegmentTimeout = null; if (noFaceDetectedTimeout) clearTimeout(noFaceDetectedTimeout); noFaceDetectedTimeout = null; resetFaceActionTimer(); if(faceGuideFrame) faceGuideFrame.classList.remove('visible', 'invalid'); if (videoRecordingSection) videoRecordingSection.classList.add('hidden'); if (startRecordingBtn) startRecordingBtn.disabled = true; if (submitKycBtn) { submitKycBtn.classList.add('hidden'); submitKycBtn.disabled = true; } if (mediaPipeCamera) { try { mediaPipeCamera.stop(); } catch(e){} mediaPipeCamera = null; } if (faceCaptureSection) faceCaptureSection.classList.remove('hidden'); startFaceCaptureProcess(); }
        function distance(p1,p2){if(!p1||!p2)return 0;return Math.hypot(p1.x-p2.x,p1.y-p2.y,p1.z-p2.z);}
        function isLookingStraight(l){if(!l || l.length < 468) return false; const n=l[1],le=l[133],re=l[362],c=l[152];const ed=distance(le,re);if(ed<0.01)return!1;const x=(le.x+re.x)/2,y=(le.y+re.y)/2;const cd=Math.abs(y-c.y);if(cd<0.01)return!1;const dx=n.x-x,dy=n.y-y;const tx=ed*0.20,tr=0.15,er=0.45;const nr=dy/cd;const lx=Math.abs(dx)<tx,ly=Math.abs(nr-er)<tr;debugData.LookStraight=`dX:${Math.abs(dx).toFixed(3)}<${tx.toFixed(3)}, N-Ratio:${nr.toFixed(3)}≈${er}±${tr}`;return lx&&ly}
        function isSmiling(l){if(!l || l.length < 468) return false; const lc=l[61],rc=l[291],u=l[0],d=l[17]; const w=distance(lc,rc); const v=distance(u,d); if(v<0.005)return false; const r=w/v; const t=3.8; debugData.Smile=`Ratio:${r.toFixed(2)}, Thresh:>${t.toFixed(1)}`; return r>t;}
        function isMouthOpen(l){if(!l || l.length < 468) return false; const u=l[13],d=l[14],le=l[133],re=l[362];const o=distance(u,d);const e=distance(le,re);if(e<0.01)return!1;const r=o/e,t=0.12;debugData.MouthOpen=`Ratio:${r.toFixed(3)}, Thresh:>${t}`;return r>t}
        function getHeadYaw(l){if(!l || l.length < 468) return 0; const n=l[1],lf=l[234],rf=l[454];const w=distance(lf,rf);if(w<0.01)return 0;const x1=Math.abs(n.x-lf.x),x2=Math.abs(n.x-rf.x);const r=x2/(x1+1e-6);let y=0;if(r>0.01&&r<100)y=Math.log(r)*45;else if(r<=0.01)y=-90;else y=90;debugData.HeadYaw=`Yaw:${y.toFixed(1)} deg`;return y}
        function isTurnedLeft(l){const y=getHeadYaw(l),t=-12;return y<t}
        function isTurnedRight(l){const y=getHeadYaw(l),t=12;return y>t}
        function updateInstruction(text, addIcon = true) { if (!instructionTextEl) return; let iconHtml = ''; const isCompletionMessage = text.includes("ครบ"); if (addIcon && !isCompletionMessage) { let iconClass = 'fa-bullseye'; if (text.includes('ยิ้ม')) iconClass = 'fa-smile'; else if (text.includes('อ้าปาก')) iconClass = 'fa-surprise'; else if (text.includes('ซ้าย')) iconClass = 'fa-arrow-left'; else if (text.includes('ขวา')) iconClass = 'fa-arrow-right'; else if (text.includes('ตรง')) iconClass = 'fa-eye'; iconHtml = `<i class="fas ${iconClass}" style="opacity: 0.9; margin-right: 8px;"></i>`; } else if (isCompletionMessage) iconHtml = `<i class="fas fa-check-circle" style="color: var(--success-color); margin-right: 8px;"></i> `; instructionTextEl.innerHTML = `${iconHtml}${text}`; instructionTextEl.classList.remove('hidden'); }
        function updateDebugInfo(landmarks){ if(!DEBUG_MODE || !debugInfoEl){ if(debugInfoEl) debugInfoEl.classList.add('hidden'); return; } if(currentFaceActionIndex >= faceActionsSource.length){ debugInfoEl.classList.add('hidden'); return; } let debugText = ""; if (faceActionsSource[currentFaceActionIndex]) { debugText += `Act: ${faceActionsSource[currentFaceActionIndex].label}\nThr: ${faceActionsSource[currentFaceActionIndex].thresholdDebug || 'N/A'}\n---\n`; } else debugText += "Waiting...\n"; if (!landmarks) debugText += `No Face Detected`; else { if(debugData.FaceInGuide) debugText +=`In Frame: ${debugData.FaceInGuide}\n`; const currentAction = faceActionsSource[currentFaceActionIndex]; if (currentAction) { if(currentAction.detector === isLookingStraight && debugData.LookStraight) debugText +=`Str Data: ${debugData.LookStraight.replace('\n',', ')}\n`; if(currentAction.detector === isSmiling && debugData.Smile) debugText +=`Smile Data: ${debugData.Smile}\n`; if(currentAction.detector === isMouthOpen && debugData.MouthOpen) debugText +=`Mouth Data: ${debugData.MouthOpen}\n`; if((currentAction.detector === isTurnedLeft || currentAction.detector === isTurnedRight) && debugData.HeadYaw) debugText +=`Yaw Data: ${debugData.HeadYaw}\n`; } } debugInfoEl.textContent = debugText; debugInfoEl.classList.remove('hidden'); }
        function showStatus(message, isFrameIssue = false) { if (!statusTextEl) return; statusTextEl.textContent = message; statusTextEl.classList.toggle('frame-issue', isFrameIssue); statusTextEl.classList.remove('hidden'); }
        function hideStatus() { if (!statusTextEl) return; statusTextEl.classList.add('hidden'); statusTextEl.classList.remove('frame-issue'); if (noFaceDetectedTimeout) { clearTimeout(noFaceDetectedTimeout); noFaceDetectedTimeout = null; } }
        function isFaceInGuide(landmarks) { if (!landmarks || landmarks.length < 468 || !faceGuideFrame || !videoElementFace) return false; const videoRect = videoElementFace.getBoundingClientRect(); if (videoRect.width === 0 || videoRect.height === 0) return false; const guideTop = 0.10, guideBottom = 0.90, guideLeft = 0.15, guideRight = 0.85; const foreheadTop = landmarks[10], chinBottom = landmarks[152], leftCheek = landmarks[234], rightCheek = landmarks[454]; const toleranceY = 0.05, toleranceX = 0.05; const isTopOk = foreheadTop.y > (guideTop - toleranceY), isBottomOk = chinBottom.y < (guideBottom + toleranceY), isLeftOk = leftCheek.x > (guideLeft - toleranceX), isRightOk = rightCheek.x < (guideRight + toleranceX); const faceInGuide = isTopOk && isBottomOk && isLeftOk && isRightOk; faceGuideFrame.classList.toggle('invalid', !faceInGuide); debugData.FaceInGuide = `In:${faceInGuide}(T:${isTopOk.toString()[0]},B:${isBottomOk.toString()[0]},L:${isLeftOk.toString()[0]},R:${isRightOk.toString()[0]}) Y:${foreheadTop.y.toFixed(2)}<->${chinBottom.y.toFixed(2)} X:${leftCheek.x.toFixed(2)}<->${rightCheek.x.toFixed(2)}`; return faceInGuide; }
        // --- End Face Verification Specific Functions ---


        // --- Video Recording Logic ---
        function showFaceVideoGuide() { if (typeof Swal === 'undefined') return; Swal.fire({ title: 'แนะนำการยืนยันใบหน้าและวิดีโอ', html: `<p>กรุณาดูวิดีโอแนะนำขั้นตอนการยืนยันตัวตนด้วยใบหน้าและการบันทึกวิดีโอก่อนดำเนินการต่อ</p><video id="swal-video-step6" controls playsinline autoplay  width="100%" src="${FACE_VIDEO_GUIDE_URL}" preload="metadata">เบราว์เซอร์ไม่รองรับวิดีโอ HTML5.</video><p style="font-size: 0.9em; margin-top: 10px;">(ปุ่ม "ดำเนินการต่อ" จะเปิดใช้งานเมื่อดูวิดีโอจบ)</p>`, icon: 'info', allowOutsideClick: false, allowEscapeKey: false, confirmButtonText: 'กรุณาดูวิดีโอให้จบ', confirmButtonColor: 'var(--primary-color)', didOpen: () => { const confirmButton = Swal.getConfirmButton(); const videoElement = document.getElementById('swal-video-step6'); if (confirmButton && videoElement) { confirmButton.disabled = true; videoElement.addEventListener('ended', () => { confirmButton.disabled = false; confirmButton.textContent = 'ดูจบแล้ว ดำเนินการต่อ'; }); videoElement.addEventListener('error', (e) => { showError("วิดีโอผิดพลาด", "ไม่สามารถเล่นวิดีโอแนะนำได้"); confirmButton.disabled = false; confirmButton.textContent = 'ดำเนินการต่อ (วิดีโอขัดข้อง)'; }); videoElement.play().catch(error => { Swal.update({ html: Swal.getHtmlContainer().innerHTML + '<p style="color: orange; font-size: 0.9em;">กรุณากดปุ่ม Play บนวิดีโอ</p>' }); }); } else { if (confirmButton) { confirmButton.disabled = false; confirmButton.textContent = 'ดำเนินการต่อ (เกิดข้อผิดพลาด)'; } } }, }).then((result) => { if (result.isConfirmed) { step6VideoWatched = true; enableStep6Actions(); } else if (startFaceCaptureBtn) startFaceCaptureBtn.disabled = true; }); }
        function enableStep6Actions() { console.log("Enabling Step 6 actions..."); initWebcamStreamOnly().then(obtainedStream => { if (obtainedStream && startFaceCaptureBtn) startFaceCaptureBtn.disabled = false; else if(startFaceCaptureBtn) startFaceCaptureBtn.disabled = true; }).catch(error => { if(startFaceCaptureBtn) startFaceCaptureBtn.disabled = true; }); }
        function resetStep6UI() { console.log("Resetting Step 6 UI..."); if (faceCaptureSection) faceCaptureSection.classList.remove('hidden'); if (startFaceCaptureBtn) { startFaceCaptureBtn.classList.remove('hidden'); startFaceCaptureBtn.disabled = true; } if (retakeFaceCaptureBtn) { retakeFaceCaptureBtn.classList.add('hidden'); retakeFaceCaptureBtn.disabled = true; } if (capturedFacesContainer) { capturedFacesContainer.classList.add('hidden'); capturedFacesContainer.innerHTML = ''; } if (faceGuideFrame) faceGuideFrame.classList.remove('visible', 'invalid'); if (instructionTextEl) instructionTextEl.classList.add('hidden'); if (countdownTextEl) countdownTextEl.classList.add('hidden'); if (statusTextEl) statusTextEl.classList.add('hidden'); if (overlayFace) { overlayFace.classList.remove('hidden'); overlayFace.querySelector('p').textContent = 'กำลังเตรียมกล้อง...'; overlayFace.querySelector('i').className = 'fas fa-camera-retro'; } if(debugInfoEl) debugInfoEl.classList.add('hidden'); if (videoRecordingSection) { videoRecordingSection.classList.add('hidden'); videoRecordingSection.classList.remove('active'); } if (recordingIndicator) recordingIndicator.classList.add('hidden'); if (recordingInstructionContainer) recordingInstructionContainer.classList.remove('visible'); if (startRecordingBtn) { startRecordingBtn.classList.remove('hidden'); startRecordingBtn.innerHTML = '<i class="fas fa-microphone"></i> เริ่มบันทึกวิดีโอ'; startRecordingBtn.disabled = true; } if (stopRecordingBtn) { stopRecordingBtn.classList.add('hidden'); stopRecordingBtn.disabled = true; } if (videoPreviewContainer) videoPreviewContainer.classList.add('hidden'); if (videoPreview?.src) { try { URL.revokeObjectURL(videoPreview.src); } catch (e) {} videoPreview.src = ''; } if (submitKycBtn) { submitKycBtn.classList.add('hidden'); submitKycBtn.disabled = true; } currentFaceActionIndex = 0; faceActionStartTime = null; faceActionsSource.forEach(a => a.captured = false); capturedFaces = []; isProcessing = false; isFaceProcessing = false; if (noFaceDetectedTimeout) clearTimeout(noFaceDetectedTimeout); noFaceDetectedTimeout = null; recordedChunks = []; let recordedVideoBlob = null; if (mediaRecorder?.state !== 'inactive') { try { mediaRecorder.stop(); } catch (e) {} } mediaRecorder = null; console.log("Step 6 UI reset complete."); }
        function showRecordingInstructionAlert() { if (typeof Swal === 'undefined' || !recordingInstruction) return; const instructionText = recordingInstruction.textContent.trim(); if (!instructionText) { showError("ข้อผิดพลาด", "ไม่พบข้อความสำหรับอ่านออกเสียง"); return; } Swal.fire({ title: 'คำแนะนำการบันทึกวิดีโอ', html: `<p style="margin-bottom: 15px;">กรุณาอ่านออกเสียงข้อความต่อไปนี้ให้ชัดเจน โดยมองที่กล้อง:</p><p style="font-weight: bold; color: var(--primary-color); font-size: 1.1em; line-height: 1.5; background-color: #f0f0f0; padding: 10px; border-radius: 8px;">${instructionText}</p>`, icon: 'info', confirmButtonText: 'รับทราบและเริ่มบันทึก', confirmButtonColor: 'var(--primary-color)', allowOutsideClick: false, showCancelButton: true, cancelButtonText: 'ยกเลิก', cancelButtonColor: '#757575', }).then((result) => { if (result.isConfirmed) startRecording(); else if (startRecordingBtn) startRecordingBtn.disabled = false; }); }

      
      async function startRecording() {
          console.log("startRecording: --- เริ่มต้นฟังก์ชัน V3 ---");

          // --- 1. ตรวจสอบ Element และ State ที่จำเป็น ---
          if (!startRecordingBtn || !videoPreviewContainer || !submitKycBtn || !stopRecordingBtn || !recordingIndicator || !videoRecordingSection || !recordingInstructionContainer || !videoElementVideo) {
              console.error("startRecording: ERROR - ไม่พบ Element ที่จำเป็นบางตัว!");
              return;
          }
          console.log("startRecording: ตรวจสอบ Elements: ผ่าน");
          if (!step6VideoWatched) {
              console.log("startRecording: เงื่อนไขไม่ผ่าน - ยังไม่ได้ดูวิดีโอแนะนำ");
              showError('ยังไม่ได้ดูวิดีโอแนะนำ', 'กรุณาดูวิดีโอแนะนำก่อนเริ่มบันทึก');
              showFaceVideoGuide();
              return;
          }
          console.log("startRecording: ตรวจสอบ Video Watched: ผ่าน");
          if (!window.MediaRecorder) {
              console.log("startRecording: เงื่อนไขไม่ผ่าน - Browser ไม่รองรับ MediaRecorder");
              showError('เบราว์เซอร์ไม่รองรับ', 'ขออภัย เบราว์เซอร์ของคุณไม่รองรับฟังก์ชันบันทึกวิดีโอ');
              return;
          }
          console.log("startRecording: ตรวจสอบ MediaRecorder Support: ผ่าน");

          // --- 2. ปิดปุ่มเริ่ม และแสดงสถานะ Loading ---
          startRecordingBtn.disabled = true;
          startRecordingBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> กำลังเตรียม...';
          console.log("startRecording: ปิดปุ่มเริ่ม และแสดง Loading");

          // --- 3. ตรวจสอบ/เตรียม Stream และ Video Element ---
          console.log("startRecording: กำลังตรวจสอบ Stream/Video...");
          let isStreamReady = false;
          try {
              if (!stream?.active || !stream.getAudioTracks().length > 0 || !stream.getVideoTracks().length > 0 || videoElementVideo.readyState < videoElementVideo.HAVE_ENOUGH_DATA) {
                  console.log("startRecording: Stream/Video ไม่พร้อม, กำลังเรียก init...");
                   if(overlayFace && overlayFace.classList.contains('hidden')) {
                       overlayFace.querySelector('p').textContent = 'กำลังเชื่อมต่อกล้อง/ไมค์...';
                       overlayFace.querySelector('i').className = 'fas fa-sync fa-spin';
                       overlayFace.classList.remove('hidden');
                   }
                  stream = await initWebcamStreamOnly();
                  if (!stream?.active) { throw new Error("StreamInitFailed"); }
                  console.log("startRecording: ได้ Stream ใหม่, รอ Video Element...");
                  await new Promise(resolve => setTimeout(resolve, 300));
                  if (videoElementVideo.readyState < 3) {
                       throw new Error(`VideoElementNotReady (State: ${videoElementVideo.readyState})`);
                  }
                  console.log("startRecording: Stream/Video พร้อม (หลัง init)");
                  isStreamReady = true;
              } else {
                  console.log("startRecording: Stream/Video พร้อม (ตรวจสอบครั้งแรก)");
                  isStreamReady = true;
              }
          } catch (streamError) {
               console.error("startRecording: *** ERROR ตอนเตรียม Stream/Video: ***", streamError);
               showError('กล้อง/ไมค์ไม่พร้อม', 'ไม่สามารถเข้าถึงกล้องหรือไมโครโฟนได้: ' + streamError.message);
               startRecordingBtn.disabled = false;
               startRecordingBtn.innerHTML = '<i class="fas fa-microphone"></i> เริ่มบันทึกวิดีโอ';
               if(overlayFace) overlayFace.classList.add('hidden');
               console.log("startRecording: รีเซ็ต UI หลัง Stream Error");
               return;
          } finally {
                if(overlayFace && !overlayFace.classList.contains('hidden') && stream?.active) {
                     overlayFace.classList.add('hidden');
                }
          }

          if (!isStreamReady) {
              console.error("startRecording: ออกจากฟังก์ชันเนื่องจาก Stream ไม่พร้อม (หลัง try-finally)");
               if (!startRecordingBtn.disabled) {
                   startRecordingBtn.disabled = false;
                   startRecordingBtn.innerHTML = '<i class="fas fa-microphone"></i> เริ่มบันทึกวิดีโอ';
               }
              return;
          }

          // --- 4. รีเซ็ต State และ UI อื่นๆ ---
          console.log("startRecording: รีเซ็ต State และ UI Preview...");
          recordedChunks = [];
          recordedVideoBlob = null;
          videoPreviewContainer.classList.add('hidden');
          if (videoPreview?.src && videoPreview.src.startsWith('blob:')) { try { URL.revokeObjectURL(videoPreview.src); } catch (e) {} }
          if (videoPreview) videoPreview.src = '';
          submitKycBtn.classList.add('hidden'); submitKycBtn.disabled = true;
          console.log("startRecording: รีเซ็ต State เสร็จสิ้น");

          // --- 5. สร้าง MediaRecorder และเริ่มบันทึก ---
          try {
              // *** START MODIFICATION: Add Bitrate Options ***
              const targetVideoBitrate = 2000000; // Target 2 Mbps (Adjust as needed)
              const targetAudioBitrate = 96000; // Target 96 kbps (Adjust as needed)

              const options = {
                  // Let browser choose mimeType for better compatibility
                  audioBitsPerSecond: targetAudioBitrate,
                  videoBitsPerSecond: targetVideoBitrate
              };
              console.log("startRecording: MediaRecorder Options:", options);
              // *** END MODIFICATION ***

              console.log("startRecording: กำลังสร้าง MediaRecorder Instance...");
              // Pass the options object to the constructor
              mediaRecorder = new MediaRecorder(stream, options);
              console.log(`startRecording: สร้าง MediaRecorder สำเร็จ. Requested options: ${JSON.stringify(options)}, Actual mimeType: ${mediaRecorder.mimeType || '(Browser default)'}`);


              // กำหนด Event Handlers (use your existing complete handlers)
              console.log("startRecording: กำลังกำหนด Event Handlers...");
              mediaRecorder.ondataavailable = (event) => {
                   if (event.data && event.data.size > 0) {
                      recordedChunks.push(event.data);
                   }
              };
              mediaRecorder.onstop = () => {
                  console.log(`Recorder stopped. Chunks: ${recordedChunks.length}. Final mimeType: ${mediaRecorder.mimeType}`);
                  recordingIndicator.classList.add('hidden');
                  videoRecordingSection.classList.remove('active');
                  recordingInstructionContainer.classList.remove('visible');
                  stopRecordingBtn.classList.add('hidden');
                  stopRecordingBtn.disabled = true;
                  startRecordingBtn.classList.remove('hidden');
                  startRecordingBtn.innerHTML = '<i class="fas fa-redo"></i> บันทึกวิดีโอใหม่';
                  startRecordingBtn.disabled = false;

                  if (recordedChunks.length === 0) {
                      showError('บันทึกวิดีโอผิดพลาด', 'ไม่สามารถบันทึกข้อมูลวิดีโอได้ (No data chunks)');
                      recordedVideoBlob = null; submitKycBtn.classList.add('hidden'); submitKycBtn.disabled = true; return;
                  }
                  // Use the actual mimeType if available, fallback carefully
                  const actualMimeType = mediaRecorder.mimeType || (recordedChunks[0]?.type) || 'video/webm'; // Fallback to webm if needed
                  const blobProperty = { type: actualMimeType };
                  try {
                      const videoBlob = new Blob(recordedChunks, blobProperty);
                      if (videoBlob.size === 0) {
                          showError('บันทึกวิดีโอผิดพลาด', 'ไฟล์วิดีโอมีขนาด 0');
                          recordedVideoBlob = null; submitKycBtn.classList.add('hidden'); submitKycBtn.disabled = true; return;
                      }
                      recordedVideoBlob = videoBlob;
                      // *** ADDED SIZE LOG ***
                      console.log(`Video Blob created. Size: ${(recordedVideoBlob.size / 1024 / 1024).toFixed(2)} MB, Type: ${recordedVideoBlob.type}`);

                      const videoUrl = URL.createObjectURL(recordedVideoBlob);
                      if (videoPreview) {
                           videoPreview.src = videoUrl;
                           videoPreview.onloadedmetadata = () => console.log("Video metadata loaded.");
                           videoPreview.onerror = (e) => { console.error("Preview Error:", e); showError('แสดงตัวอย่างไม่ได้'); /*...*/ };
                      }
                      videoPreviewContainer.classList.remove('hidden');
                      submitKycBtn.classList.remove('hidden'); submitKycBtn.disabled = false;
                      videoPreviewContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                  } catch(blobError) {
                      showError('เกิดข้อผิดพลาด', 'สร้างไฟล์วิดีโอไม่ได้: ' + blobError.message);
                      recordedVideoBlob = null; submitKycBtn.classList.add('hidden'); submitKycBtn.disabled = true;
                  }
              };
              mediaRecorder.onerror = (event) => {
                  console.error("MediaRecorder onerror:", event.error || event);
                  let errorDetail = event.error ? `${event.error.name}: ${event.error.message}` : 'Unknown error';
                  showError('เกิดข้อผิดพลาดในการบันทึกวิดีโอ', errorDetail);
                  recordingIndicator.classList.add('hidden');
                  videoRecordingSection.classList.remove('active');
                  recordingInstructionContainer.classList.remove('visible');
                  stopRecordingBtn.classList.add('hidden'); stopRecordingBtn.disabled = true;
                  startRecordingBtn.classList.remove('hidden'); startRecordingBtn.disabled = false;
                  startRecordingBtn.innerHTML = '<i class="fas fa-microphone"></i> เริ่มบันทึกวิดีโอ';
                  recordedVideoBlob = null; submitKycBtn.classList.add('hidden'); submitKycBtn.disabled = true;
              };
              console.log("startRecording: กำหนด Event Handlers เสร็จสิ้น");

              // --- 5.1 อัปเดต UI เป็นสถานะ "กำลังบันทึก" ---
              console.log("startRecording: กำลังอัปเดต UI เป็น 'กำลังบันทึก'...");
              startRecordingBtn.classList.add('hidden');
              if (stopRecordingBtn) {
                   stopRecordingBtn.classList.remove('hidden'); stopRecordingBtn.disabled = false;
                   console.log("startRecording: แสดง/เปิด ปุ่ม Stop สำเร็จ");
              } else {
                  throw new Error("Element stopRecordingBtn not found during UI update!");
              }
              if (recordingIndicator) recordingIndicator.classList.remove('hidden');
              if (videoRecordingSection) videoRecordingSection.classList.add('active');
              if (recordingInstructionContainer) recordingInstructionContainer.classList.add('visible');
              console.log("startRecording: อัปเดต UI 'กำลังบันทึก' เสร็จสิ้น");

              // --- 5.2 เริ่มการบันทึกจริง ---
              console.log("startRecording: กำลังเรียก mediaRecorder.start()...");
              mediaRecorder.start();
              console.log("startRecording: เรียก .start() แล้ว. State ทันที:", mediaRecorder.state);

          } catch (error) {
              // --- 6. จัดการ Error ที่อาจเกิดขึ้นตอนสร้าง/เริ่ม MediaRecorder ---
              console.error("startRecording: *** CATCH BLOCK Activated: ERROR ระหว่าง Setup/Start MediaRecorder: ***", error);
              // Show more specific error if possible (e.g., unsupported bitrate)
              let detailedMsg = `ไม่สามารถเริ่มบันทึกวิดีโอได้ (${error.name || 'Unknown Error'})`;
              if (error.message) {
                 detailedMsg += `: ${error.message}`;
              }
               if (error.name === 'NotSupportedError') {
                   detailedMsg += '. อาจเป็นไปได้ว่า Browser ไม่รองรับค่า Bitrate ที่กำหนด.';
               }
              showError('เกิดข้อผิดพลาด', detailedMsg);

              // --- **รีเซ็ต UI กลับไปสถานะเริ่มต้นให้สมบูรณ์ 100%** ---
              console.log("startRecording: กำลังรีเซ็ต UI ใน Catch Block...");
              if (startRecordingBtn) {
                  startRecordingBtn.disabled = false;
                  startRecordingBtn.classList.remove('hidden');
                  startRecordingBtn.innerHTML = '<i class="fas fa-microphone"></i> เริ่มบันทึกวิดีโอ';
                  console.log("startRecording: รีเซ็ตปุ่ม Start ใน Catch");
              } else { console.error("startRecording: Catch - ไม่พบ startRecordingBtn!"); }

              if (stopRecordingBtn) {
                   stopRecordingBtn.classList.add('hidden');
                   stopRecordingBtn.disabled = true;
                   console.log("startRecording: ซ่อน/ปิด ปุ่ม Stop ใน Catch");
               } else { console.error("startRecording: Catch - ไม่พบ stopRecordingBtn!"); }

              if (recordingIndicator) recordingIndicator.classList.add('hidden');
              if (videoRecordingSection) videoRecordingSection.classList.remove('active');
              if (recordingInstructionContainer) recordingInstructionContainer.classList.remove('visible');
              recordedChunks = [];
              recordedVideoBlob = null;
              console.log("startRecording: รีเซ็ต UI และ State เสร็จสิ้นหลังเกิด Error ใน Catch");
          }
          console.log("startRecording: --- สิ้นสุดฟังก์ชัน ---");
      } 
      
        function stopRecording() { if (!stopRecordingBtn || !mediaRecorder) return; console.log("Stop recording clicked. State:", mediaRecorder.state); stopRecordingBtn.disabled = true; if (mediaRecorder.state === 'recording' || mediaRecorder.state === 'paused') { try { mediaRecorder.stop(); } catch (e) { console.warn("Error calling mediaRecorder.stop():", e); recordingIndicator?.classList.add('hidden'); videoRecordingSection?.classList.remove('active'); recordingInstructionContainer?.classList.remove('visible'); stopRecordingBtn?.classList.add('hidden'); startRecordingBtn?.classList.remove('hidden'); startRecordingBtn?.removeAttribute('disabled'); } } else { console.warn("Stop called but state is:", mediaRecorder.state); recordingIndicator?.classList.add('hidden'); videoRecordingSection?.classList.remove('active'); recordingInstructionContainer?.classList.remove('visible'); stopRecordingBtn?.classList.add('hidden'); startRecordingBtn?.classList.remove('hidden'); startRecordingBtn?.removeAttribute('disabled'); } }
       function removeVideo() {
    // --- 1. ตรวจสอบ Element ที่จำเป็น ---
    // (ใช้ element เดิมที่คุณมีอยู่)
    if (!videoPreview || !videoPreviewContainer || !submitKycBtn || !startRecordingBtn || !stopRecordingBtn || !recordingInstructionContainer || !videoRecordingSection) {
        console.error("removeVideo: Missing required DOM elements.");
        return; // ออกถ้าหา element ไม่เจอ
    }

    console.log("Removing recorded video...");

    // --- 2. เคลียร์ Video Preview ---
    // ตรวจสอบและยกเลิก Object URL เดิมเพื่อคืน Memory
    if (videoPreview.src && videoPreview.src.startsWith('blob:')) {
        try {
            URL.revokeObjectURL(videoPreview.src);
            console.log("Revoked video preview URL.");
        } catch (e) {
            console.warn("Could not revoke video preview URL:", e);
        }
    }
    videoPreview.src = ''; // เคลียร์ src ของ element <video>
    videoPreviewContainer.classList.add('hidden'); // ซ่อนกรอบ preview

    // --- 3. เคลียร์ข้อมูลวิดีโอที่เก็บไว้ ---
    recordedChunks = [];      // เคลียร์ array ของ chunks
    recordedVideoBlob = null; // *** สำคัญ: เคลียร์ Blob ที่เก็บไว้ออกไปด้วย ***
    console.log("Cleared recordedChunks and recordedVideoBlob.");

    // --- 4. รีเซ็ตสถานะปุ่ม ---
    submitKycBtn.classList.add('hidden'); // ซ่อนปุ่ม Submit
    submitKycBtn.disabled = true;         // ปิดปุ่ม Submit

    startRecordingBtn.innerHTML = '<i class="fas fa-microphone"></i> เริ่มบันทึกวิดีโอ'; // เปลี่ยนข้อความปุ่มเริ่ม
    startRecordingBtn.classList.remove('hidden');      // แสดงปุ่มเริ่ม
    startRecordingBtn.disabled = false;                 // เปิดปุ่มเริ่ม

    stopRecordingBtn.classList.add('hidden');          // ซ่อนปุ่มหยุด
    stopRecordingBtn.disabled = true;                  // ปิดปุ่มหยุด

    // --- 5. รีเซ็ต UI อื่นๆ ---
    recordingInstructionContainer.classList.remove('visible'); // ซ่อนกรอบข้อความแนะนำ
    videoRecordingSection.classList.remove('active');   // เอา class active ออก
    // ซ่อน indicator (ถ้ามี element และยังไม่ถูกซ่อน)
    if (recordingIndicator) {
        recordingIndicator.classList.add('hidden');
    }

    console.log("Video removal complete. UI reset.");
}
        function dataURItoBlob(dataURI) { if (!dataURI?.includes(',')) { console.error("Invalid data URI:", dataURI?.substring(0, 50)); return null; } try { const byteString = atob(dataURI.split(',')[1]); const mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0]; const ab = new ArrayBuffer(byteString.length); const ia = new Uint8Array(ab); for (let i = 0; i < byteString.length; i++) ia[i] = byteString.charCodeAt(i); return new Blob([ab], { type: mimeString }); } catch (e) { console.error("Error converting data URI to Blob:", e); return null; } }
  // --- Utility Function (จำเป็นต้องมีอยู่) ---
function dataURItoBlob(dataURI) {
    if (!dataURI?.includes(',')) {
        console.error("Invalid data URI:", dataURI?.substring(0, 50));
        return null;
    }
    try {
        // convert base64 to raw binary data held in a string
        // doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this
        const byteString = atob(dataURI.split(',')[1]);

        // separate out the mime component
        const mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];

        // write the bytes of the string to an ArrayBuffer
        const ab = new ArrayBuffer(byteString.length);
        const ia = new Uint8Array(ab);
        for (let i = 0; i < byteString.length; i++) {
            ia[i] = byteString.charCodeAt(i);
        }
        return new Blob([ab], { type: mimeString });
    } catch (e) {
        console.error("Error converting data URI to Blob:", e);
        return null;
    }
}

         function handleSubmitKyc() {
          console.log("handleSubmitKyc: Attempting FINAL KYC submission...");

          // ตรวจสอบข้อมูล Step 6
          if (!validateStep6()) {
              console.warn("handleSubmitKyc: Step 6 validation failed. Cannot submit.");
               if(submitKycBtn && submitKycBtn.disabled) { // Ensure button is re-enabled if validation fails while loading
                   resetSubmitButton();
               }
              return;
          }

          // *** START SIZE CHECK ***
          const MAX_VIDEO_SIZE_MB = 4;
          const MAX_VIDEO_SIZE_BYTES = MAX_VIDEO_SIZE_MB * 1024 * 1024;

          if (recordedVideoBlob && recordedVideoBlob.size > MAX_VIDEO_SIZE_BYTES) {
              const actualSizeMB = (recordedVideoBlob.size / 1024 / 1024).toFixed(2);
              console.warn(`handleSubmitKyc: Video size (${actualSizeMB} MB) exceeds limit (${MAX_VIDEO_SIZE_MB} MB).`);
              showError(
                  'วิดีโอมีขนาดใหญ่เกินไป',
                  `ไฟล์วิดีโอมีขนาดใหญ่กว่า ${MAX_VIDEO_SIZE_MB}MB (${actualSizeMB}MB). กรุณาลองบันทึกใหม่อีกครั้ง (ระบบพยายามบีบอัดแล้วแต่ยังเกินกำหนด)`
              );
              // Reset the recording state so the user can try again
              removeVideo(); // Use removeVideo to reset UI and clear blob
              // resetSubmitButton(); // removeVideo should handle the submit button state now
              return; // Stop the submission process
          }
           // *** END SIZE CHECK ***


          // แสดงสถานะกำลังโหลด
          if(submitKycBtn) {
              submitKycBtn.disabled = true;
              submitKycBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> กำลังส่งข้อมูล...';
          }

          // --- Continue with existing handleSubmitKyc logic from here ---
           const prevStepBtn = document.querySelector('#step-6 .prev-step'); // Be more specific
            if (prevStepBtn) prevStepBtn.style.display = 'none';

             // แสดง progress bar
            const progressContainer = document.querySelector('.progress-container');
            const progressBar = document.getElementById('upload-progress');
            const progressText = document.getElementById('progress-text');

            if (progressContainer) progressContainer.style.display = 'block';
            if (progressBar) progressBar.value = 0;
            if (progressText) progressText.textContent = '0%';


          if (recordedVideoBlob && recordedVideoBlob instanceof Blob && recordedVideoBlob.size > 0) {
              console.log("handleSubmitKyc: Video blob is valid. Size:", recordedVideoBlob.size, "bytes");

              const formData = new FormData();

              // --- Append standard data ---
              if (liffUserId) {
                  formData.append('line_user_id', liffUserId);
              } else {
                   showError("ข้อผิดพลาดร้ายแรง", "ไม่พบ User ID");
                   resetSubmitButton(); // Call the reset function
                   return;
              }
              if (liffDisplayName) formData.append('line_display_name', liffDisplayName);
              if (liffPictureUrl) formData.append('line_profile_url', liffPictureUrl);
              // --- Add any OTHER form data needed by the final API call ---
              // e.g., formData.append('some_other_field', someValue);
              // Make sure ALL necessary fields are appended here before sending


              // --- Append the video blob ---
              // Use the actual mime type if possible, otherwise determine extension
              const mimeType = recordedVideoBlob.type || 'video/mp4'; // Default to mp4 if type missing
              let fileExtension = mimeType.split('/')[1]?.split(';')[0] || 'mp4';
               // Fix common non-standard webm type from some browsers
               if (fileExtension.toLowerCase() === 'x-matroska') fileExtension = 'webm';

              const videoFileName = `verification_video_${liffUserId}_${Date.now()}.${fileExtension}`;
              formData.append('verification_video', recordedVideoBlob, videoFileName); // Use the correct field name 'verification_video'
              console.log(`Appended final video: ${videoFileName}, Type: ${mimeType}`);

              // --- Send the data ---
              sendFinalFormData(formData); // Call your existing function to send

          } else {
              console.error("handleSubmitKyc: Critical Error - recordedVideoBlob is invalid or missing AFTER size check (should not happen).");
              showError("ข้อผิดพลาดในการส่งข้อมูล", "ไม่พบข้อมูลวิดีโอที่ถูกต้อง");
               resetSubmitButton(); // Call the reset function
          }
      }
      function resetSubmitButton() {
          if(submitKycBtn) {
              submitKycBtn.disabled = false;
              submitKycBtn.innerHTML = 'ส่งข้อมูลเพื่อตรวจสอบ <i class="fas fa-paper-plane"></i>';
          }

          // แสดงปุ่มย้อนกลับอีกครั้ง
          const prevStepBtn = document.querySelector('#step-6 .prev-step'); // Be more specific
          if (prevStepBtn) prevStepBtn.style.display = ''; // Use empty string to revert to default display

          // ซ่อน progress bar
          const progressContainer = document.querySelector('.progress-container');
           const progressBar = document.getElementById('upload-progress');
           const progressText = document.getElementById('progress-text');
          if (progressContainer) progressContainer.style.display = 'none';
          if (progressBar) progressBar.value = 0;
          if (progressText) progressText.textContent = '0%';
      }


function sendFinalFormData(formData) {
    // กำหนด URL ของ API ใหม่
    const API_URL = "https://mg-no1member.vercel.app/api/upsertUser";
    
    // แสดงความคืบหน้าการอัปโหลด
    const progressBar = document.getElementById('upload-progress');
    const progressText = document.getElementById('progress-text');
    const progressContainer = document.querySelector('.progress-container');
    
    if (progressContainer) progressContainer.style.display = 'block';
    if (progressBar) progressBar.value = 0;
    if (progressText) progressText.textContent = '0%';

    // สร้าง XMLHttpRequest เพื่อติดตามความคืบหน้า
    const xhr = new XMLHttpRequest();
    
    // ติดตามความคืบหน้า
    xhr.upload.onprogress = function(event) {
        if (event.lengthComputable) {
            const percentComplete = (event.loaded / event.total) * 100;
            if (progressBar) progressBar.value = percentComplete;
            if (progressText) progressText.textContent = `${percentComplete.toFixed(0)}%`;
            console.log(`Upload progress: ${percentComplete.toFixed(2)}%`);
        }
    };
    
    // เมื่อส่งเสร็จสมบูรณ์
    xhr.onload = function() {
        if (xhr.status >= 200 && xhr.status < 300) {
            try {
                const response = JSON.parse(xhr.responseText);
                console.log("sendFinalFormData: Success response:", response);
                
                if (response.message) {
                    showSuccess("ส่งข้อมูลสำเร็จ", response.message);
                    
                    // ทำงานอื่นๆ หลังจากส่งสำเร็จ
                    // เช่น เปลี่ยนหน้า หรือแสดงข้อความขอบคุณ
                    if (typeof onKycSubmitSuccess === 'function') {
                        onKycSubmitSuccess(response);
                    }
                } else {
                    showSuccess("ส่งข้อมูลสำเร็จ", "ข้อมูลของคุณถูกส่งเรียบร้อยแล้ว");
                }
            } catch (e) {
                console.error("sendFinalFormData: Error parsing response:", e);
                showError("ข้อผิดพลาด", "ไม่สามารถประมวลผลการตอบกลับจากเซิร์ฟเวอร์ได้");
            }
        } else {
            console.error("sendFinalFormData: Server error:", xhr.status, xhr.statusText);
            try {
                const errorResponse = JSON.parse(xhr.responseText);
                showError("ข้อผิดพลาดจากเซิร์ฟเวอร์", errorResponse.details || `รหัสข้อผิดพลาด: ${xhr.status}`);
            } catch (e) {
                showError("ข้อผิดพลาดจากเซิร์ฟเวอร์", `รหัสข้อผิดพลาด: ${xhr.status}`);
            }
        }
        
        // ซ่อน progress bar และรีเซ็ตปุ่ม
        if (progressContainer) progressContainer.style.display = 'none';
        resetSubmitButton();
    };
    
    // จัดการข้อผิดพลาด
    xhr.onerror = function() {
        console.error("sendFinalFormData: Network error");
        showError("ข้อผิดพลาดเครือข่าย", "ไม่สามารถเชื่อมต่อกับเซิร์ฟเวอร์ได้");
        if (progressContainer) progressContainer.style.display = 'none';
        resetSubmitButton();
    };
    
    // จัดการกรณีที่ผู้ใช้ยกเลิกการอัปโหลด
    xhr.onabort = function() {
        console.warn("sendFinalFormData: Upload aborted by user");
        showError("การอัปโหลดถูกยกเลิก", "คุณได้ยกเลิกการอัปโหลดข้อมูล");
        if (progressContainer) progressContainer.style.display = 'none';
        resetSubmitButton();
    };
    
    // เปิดการเชื่อมต่อและส่งข้อมูล
    xhr.open('POST', API_URL, true);
    xhr.send(formData);
    
    console.log("sendFinalFormData: Sending data to API:", API_URL);
}
     
        function validateStep6() {
    // --- 1. ตรวจสอบว่าดูวิดีโอแนะนำ Step 6 หรือยัง ---
    if (!step6VideoWatched) {
        showError('ยังไม่ได้ดูวิดีโอแนะนำ', 'กรุณาดูวิดีโอแนะนำการยืนยันใบหน้าและวิดีโอก่อน');
        showFaceVideoGuide(); // แสดงวิดีโอแนะนำอีกครั้ง
        return false; // ไม่ผ่าน validation
    }

    // --- 2. ตรวจสอบว่าบันทึกภาพใบหน้าครบทุกขั้นตอนหรือไม่ ---
    const allActionsDone = currentFaceActionIndex >= faceActionsSource.length; // เช็คว่าทำครบทุก action หรือยัง
    const sufficientFacesCaptured = capturedFaces.length >= faceActionsSource.length; // เช็คว่ามีจำนวนรูปที่ capture ครบหรือไม่

    if (!allActionsDone || !sufficientFacesCaptured) {
        showError('ยังไม่บันทึกใบหน้า', 'กรุณาบันทึกภาพใบหน้าให้ครบทุกขั้นตอนก่อน');
        // แสดงส่วนบันทึกใบหน้า และซ่อนส่วนวิดีโอ (ถ้าถูกแสดงอยู่)
        if (faceCaptureSection) faceCaptureSection.classList.remove('hidden');
        if (videoRecordingSection) videoRecordingSection.classList.add('hidden');
        // เลื่อนจอไปที่ส่วนบันทึกใบหน้า
        faceCaptureSection?.scrollIntoView({ behavior: 'smooth', block: 'start' });
        // ลอง focus ที่ปุ่มถ่ายใหม่ หรือปุ่มเริ่มถ่าย (อันที่มองเห็นและใช้งานได้)
        if (retakeFaceCaptureBtn && !retakeFaceCaptureBtn.classList.contains('hidden') && !retakeFaceCaptureBtn.disabled) {
            retakeFaceCaptureBtn.focus();
        } else if (startFaceCaptureBtn && !startFaceCaptureBtn.classList.contains('hidden') && !startFaceCaptureBtn.disabled) {
            startFaceCaptureBtn.focus();
        }
        return false; // ไม่ผ่าน validation
    }

    // --- 3. ตรวจสอบว่าบันทึกวิดีโอเรียบร้อยและมีข้อมูล Blob หรือไม่ ---
    // *** แก้ไข: เปลี่ยนมาเช็คตัวแปร recordedVideoBlob ที่เก็บข้อมูลวิดีโอโดยตรง ***
    const videoRecorded = recordedVideoBlob && recordedVideoBlob.size > 0;

    if (!videoRecorded) {
        // แสดงข้อความผิดพลาดที่ชัดเจนขึ้น
        showError('ยังไม่บันทึกวิดีโอ', 'กรุณาบันทึกวิดีโอการยืนยันตัวตน (ไม่พบข้อมูลวิดีโอที่บันทึกไว้)');
        // เลื่อนจอไปที่ส่วนบันทึกวิดีโอ (ควรจะแสดงอยู่แล้ว แต่เผื่อไว้)
        if (videoRecordingSection) videoRecordingSection.classList.remove('hidden');
        videoRecordingSection?.scrollIntoView({ behavior: 'smooth', block: 'start' });
        // focus ที่ปุ่มเริ่มบันทึกวิดีโอ (หรือปุ่มบันทึกใหม่)
        startRecordingBtn?.focus();
        return false; // ไม่ผ่าน validation
    }

    // --- 4. ถ้าผ่านทุกการตรวจสอบ ---
    console.log("Step 6 validation passed (checked video blob).");
    return true; // ข้อมูลถูกต้อง พร้อม Submit
}

        // --- Utility Functions ---
        function showError(title, text) { if (typeof Swal !== 'undefined' && Swal.isLoading()) Swal.close(); if (typeof Swal !== 'undefined') Swal.fire({ icon: 'error', title: title, text: text, confirmButtonColor: 'var(--primary-color)', confirmButtonText: 'ตกลง' }); else { console.error("SweetAlert Error:", title, text); alert(`Error: ${title}\n${text}`); } }
        // ฟังก์ชันแสดงข้อความสำเร็จ
function showSuccess(title, message) {
    // ถ้ามี SweetAlert หรือ library อื่นๆ
    if (typeof Swal !== 'undefined') {
        Swal.fire({
            icon: 'success',
            title: title,
            text: message,
            confirmButtonText: 'ตกลง'
        });
    } else {
        alert(`${title}: ${message}`);
    }
    console.log(`Success: ${title} - ${message}`);
}

// ฟังก์ชันแสดงข้อความผิดพลาด
function showError(title, message) {
    console.error(`Error: ${title} - ${message}`);
    
    // ถ้ามี SweetAlert หรือ library อื่นๆ
    if (typeof Swal !== 'undefined') {
        Swal.fire({
            icon: 'error',
            title: title,
            text: message,
            confirmButtonText: 'ตกลง'
        });
    } else {
        alert(`${title}: ${message}`);
    }
}
        function shakeElement(element) { if (element?.classList) { element.classList.remove('shake'); void element.offsetWidth; element.classList.add('shake'); setTimeout(() => element.classList.remove('shake'), 500); } }

        // --- Auto-run on Load (LIFF Initialization and Profile Fetch) ---
        if (typeof liff !== 'undefined') {
            console.log("LIFF library found. Initializing...");
            liff.init({ liffId: "2006703040-rakJMkJk" }) // Use your actual LIFF ID
                .then(() => {
                    console.log("LIFF initialized successfully.");
                    if (!liff.isLoggedIn()) {
                        console.log("User is not logged in to LINE. Prompting login.");
                        liff.login(); // Automatically prompt for login
                    } else {
                        console.log("User is logged in to LINE.");
                        // Get profile information now
                        liff.getProfile()
                            .then(profile => {
                                // Store LIFF data in global variables
                                liffUserId = profile.userId;
                                liffDisplayName = profile.displayName;
                                liffPictureUrl = profile.pictureUrl || ''; // Store empty string if undefined

                                console.log('--- LIFF Profile ---');
                                console.log('User ID:', liffUserId);
                                console.log('Display Name:', liffDisplayName);
                                console.log('Profile URL:', liffPictureUrl || 'Not set');
                                console.log('--------------------');

                                // UI is ready, user can proceed by clicking slider button
                            })
                            .catch((err) => {
                                console.error("Error getting LIFF profile:", err);
                                showError("LIFF Profile Error", "Could not retrieve your LINE profile information.");
                            });
                    }
                })
                .catch((err) => {
                    console.error("LIFF initialization failed:", err);
                    showError("LIFF Error", "Could not initialize LINE integration. Please try again later.");
                });
        } else {
             console.log("LIFF library not found. This page should be opened within the LINE app.");
             // showError("เปิดใน LINE เท่านั้น", "กรุณาเปิดหน้านี้ผ่านแอปพลิเคชัน LINE");
        }

    }); // End DOMContentLoaded
</script>
</body>
</html>
